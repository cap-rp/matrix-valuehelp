{"version":3,"file":"Recommendations.js","names":["Recommendations","_dec","defineUI5Class","_dec2","methodOverride","_dec3","_dec4","publicExtension","_dec5","_dec6","extensible","OverrideExecution","Instead","_dec7","_dec8","finalExtension","_dec9","_dec10","_dec11","_dec12","_dec13","_dec14","_dec15","_dec16","_class","_class2","_ControllerExtension","_this","call","this","dataToBeAccepted","_exports","_inheritsLoose","_proto","prototype","onInit","telemetry","Telemetry","allRecommendedFields","internalModel","base","getView","getModel","previousContext","undefined","onAfterBinding","async","context","currentContextBasePath","getPath","split","previousContextBasePath","rootContext","isRecommendationEnabled","getProperty","_getRootContext","recommendations","isEnabled","setProperty","isFclEnabled","getAppComponent","_isFclEnabled","isFullScreen","getRootViewController","getHelper","getCurrentUIState","tryResetRecommendations","resetData","programmingModel","TransactionHelper","getProgrammingModel","CommonUtils","createRootContext","clearRecommendations","bindingContext","getBindingContext","recommendationHelper","_rootContext","fetchRecommendations","_context","Promise","resolve","fetchAndApplyRecommendations","currentContextsInfo","considerOnlyNewContext","isSuccess","sideEffects","getSideEffectsService","recommendationRegistry","getRecommendationsMapping","filteredContextsInfo","filter","contextInfo","standardRecommendationHelper","checkIfRecommendationRoleExistsForContext","contextsInfo","getContextsWithNoRecommendations","contexts","map","length","startTime","performance","now","recommendationData","endTime","updateResponseTimeInfo","updateAllRecommendedFields","updateDataFromRecommendationResponse","increaseCount","applyRecommendation","e","Log","error","storeRecommendationContexts","fetchAndApplyRecommendationsOnFieldChange","field","appComponent","isFieldRecommendationRelevant","checkIfFieldIsRecommendationRelevant","targets","fetchTargets","filteredRecommendationContexts","fetchFilteredRecommendationContexts","recommendationContext","filteredRecommendationContext","includes","clearIgnoredContexts","onBeforeAcceptRecommendations","_params","acceptRecommendations","promises","propertyPath","push","value","all","recommendationResponses","storeRecommendations","contextPaths","recommendationContexts","forEach","contextPath","index","indexOf","contextIdentifier","key","contextPathFromKey","substring","lastIndexOf","fetchFilteredRecommendationData","filteredTargets","filterRecommendationsData","Object","keys","assign","considerRecommendationContexts","version","isRecommendationAcceptable","splitPathAndCheckIfRecommendationAcceptable","ctxtPath","pathArray","newPath","newPathArray","slice","some","rightMostContext","getRightmostContext","dataToBeFiltered","fetchDataToBeFiltered","adjustAcceptAllParams","filterRecommendationData","filterRecommendationContexts","params","text","propertyPathFromKey","matchingContext","isRecommendationFieldNull","fetchAcceptAllParams","getController","addContextIdentifierText","checkIfRecommendationsExist","ignoreRecommendationForContexts","view","setCurrentRootContext","resetRecommendations","storeDataForTelemetry","recommendationOptionChoosen","RecommendationDialogDecision","Accept","updateData","Ignore","storeData","increaseTelemetryDataCount","updateTelemetryDataBasedOnUserSelection","fieldPath","selectedValue","viewBindingContextPath","newRecommendationsForCurrentContexts","response","ControllerExtension","_applyDecoratedDescriptor","getOwnPropertyDescriptor"],"sources":["./Recommendations.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport { defineUI5Class, extensible, finalExtension, methodOverride, publicExtension } from \"sap/fe/base/ClassSupport\";\nimport type PageController from \"sap/fe/core/PageController\";\nimport { recommendationHelper } from \"sap/fe/core/helpers/RecommendationHelper\";\nimport type {\n\tRecommendationContextsInfo,\n\tRecommendationInfo,\n\tStandardRecommendationResponse\n} from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport { standardRecommendationHelper } from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport type Control from \"sap/ui/core/Control\";\nimport ControllerExtension from \"sap/ui/core/mvc/ControllerExtension\";\nimport OverrideExecution from \"sap/ui/core/mvc/OverrideExecution\";\nimport type Context from \"sap/ui/model/Context\";\nimport type JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type { default as ODataV4Context } from \"sap/ui/model/odata/v4/Context\";\nimport type { FEView } from \"../BaseController\";\nimport CommonUtils from \"../CommonUtils\";\nimport type FclController from \"../rootView/Fcl.controller\";\nimport TransactionHelper from \"./editFlow/TransactionHelper\";\n\nimport { RecommendationDialogDecision } from \"../controls/Recommendations/ConfirmRecommendationDialog\";\nimport type { RecommendationTelemetry } from \"../services/TelemetryServiceFactory\";\nimport Telemetry from \"./recommendations/Telemetry\";\n\nexport type AcceptAllParams = {\n\trecommendationData?: RecommendationData[];\n};\n\nexport type RecommendationData = {\n\tcontext?: ODataV4Context;\n\tcontextIdentifier?: string[];\n\tcontextIdentifierText?: string[];\n\tpropertyPath?: string;\n\tvalue?: string;\n\ttext?: string;\n};\n@defineUI5Class(\"sap.fe.core.controllerextensions.Recommendations\")\nexport default class Recommendations extends ControllerExtension {\n\tbase!: PageController;\n\n\trecommendationContexts!: RecommendationContextsInfo[];\n\n\trootContext!: Context | undefined;\n\n\tinternalModel!: JSONModel;\n\n\ttelemetry!: Telemetry;\n\n\tallRecommendedFields!: string[];\n\n\t// the data shown in Accept/Ignore dialog of Recommendations\n\tdataToBeAccepted: RecommendationData[] = [];\n\n\tpreviousContext: Context | null | undefined;\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t@methodOverride()\n\tonInit(): void {\n\t\tthis.telemetry = new Telemetry();\n\t\tthis.allRecommendedFields = [];\n\t\tthis.internalModel = this.base.getView().getModel(\"internal\");\n\t\tthis.previousContext = undefined;\n\t}\n\n\t@methodOverride(\"_routing\")\n\tasync onAfterBinding(context: Context | null): Promise<void> {\n\t\tif (context) {\n\t\t\tconst currentContextBasePath = context.getPath().split(\"/\")[1];\n\t\t\tconst previousContextBasePath = this.previousContext?.getPath().split(\"/\")[1];\n\t\t\t//\tconsole.log('current::', currentContextBasePath);\n\t\t\t//\tconsole.log('previous', previousContextBasePath);\n\t\t\tthis.rootContext = undefined;\n\t\t\t// use internal model because we have to use this information across the application for different instances.\n\t\t\tlet isRecommendationEnabled = this.internalModel.getProperty(\"/isRecommendationEnabled\");\n\t\t\t// onAfter binding is called for all contexts\n\t\t\t// but we do not need to call the isEnabled hook all the time\n\t\t\t// so check if recommendation enabled is already available\n\t\t\tthis.previousContext = context;\n\t\t\tconst rootContext = await this._getRootContext(context as ODataV4Context);\n\t\t\tif (rootContext) {\n\t\t\t\tif (isRecommendationEnabled === undefined) {\n\t\t\t\t\tisRecommendationEnabled = this.base.recommendations.isEnabled(rootContext);\n\t\t\t\t\tthis.internalModel.setProperty(\"/isRecommendationEnabled\", isRecommendationEnabled);\n\t\t\t\t}\n\t\t\t\t//\tif(!this.previousContext) {\n\n\t\t\t\t//\t}\n\t\t\t\tconst isFclEnabled = this.base.getAppComponent()._isFclEnabled();\n\t\t\t\tconst isFullScreen = isFclEnabled\n\t\t\t\t\t? (this.base.getAppComponent().getRootViewController() as FclController).getHelper().getCurrentUIState().isFullScreen\n\t\t\t\t\t: true;\n\t\t\t\tif (currentContextBasePath !== previousContextBasePath) {\n\t\t\t\t\t// different contexts/ OP\n\t\t\t\t\t//\tconsole.log(\"run reset logic\")\n\t\t\t\t\tthis.tryResetRecommendations(rootContext as ODataV4Context);\n\t\t\t\t\tthis.telemetry.resetData();\n\t\t\t\t}\n\t\t\t\tif (isFclEnabled && !isFullScreen) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async _getRootContext(context: ODataV4Context): Promise<Context | undefined> {\n\t\tconst programmingModel = TransactionHelper.getProgrammingModel(context);\n\t\treturn CommonUtils.createRootContext(programmingModel, this.base.getView(), this.base.getAppComponent());\n\t}\n\n\t/**\n\t * Clear all recommendations currently available on the UI.\n\t * @public\n\t */\n\t@publicExtension()\n\tpublic clearRecommendations(): void {\n\t\tconst bindingContext = this.getView().getBindingContext();\n\t\tif (bindingContext) {\n\t\t\trecommendationHelper.clearRecommendations(this.base.getView(), bindingContext);\n\t\t}\n\t}\n\n\t/**\n\t * Check if recommendations are enabled or not.\n\t * @param _rootContext The root entity context\n\t * @returns True if recommendation is enabled. False if recommendation is disabled.\n\t * @public\n\t */\n\t@publicExtension()\n\t@extensible(OverrideExecution.Instead)\n\tpublic isEnabled(_rootContext: Context): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Method returns a boolean value indicating recommendation is enabled or not. In case called before\n\t * the enablement check is completed, method will return false which is the default value.\n\t * @returns True if recommendation is enabled else false.\n\t */\n\t@publicExtension()\n\t@finalExtension()\n\tpublic isRecommendationEnabled(): boolean {\n\t\treturn !!this.internalModel?.getProperty(\"/isRecommendationEnabled\");\n\t}\n\n\t/**\n\t * Fetch the recommendation for a specific context.\n\t * @param _context The context that shall be considered when fetching recommendations\n\t * @param _rootContext The root entity context\n\t * @returns The recommendation entries\n\t * @public\n\t */\n\t@publicExtension()\n\t@extensible(OverrideExecution.Instead)\n\tpublic async fetchRecommendations(_context: ODataV4Context[], _rootContext?: Context): Promise<StandardRecommendationResponse[]> {\n\t\treturn Promise.resolve([]);\n\t}\n\n\t/**\n\t * Fetch the recommendations and apply them on the UI.\n\t * @param currentContextsInfo Contexts Info that contains the context that shall be considered when fetching recommendations along with contextIdentifier\n\t * @param considerOnlyNewContext Boolean property indicating Recommendation\n\t * should be fetched only for new contexts with no recommendation fetch call\n\t * @returns `true` if the recommendations were fetched and applied correctly\n\t */\n\t@publicExtension()\n\tpublic async fetchAndApplyRecommendations(\n\t\tcurrentContextsInfo: RecommendationContextsInfo[],\n\t\tconsiderOnlyNewContext?: boolean\n\t): Promise<boolean> {\n\t\tlet isSuccess = false;\n\t\tconst sideEffects = this.base.getAppComponent().getSideEffectsService();\n\t\tconst recommendationRegistry = sideEffects.getRecommendationsMapping();\n\t\tconst filteredContextsInfo = currentContextsInfo.filter((contextInfo: RecommendationContextsInfo) => {\n\t\t\treturn standardRecommendationHelper.checkIfRecommendationRoleExistsForContext(contextInfo, recommendationRegistry);\n\t\t});\n\t\tif (this.isRecommendationEnabled()) {\n\t\t\tconst contextsInfo: RecommendationContextsInfo[] = considerOnlyNewContext\n\t\t\t\t? standardRecommendationHelper.getContextsWithNoRecommendations(filteredContextsInfo, this.internalModel)\n\t\t\t\t: filteredContextsInfo;\n\t\t\tconst contexts: ODataV4Context[] = contextsInfo.map(\n\t\t\t\t(contextInfo: RecommendationContextsInfo) => contextInfo.context\n\t\t\t) as ODataV4Context[];\n\t\t\tif (contexts && contexts.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tconst rootContext = await this._getRootContext(contexts[0]);\n\t\t\t\t\tconst startTime = performance.now();\n\t\t\t\t\tconst recommendationData = await this.base.recommendations.fetchRecommendations(contexts, rootContext);\n\t\t\t\t\tconst endTime = performance.now();\n\t\t\t\t\tthis.telemetry.updateResponseTimeInfo(endTime - startTime);\n\t\t\t\t\tif (recommendationData?.length) {\n\t\t\t\t\t\tthis.updateAllRecommendedFields(recommendationData);\n\t\t\t\t\t\tthis.telemetry.updateDataFromRecommendationResponse(recommendationData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if empty recommendations, then store it for telemetry purpose\n\t\t\t\t\t\tthis.telemetry.increaseCount(\"numberOfTimesEmptyRecommendations\");\n\t\t\t\t\t}\n\t\t\t\t\t// need to validate that the response is properly formatted\n\t\t\t\t\tisSuccess = this.applyRecommendation(recommendationData, contexts);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tLog.error(\"There was an error fetching the recommendations\", e as Error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.storeRecommendationContexts(filteredContextsInfo);\n\t\t}\n\n\t\treturn isSuccess;\n\t}\n\n\t/**\n\t * Fetch the recommendations on field change and apply them on the UI.\n\t * @param field The changed field.\n\t * @param contextInfo ContextInfo which contains the context is only considered when fetching the recommendations along with contextIdentifier\n\t * @returns `true` if the recommendation were fetched and applied correctly\n\t */\n\t@publicExtension()\n\tpublic async fetchAndApplyRecommendationsOnFieldChange(field: Control, contextInfo: RecommendationContextsInfo): Promise<boolean> {\n\t\tconst appComponent = this.base.getAppComponent();\n\t\tconst isFieldRecommendationRelevant = appComponent.getSideEffectsService().checkIfFieldIsRecommendationRelevant(field);\n\t\tif (isFieldRecommendationRelevant) {\n\t\t\t//getting the visible targets on the UI and their respective contexts\n\t\t\tconst targets = this.fetchTargets(true);\n\t\t\tconst filteredRecommendationContexts = this.fetchFilteredRecommendationContexts(targets);\n\t\t\t//filtering the child contexts from the available contexts\n\t\t\tconst recommendationContext = filteredRecommendationContexts.filter(function (filteredRecommendationContext) {\n\t\t\t\tif (\n\t\t\t\t\t(filteredRecommendationContext.context as ODataV4Context)\n\t\t\t\t\t\t.getPath()\n\t\t\t\t\t\t?.includes((contextInfo?.context as ODataV4Context).getPath())\n\t\t\t\t) {\n\t\t\t\t\treturn filteredRecommendationContext;\n\t\t\t\t}\n\t\t\t});\n\t\t\tstandardRecommendationHelper.clearIgnoredContexts(this.internalModel, (contextInfo?.context as ODataV4Context).getPath());\n\t\t\treturn this.fetchAndApplyRecommendations(recommendationContext);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the filtered recommendations from passed recommendations and then based on it we either show the filtered recommendations or not show the Accept all Dialog if there are no recommendations.\n\t * @param _params Params object containing recommendationData property which is an array of objects containing context, propertyPath, value and text for a recommendation\n\t * @returns Promise\n\t */\n\t@publicExtension()\n\t@extensible(\"AfterAsync\")\n\tpublic async onBeforeAcceptRecommendations(_params: AcceptAllParams): Promise<void> {\n\t\t//do nothing\n\t\treturn Promise.resolve(); //had to do this because of eslint error of not having await when the function is async\n\t}\n\n\t/**\n\t * This function is responsible for accepting the recommendations.\n\t * @param _params Params object containing recommendationData property which is an array of objects containing context, propertyPath, value and text for a recommendation\n\t * @returns Promise which resolved to a Boolean value based on whether recommendations are accepted or not\n\t */\n\t@publicExtension()\n\t@extensible(OverrideExecution.Instead)\n\tpublic async acceptRecommendations(_params: AcceptAllParams): Promise<boolean> {\n\t\t// the following code will be executed if there is no hook implementation i.e. for the new orchestration\n\t\tconst promises = [];\n\t\tif (_params.recommendationData) {\n\t\t\tfor (const recommendationData of _params.recommendationData) {\n\t\t\t\tif (recommendationData.context && recommendationData.propertyPath) {\n\t\t\t\t\tpromises.push(\n\t\t\t\t\t\trecommendationData.context.setProperty(recommendationData.propertyPath, recommendationData.value, \"$auto.abc\")\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait Promise.all(promises);\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate applyRecommendation(recommendationResponses: StandardRecommendationResponse[], _context: ODataV4Context[]): boolean {\n\t\tstandardRecommendationHelper.storeRecommendations(\n\t\t\trecommendationResponses,\n\t\t\tthis.getView().getModel(\"internal\") as JSONModel,\n\t\t\t_context\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stores the recommendation contexts.\n\t * @param contextsInfo\n\t */\n\tprivate storeRecommendationContexts(contextsInfo: RecommendationContextsInfo[]): void {\n\t\tconst contextPaths: string[] = [];\n\t\tlet recommendationContexts = this.internalModel.getProperty(\"/recommendationContexts\") || [];\n\t\tcontextsInfo.forEach((contextInfo: RecommendationContextsInfo) => {\n\t\t\tcontextPaths.push((contextInfo.context as ODataV4Context).getPath());\n\t\t});\n\n\t\trecommendationContexts = recommendationContexts?.filter((recommendationContext: RecommendationContextsInfo) => {\n\t\t\tconst context = recommendationContext?.context;\n\t\t\tif (context) {\n\t\t\t\tconst contextPath = context.getPath();\n\t\t\t\tconst index = contextPaths.indexOf(contextPath);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\t// Existing context path is not found in the newly fetched recommendation & therefore don't do anything\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (recommendationContext.contextIdentifier) {\n\t\t\t\t\t// Existing context path is found. we try to update the contextInfo with the latest context\n\t\t\t\t\t// instead of outdated one\n\t\t\t\t\tcontextsInfo[index].contextIdentifier = recommendationContext.contextIdentifier;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\n\t\tthis.internalModel.setProperty(\"/recommendationContexts\", [...recommendationContexts, ...contextsInfo]);\n\t}\n\n\t/**\n\t * Filters the contexts and only returns those that matches the contexts.\n\t * @param targets\n\t * @returns Returns the filtered recommendation relevant contexts\n\t */\n\tprivate fetchFilteredRecommendationContexts(targets: string[]): RecommendationContextsInfo[] {\n\t\tconst contextPaths: string[] = [];\n\t\tconst filteredRecommendationContexts: RecommendationContextsInfo[] = [];\n\t\tfor (const key of targets) {\n\t\t\tconst contextPathFromKey = key.substring(0, key.lastIndexOf(\")\") + 1);\n\t\t\tconst recommendationContexts = (this.getView().getModel(\"internal\") as JSONModel).getProperty(\"/recommendationContexts\");\n\t\t\trecommendationContexts.forEach((contextInfo: RecommendationContextsInfo) => {\n\t\t\t\tconst context = contextInfo.context;\n\t\t\t\tif ((context as ODataV4Context).getPath() == contextPathFromKey && !contextPaths.includes(contextPathFromKey)) {\n\t\t\t\t\tcontextPaths.push(contextPathFromKey);\n\t\t\t\t\tfilteredRecommendationContexts.push(contextInfo);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn filteredRecommendationContexts;\n\t}\n\n\t/**\n\t * Fetches RecommendationData based on filtered targets.\n\t * @param filteredTargets\n\t * @returns RecommendationData\n\t */\n\tprivate fetchFilteredRecommendationData(filteredTargets: string[]): RecommendationInfo {\n\t\tconst filterRecommendationsData: RecommendationInfo = {};\n\t\tconst recommendationData = this.getView().getModel(\"internal\")?.getProperty(\"/recommendationsData\");\n\t\tObject.keys(recommendationData).forEach((key: string) => {\n\t\t\tif (filteredTargets.includes(key)) {\n\t\t\t\tfilterRecommendationsData[key] = Object.assign(recommendationData[key], {});\n\t\t\t}\n\t\t});\n\t\treturn filterRecommendationsData;\n\t}\n\n\t/**\n\t * Fetches the filtered targets.\n\t * @param considerRecommendationContexts Passed as true when recommendation contexts should be considered instead of data\n\t * @returns Array of Filtered targets\n\t */\n\tprivate fetchTargets(considerRecommendationContexts?: boolean): string[] {\n\t\tconst recommendationData = this.getView().getModel(\"internal\")?.getProperty(\"/recommendationsData\");\n\t\tif (recommendationData.version === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst isFclEnabled = this.base.getAppComponent()._isFclEnabled();\n\t\tconst isFullScreen = isFclEnabled\n\t\t\t? (this.base.getAppComponent().getRootViewController() as FclController).getHelper().getCurrentUIState().isFullScreen\n\t\t\t: true;\n\t\tconst isRecommendationAcceptable = (contextPath: string, key: string): boolean => {\n\t\t\tconst splitPathAndCheckIfRecommendationAcceptable = (ctxtPath: string): boolean => {\n\t\t\t\tconst pathArray = key.split(ctxtPath);\n\t\t\t\tconst newPath = pathArray[1];\n\t\t\t\tlet newPathArray = newPath.split(\"/\");\n\t\t\t\t//here we check the path by splitting to decide whether to include recommendations or not in dialog\n\t\t\t\tif (newPathArray.length <= 3) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tnewPathArray = newPathArray.slice(2);\n\t\t\t\t\treturn !newPathArray.some((value: string) => value.includes(\"(\"));\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (isFclEnabled && !isFullScreen) {\n\t\t\t\tconst rightMostContext = (this.base.getAppComponent().getRootViewController() as FclController).getRightmostContext();\n\t\t\t\tif (key.includes(rightMostContext?.getPath() as string)) {\n\t\t\t\t\treturn splitPathAndCheckIfRecommendationAcceptable(rightMostContext?.getPath() as string);\n\t\t\t\t} else {\n\t\t\t\t\treturn splitPathAndCheckIfRecommendationAcceptable(contextPath);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn splitPathAndCheckIfRecommendationAcceptable(contextPath);\n\t\t\t}\n\t\t};\n\n\t\tconst dataToBeFiltered = this.fetchDataToBeFiltered(recommendationData, considerRecommendationContexts);\n\t\treturn (\n\t\t\tdataToBeFiltered.filter((key: string) => {\n\t\t\t\treturn (\n\t\t\t\t\tkey.includes(this.getView().getBindingContext()?.getPath() as string) &&\n\t\t\t\t\tisRecommendationAcceptable(this.getView().getBindingContext()?.getPath() as string, key)\n\t\t\t\t);\n\t\t\t}) || []\n\t\t);\n\t}\n\n\t/**\n\t * Fetches the data to be filtered depending on the recommendationData.\n\t * @param recommendationData\n\t * @param considerRecommendationContexts Passed as true when recommendation contexts should be considered instead of data\n\t * @returns Array of contextPaths to be filtered\n\t */\n\tprivate fetchDataToBeFiltered(recommendationData: RecommendationInfo, considerRecommendationContexts: boolean | undefined): string[] {\n\t\tlet dataToBeFiltered: string[] = [];\n\t\t// consider recommendationContexts for fetching the paths in case of field change so that contexts for which empty recommendation data is returned are also considered\n\t\tif (considerRecommendationContexts) {\n\t\t\tconst recommendationContexts = this.getView().getModel(\"internal\")?.getProperty(\"/recommendationContexts\");\n\t\t\trecommendationContexts.forEach((recommendationContext: RecommendationContextsInfo) => {\n\t\t\t\tdataToBeFiltered.push((recommendationContext.context as ODataV4Context).getPath());\n\t\t\t});\n\t\t} else {\n\t\t\t// consider recommendationData in case of accept all dialog scenarios\n\t\t\tdataToBeFiltered = Object.keys(recommendationData).filter((key) => {\n\t\t\t\treturn key !== \"version\" && key !== \"keys\";\n\t\t\t});\n\t\t}\n\t\treturn dataToBeFiltered;\n\t}\n\n\t/**\n\t * Overwrites AcceptAll Params based of recommendation data and contexts.\n\t * @param filterRecommendationData\n\t * @param filterRecommendationContexts\n\t * @param params\n\t */\n\tprivate adjustAcceptAllParams(\n\t\tfilterRecommendationData: RecommendationInfo,\n\t\tfilterRecommendationContexts: RecommendationContextsInfo[],\n\t\tparams: AcceptAllParams\n\t): void {\n\t\tparams.recommendationData = [];\n\t\tfor (const key in filterRecommendationData) {\n\t\t\tif (filterRecommendationData[key].value || filterRecommendationData[key].text) {\n\t\t\t\t// In case there is no placeholder value or placeholder text then this recommendation is not relevant for Accept.\n\t\t\t\t// User needs to manually select the recommended value in these cases & therefore filter the same.\n\t\t\t\tconst contextPathFromKey = key.substring(0, key.lastIndexOf(\")\") + 1);\n\t\t\t\tconst propertyPathFromKey = key.substring(key.lastIndexOf(\")\") + 2);\n\t\t\t\tconst matchingContext = filterRecommendationContexts.filter(function (contextInfo) {\n\t\t\t\t\tif ((contextInfo?.context as ODataV4Context).getPath() === contextPathFromKey) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (\n\t\t\t\t\tmatchingContext?.length > 0 &&\n\t\t\t\t\tstandardRecommendationHelper.isRecommendationFieldNull(\n\t\t\t\t\t\tmatchingContext[0].context as ODataV4Context,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tpropertyPathFromKey\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tparams.recommendationData.push({\n\t\t\t\t\t\tcontext: matchingContext[0].context,\n\t\t\t\t\t\tcontextIdentifier: matchingContext[0].contextIdentifier,\n\t\t\t\t\t\tpropertyPath: propertyPathFromKey,\n\t\t\t\t\t\tvalue: filterRecommendationData[key].value,\n\t\t\t\t\t\ttext: filterRecommendationData[key].text\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fetches RecommendationInfo that contains targets, filterRecommendationData, filterRecommendationContexts.\n\t * @returns Promise which resolves with AcceptallParams\n\t */\n\tpublic async fetchAcceptAllParams(): Promise<AcceptAllParams> {\n\t\tconst targets: string[] = this.fetchTargets();\n\t\tconst filterRecommendationData = this.fetchFilteredRecommendationData(targets);\n\t\tconst filterRecommendationContexts = this.fetchFilteredRecommendationContexts(targets);\n\t\tconst params = {};\n\t\tthis.adjustAcceptAllParams(filterRecommendationData, filterRecommendationContexts, params);\n\t\tawait (this.getView().getController() as PageController).recommendations.onBeforeAcceptRecommendations(params);\n\t\tstandardRecommendationHelper.addContextIdentifierText(params, this.getView()?.getBindingContext()?.getPath());\n\t\tthis.dataToBeAccepted = (params as AcceptAllParams).recommendationData || [];\n\t\treturn params;\n\t}\n\n\t/**\n\t * Checks if recommendations exist or not.\n\t * @returns Boolean value based on whether recommendations are present or not\n\t */\n\tpublic checkIfRecommendationsExist(): boolean {\n\t\tconst recommendationData = this.internalModel.getProperty(\"/recommendationsData\") || {};\n\t\treturn Object.keys(recommendationData).length !== 0;\n\t}\n\n\t/**\n\t * This function will clear recommendation Data for a given context and all its children.\n\t * @param contexts Context for which recommendation has to be cleared\n\t */\n\tpublic ignoreRecommendationForContexts(contexts?: ODataV4Context[]): void {\n\t\tif (!contexts || !contexts.length) {\n\t\t\tconst view = this.getView();\n\t\t\tconst bindingContext = view.getBindingContext() as ODataV4Context;\n\t\t\tcontexts = [bindingContext];\n\t\t}\n\t\tstandardRecommendationHelper.ignoreRecommendationForContexts(contexts, this.internalModel);\n\t}\n\n\tprivate tryResetRecommendations(rootContext: ODataV4Context): void {\n\t\tstandardRecommendationHelper.setCurrentRootContext(rootContext);\n\t\t// TODO: StandardRecommendationHelper stores all the recommendations for an instance of business object\n\t\t// meaning doesn't matter the recommendations are on the OP/SubOP. But the recommendations contexts here\n\t\t// is specific to this controller, SubOP controller will have its own recommendation contexts. Ideally it\n\t\t// should be cleared but this is not done here. This complete thing needs to be refactored\n\t\tthis.internalModel.setProperty(\"/recommendationContexts\", []);\n\t\tstandardRecommendationHelper.resetRecommendations(this.internalModel);\n\t}\n\n\t/**\n\t * This function will store the number of fields Accepted/Ignored when Save button is clicked, depending on which recommedation option was choosen Accept/Ignore and Save.\n\t * @param recommendationOptionChoosen\n\t */\n\tpublic async storeDataForTelemetry(recommendationOptionChoosen: undefined | RecommendationDialogDecision): Promise<void> {\n\t\tconst rootContext = await this._getRootContext(this.getView().getBindingContext() as ODataV4Context);\n\t\tif (rootContext && this.base.recommendations.isEnabled(rootContext)) {\n\t\t\tif (recommendationOptionChoosen === RecommendationDialogDecision.Accept) {\n\t\t\t\t// increase accept count\n\t\t\t\tthis.telemetry.updateData(\"numberOfFieldsAcceptedThroughAcceptButton\", this.dataToBeAccepted.length);\n\t\t\t} else if (recommendationOptionChoosen === RecommendationDialogDecision.Ignore) {\n\t\t\t\t// increase ignore count\n\t\t\t\tthis.telemetry.updateData(\"numberOfFieldsIgnoredThroughIgnoreButton\", this.dataToBeAccepted.length);\n\t\t\t}\n\t\t\tthis.telemetry.storeData(this.getView() as FEView);\n\t\t}\n\t}\n\n\t/**\n\t * This function will update the count by 1 in telemetry data.\n\t * @param key\n\t */\n\tpublic increaseTelemetryDataCount(key: keyof RecommendationTelemetry): void {\n\t\tthis.telemetry.increaseCount(key);\n\t}\n\n\t/**\n\t * This function will update telemetry data for which option user chose when selecting a field value, as top/non-top recommendation or some other value.\n\t * @param fieldPath\n\t * @param selectedValue\n\t */\n\tpublic updateTelemetryDataBasedOnUserSelection(fieldPath: string, selectedValue: string): void {\n\t\tthis.telemetry.updateTelemetryDataBasedOnUserSelection(this.getView(), fieldPath, selectedValue);\n\t}\n\n\t/**\n\t * This function will update the total number of fields recommended. If the field is already included in telemetry count then we do not include.\n\t * This way we know the total number of unique fields recommended.\n\t * @param recommendationData\n\t */\n\tupdateAllRecommendedFields(recommendationData: StandardRecommendationResponse[]): void {\n\t\tconst viewBindingContextPath = (this.getView().getBindingContext() as Context).getPath();\n\t\tconst newRecommendationsForCurrentContexts = recommendationData.filter(\n\t\t\t(response) => response[\"AIRecommendedFieldPath\"]?.includes(viewBindingContextPath)\n\t\t);\n\t\tif (!this.allRecommendedFields) {\n\t\t\tthis.allRecommendedFields = [];\n\t\t}\n\t\tnewRecommendationsForCurrentContexts.forEach((response) => {\n\t\t\tconst fieldPath = response[\"AIRecommendedFieldPath\"];\n\t\t\tif (fieldPath) {\n\t\t\t\tif (!this.allRecommendedFields.includes(fieldPath)) {\n\t\t\t\t\tthis.allRecommendedFields.push(fieldPath);\n\t\t\t\t\tthis.telemetry.increaseCount(\"numberOfRecommendedFields\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"],"mappings":"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","ignoreList":[]}