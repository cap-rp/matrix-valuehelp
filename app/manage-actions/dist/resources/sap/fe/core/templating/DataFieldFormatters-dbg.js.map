{"version":3,"names":["getDataField","oContext","oInterface","sPath","context","getPath","Error","hasOwnProperty","$kind","oConverterContext","getConverterContext","isAnnotationPath","isPathAnnotationExpression","$target","_exports","getDataFieldObjectPath","involvedDataModelObjects","getInvolvedDataModelObjects","targetObject","enhanceDataModelPath","path","value","endsWith","isSemanticallyConnectedFields","oDataField","$Type","isMultiLineText","annotations","UI","MultiLineText","valueOf","connectedFieldsTemplateRegex","connectedFieldsTemplateSubRegex","getLabelForConnectedFields","connectedFieldsPath","getTextBindingExpression","compileBindingExpression","arguments","length","undefined","connectedFields","templateMatches","Template","toString","match","partsToConcat","reduce","subPartsToConcat","subMatch","targetValue","targetData","Data","dataFieldPath","fullyQualifiedName","replace","targetEntityType","Value","push","constant","compileExpression","concat","generateVisibleExpression","dataFieldModelPath","formatOptions","propertyValue","targetModelPath","isProperty","Target","isAnalyticalGroupHeaderExpanded","isAnalytics","IsExpanded","isAnalyticalLeaf","equal","NodeLevel","and","isVisible","getRelativePaths","ifElse","or","not"],"sourceRoot":".","sources":["DataFieldFormatters.ts"],"sourcesContent":["import type { AnnotationPath, PathAnnotationExpression, Property } from \"@sap-ux/vocabularies-types/Edm\";\nimport type {\n\tConnectedFieldsTypeTypes,\n\tDataFieldAbstractTypes,\n\tDataFieldTypes,\n\tDataPointTypeTypes\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { PropertyAnnotations_UI } from \"@sap-ux/vocabularies-types/vocabularies/UI_Edm\";\nimport type { BindingToolkitExpression, CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { and, compileExpression, concat, constant, equal, ifElse, not, or } from \"sap/fe/base/BindingToolkit\";\nimport { getInvolvedDataModelObjects } from \"sap/fe/core/converters/MetaModelConverter\";\nimport { UI } from \"sap/fe/core/helpers/BindingHelper\";\nimport { isAnnotationPath, isPathAnnotationExpression, isProperty } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { enhanceDataModelPath, getRelativePaths } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type { ComputedAnnotationInterface, MetaModelContext } from \"sap/fe/core/templating/UIFormatters\";\nimport { getConverterContext, isVisible } from \"sap/fe/core/templating/UIFormatters\";\n\nexport const getDataField = function (\n\toContext: MetaModelContext,\n\toInterface: ComputedAnnotationInterface\n): DataFieldTypes | ConnectedFieldsTypeTypes | Property {\n\tconst sPath = oInterface.context.getPath();\n\tif (!oContext) {\n\t\tthrow new Error(`Unresolved context path ${sPath}`);\n\t}\n\tif (typeof oContext === \"object\" && oContext.hasOwnProperty(\"$kind\") && oContext.$kind !== \"Property\") {\n\t\tthrow new Error(`Context does not resolve to a DataField object but to a ${oContext.$kind}`);\n\t}\n\tlet oConverterContext = getConverterContext(oContext, oInterface) as\n\t\t| DataFieldTypes\n\t\t| Property\n\t\t| ConnectedFieldsTypeTypes\n\t\t| AnnotationPath<DataFieldTypes | ConnectedFieldsTypeTypes>\n\t\t| PathAnnotationExpression<DataFieldTypes | ConnectedFieldsTypeTypes>;\n\tif (isAnnotationPath(oConverterContext) || isPathAnnotationExpression(oConverterContext)) {\n\t\toConverterContext = oConverterContext.$target!;\n\t}\n\treturn oConverterContext;\n};\n\nexport const getDataFieldObjectPath = function (\n\toContext: MetaModelContext | string,\n\toInterface: ComputedAnnotationInterface\n): DataModelObjectPath<DataFieldTypes> {\n\tconst sPath = oInterface.context.getPath();\n\tif (!oContext) {\n\t\tthrow new Error(`Unresolved context path ${sPath}`);\n\t}\n\tif (typeof oContext === \"object\" && oContext.hasOwnProperty(\"$kind\") && oContext.$kind !== \"Property\") {\n\t\tthrow new Error(`Context does not resolve to a Property object but to a ${oContext.$kind}`);\n\t}\n\tlet involvedDataModelObjects = getInvolvedDataModelObjects<DataFieldTypes>(oInterface.context);\n\tif (involvedDataModelObjects.targetObject && isPathAnnotationExpression(involvedDataModelObjects.targetObject)) {\n\t\tinvolvedDataModelObjects = enhanceDataModelPath<DataFieldTypes>(\n\t\t\tinvolvedDataModelObjects,\n\t\t\tinvolvedDataModelObjects.targetObject.path\n\t\t);\n\t}\n\tif (involvedDataModelObjects.targetObject && isAnnotationPath<DataFieldTypes>(involvedDataModelObjects.targetObject)) {\n\t\t// REVIEW -> The code below was never correct, i'm changing it to something that makes sense type wise\n\t\tinvolvedDataModelObjects = enhanceDataModelPath<DataFieldTypes>(\n\t\t\tinvolvedDataModelObjects,\n\t\t\tinvolvedDataModelObjects.targetObject.value\n\t\t);\n\t}\n\tif (sPath.endsWith(\"$Path\") || sPath.endsWith(\"$AnnotationPath\")) {\n\t\tinvolvedDataModelObjects = enhanceDataModelPath<DataFieldTypes>(involvedDataModelObjects, oContext as string);\n\t}\n\treturn involvedDataModelObjects;\n};\n\nexport const isSemanticallyConnectedFields = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): boolean {\n\tconst oDataField = getDataField(oContext, oInterface);\n\treturn (oDataField as ConnectedFieldsTypeTypes).$Type === UIAnnotationTypes.ConnectedFieldsType;\n};\n\n/**\n *\n * @param oContext The Context of the property\n * @param oInterface The interface instance\n * @returns True if the property has MultiLineText annotation\n */\nexport const isMultiLineText = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): boolean {\n\tconst oDataField = getDataField(oContext, oInterface);\n\treturn (oDataField.annotations?.UI as PropertyAnnotations_UI)?.MultiLineText?.valueOf() === true;\n};\n\nconst connectedFieldsTemplateRegex = /(?:({[^}]+})[^{]*)/g;\nconst connectedFieldsTemplateSubRegex = /{([^}]+)}(.*)/;\nexport const getLabelForConnectedFields = function (\n\tconnectedFieldsPath: DataModelObjectPath<ConnectedFieldsTypeTypes>,\n\tgetTextBindingExpression: Function,\n\tcompileBindingExpression = true\n): BindingToolkitExpression<string> | CompiledBindingToolkitExpression {\n\tconst connectedFields: ConnectedFieldsTypeTypes = connectedFieldsPath.targetObject!;\n\t// First we separate each group of `{TemplatePart} xxx`\n\tconst templateMatches = connectedFields.Template.toString().match(connectedFieldsTemplateRegex);\n\tif (!templateMatches) {\n\t\treturn \"\";\n\t}\n\tconst partsToConcat = templateMatches.reduce((subPartsToConcat: BindingToolkitExpression<string>[], match) => {\n\t\t// Then for each sub-group, we retrieve the name of the data object and the remaining text, if it exists\n\t\tconst subMatch = match.match(connectedFieldsTemplateSubRegex);\n\t\tif (subMatch && subMatch.length > 1) {\n\t\t\tconst targetValue = subMatch[1];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst targetData = (connectedFields.Data as any)[targetValue];\n\t\t\tif (targetData) {\n\t\t\t\tconst dataFieldPath = enhanceDataModelPath<DataFieldTypes>(\n\t\t\t\t\tconnectedFieldsPath,\n\t\t\t\t\t// TODO Better type for the Edm.Dictionary\n\t\t\t\t\ttargetData.fullyQualifiedName.replace(connectedFieldsPath.targetEntityType.fullyQualifiedName, \"\")\n\t\t\t\t);\n\t\t\t\tdataFieldPath.targetObject = dataFieldPath.targetObject!.Value;\n\t\t\t\tsubPartsToConcat.push(getTextBindingExpression(dataFieldPath, {}));\n\t\t\t\tif (subMatch.length > 2) {\n\t\t\t\t\tsubPartsToConcat.push(constant(subMatch[2]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn subPartsToConcat;\n\t}, []);\n\treturn compileBindingExpression ? compileExpression(concat(...partsToConcat)) : concat(...partsToConcat);\n};\n\n/**\n * Returns the binding expression to evaluate the visibility of a DataField or DataPoint annotation.\n *\n * SAP Fiori elements will evaluate either the UI.Hidden annotation defined on the annotation itself or on the target property.\n * @param dataFieldModelPath The metapath referring to the annotation we are evaluating.\n * @param [formatOptions] FormatOptions optional.\n * @param formatOptions.isAnalytics This flag is set when using an analytical table.\n * @returns An expression that you can bind to the UI.\n */\nexport const generateVisibleExpression = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes | Property>,\n\tformatOptions?: { isAnalytics?: boolean }\n): BindingToolkitExpression<boolean> {\n\tlet propertyValue;\n\tlet targetModelPath;\n\tconst targetObject = dataFieldModelPath.targetObject;\n\tif (targetObject && !isProperty(targetObject)) {\n\t\tswitch (targetObject.$Type) {\n\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\tcase UIAnnotationTypes.DataPointType:\n\t\t\t\tpropertyValue = targetObject.Value.$target;\n\t\t\t\ttargetModelPath = enhanceDataModelPath(dataFieldModelPath, targetObject.Value.path);\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t// if it is a DataFieldForAnnotation pointing to a DataPoint we look at the dataPoint's value\n\t\t\t\tif (targetObject?.Target?.$target?.$Type === UIAnnotationTypes.DataPointType) {\n\t\t\t\t\tpropertyValue = targetObject.Target.$target?.Value.$target;\n\t\t\t\t\ttargetModelPath = enhanceDataModelPath(dataFieldModelPath, targetObject.Target.value);\n\t\t\t\t\ttargetModelPath = enhanceDataModelPath(targetModelPath, targetObject.Target.$target?.Value.path);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t// eslint-disable-next-line no-fallthrough\n\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\tdefault:\n\t\t\t\tpropertyValue = undefined;\n\t\t}\n\t} else if (targetObject && isProperty(targetObject)) {\n\t\ttargetModelPath = enhanceDataModelPath(dataFieldModelPath, targetObject);\n\t}\n\n\tconst isAnalyticalGroupHeaderExpanded = formatOptions?.isAnalytics ? UI.IsExpanded : constant(false);\n\tconst isAnalyticalLeaf = formatOptions?.isAnalytics ? equal(UI.NodeLevel, 0) : constant(false);\n\t// A data field is visible if:\n\t// - the UI.Hidden expression in the original annotation does not evaluate to 'true'\n\t// - the UI.Hidden expression in the target property does not evaluate to 'true'\n\t// - in case of Analytics it's not visible for an expanded GroupHeader\n\treturn and(\n\t\t...[\n\t\t\tisVisible(dataFieldModelPath.targetObject, getRelativePaths(dataFieldModelPath)),\n\t\t\tifElse(!!propertyValue, propertyValue && isVisible(propertyValue, getRelativePaths(targetModelPath)), true),\n\t\t\tor(not(isAnalyticalGroupHeaderExpanded), isAnalyticalLeaf)\n\t\t]\n\t);\n};\n"],"mappings":"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","ignoreList":[],"file":"DataFieldFormatters-dbg.js"}