{"version":3,"file":"Columns.js","names":["ColumnType","_exports","getTableColumns","lineItemAnnotation","tableType","visualizationPath","converterContext","annotationColumns","getColumnsFromAnnotations","manifestColumns","getColumnsFromManifest","getManifestControlConfiguration","columns","getAnnotationEntityType","tableColumns","insertCustomElements","width","OverrideType","overwrite","widthIncludingColumnHeader","importance","horizontalAlign","availability","isNavigable","settings","formatOptions","exportSettings","addComputedColumns","findColumnByPath","path","find","column","annotationColumn","propertyInfos","undefined","relativePath","updateLinkedProperties","dataModelObjectPath","getConverterContextFor","getContextPath","getDataModelObjectPath","forEach","oColumn","tableColumn","propertyDataModelObjectPath","enhanceDataModelPath","property","targetObject","addCurrencyOrUoMToProperty","timezoneProperty","getAssociatedTimezoneProperty","timezone","annotations","Common","Timezone","oTimezoneColumn","name","timezoneText","toString","addTextArrangentInfoToProperty","currencyOrUoMProperty","getAssociatedCurrencyPropertyPath","getAssociatedUnitPropertyPath","currencyOrUoMPropertyDataModelObjectPath","currencyOrUoMRelativePath","getContextRelativeTargetObjectPath","unitColumn","unit","Measures","ISOCurrency","Unit","unitText","displayMode","getDisplayMode","textPropertyPath","getAssociatedTextPropertyPath","textPropertyDataModelObjectPath","textRelativePath","textColumn","textArrangement","textProperty","mode","type","getColumnsFromEntityType","columnsToBeCreated","entityType","tableCreationMode","displayModeOfDescriptionPropertiesMap","restrictionsOnProperties","propertiesNotToBeConsidered","aggregationHelper","AggregationHelper","groupableProperties","getGroupableProperties","isAnalyticsSupported","map","$target","filter","target","getAssociatedTextProperty","textProp","isPropertyGroupable","prop","entityProperties","exists","some","targetType","includes","relatedPropertiesInfo","collectRelatedProperties","relatedPropertyNames","Object","keys","properties","additionalPropertyNames","additionalProperties","addPropertyToDisplayModeOfDescriptionPropertiesMap","columnInfo","getColumnDefinitionFromProperty","getEntitySetBasedAnnotationPath","fullyQualifiedName","length","dataPointTargetValue","exportDataPointTargetValue","annotationProperty","updatePropertyLabel","additionalPropertyInfos","additionalPropertyName","push","nonSortableProperties","isPathAnnotationExpression","Text","relatedColumns","_createRelatedColumns","concat","fullPropertyPath","useDataFieldPrefix","availableForAdaptation","relativePathForMultiValue","semanticObjectAnnotationPath","getSemanticObjectPath","isHidden","isReferencePropertyStaticallyHidden","groupPath","_sliceAtSlash","isGroup","label","getLabel","dataType","getDataFieldDataType","propertyTypeConfig","getTypeConfig","isAPropertyFromTextOnlyAnnotation","sortable","filterable","nonFilterableProperties","typeConfig","className","constraints","_isExportableColumn","createColumnExportSettings","collectedNavigationPropertyLabels","_getCollectedNavigationPropertyLabels","key","replaceSpecialChars","Annotation","groupLabel","group","annotationPath","semanticObjectPath","isGroupable","isKey","caseSensitive","isFilteringCaseSensitive","getImportance","UI","DataFieldDefault","required","isRequiredColumn","additionalLabels","_addToolTip","_setExportSettingsForDataPoint","ModelHelper","isObjectPathDraftSupported","extension","technicallyAggregatable","technicallyGroupable","unitProperty","utc","isATimezone","currencyProperty","scale","isProperty","getAssociatedUnitProperty","getAssociatedCurrencyProperty","getStaticUnitOrCurrency","getStaticTimezone","isTimezone","exportType","getExportDataType","inputFormat","getDateInputFormat","delimiter","getDelimiter","template","wrap","autoScale","removeUndefinedFromExportSettings","setting","columnName","linkedAnnotationColumns","col","tooltip","source","propertyType","dataFieldDefaultProperty","$Type","Target","Value","Core","MediaType","term","isURL","_isValidColumn","dataField","Inline","_getVisibleExpression","dataFieldModelPath","propertyValue","isAnalyticalGroupHeaderExpanded","constant","isAnalyticalLeaf","and","not","equal","getExpressionFromAnnotation","Hidden","ifElse","or","_getFieldGroupHiddenExpressions","dataFieldGroup","fieldGroupHiddenExpressions","compileExpression","Data","innerDataField","arguments","isNavigationProperty","dataFieldDefault","qualifier","Label","isDataFieldTypes","valueOf","_getTooltip","QuickInfo","datapointTarget","getRowStatusVisibility","colName","isSemanticKeyInFieldGroup","formatResult","pathInModel","tableFormatters","getErrorStatusTextVisibilityFormatter","existingColumns","relatedPropertyNameMap","getAbsoluteAnnotationPath","relatedColumn","propertyObjectPath","isMultiValueField","newNameRelativeTargetPath","computeHiddenOnRelatedColumns","newName","propertyInfo","_getAnnotationColumnName","KeyHelper","generateKeyFromDataField","_getShowDataFieldsLabel","fieldGroupName","columnKeys","showDataFieldsLabel","_getRelativePath","value","isLastSlash","isLastPart","iSlashIndex","lastIndexOf","indexOf","substring","_isColumnMultiValued","_isColumnSortable","propertyPath","nonSortableColumns","propName","filterFunctions","_getFilterFunctions","ConverterContext","entitySet","getEntitySet","TypeGuards","isEntitySet","Capabilities","FilterFunctions","getEntityContainer","_getDefaultFormatOptionsForTable","textLinesEdit","_findSemanticKeyValues","semanticKeys","aSemanticKeyValues","bSemanticKeyFound","i","values","semanticKeyFound","_findProperties","semanticKeyValues","fieldGroupProperties","semanticKeyHasPropertyInFieldGroup","sPropertyPath","tmp","fieldGroupPropertyPath","_findSemanticKeyValuesInFieldGroup","aProperties","_propertiesFound","getDefaultDraftIndicatorForColumn","semanticKey","semanticKeyInFieldGroup","fieldGroupDraftIndicatorPropertyPath","showErrorObjectStatus","hasDraftIndicator","_getImpNumber","Importance","_getDataFieldImportance","split","None","targetValuefromDP","getTargetValueOnDataPoint","isDataPointFromDataFieldDefault","_getMaxImportance","fields","maxImpNumber","impNumber","DataFieldWithMaxImportance","field","targetEntityType","SemanticKey","requiredProperties","getRequiredProperties","highKeys","fieldsWithImportance","isAnnotationOfType","dataFieldTarget","fieldGroupData","fieldGroupDataField","High","item","getRestrictionsOnProperties","tableManifestSettings","defaultCreationMode","getManifestWrapper","getSapFeManifestConfiguration","macros","table","CreationMode","InlineCreationRows","tableSettings","creationMode","getAnnotationsByTerm","getEntityType","tableConverterContext","getTargetObjectPath","collectRelatedPropertiesRecursively","isFieldGroupColumn","navigationProperties","situationsNavProps","navigationProperty","isCollection","SAPObjectNodeType","Name","situationsNavProp","hasSituationsIndicator","isMultiValue","visualSettings","widthCalculation","FieldGroupHiddenExpressions","HTML5","CssDefaults","isPartOfLineItem","relatedPropertyName","displayModeOfPropertyUsedAsDescription","createPropertyAnnotatedTextOnly","_getPropertyNames","matchedProperties","Array","isArray","resolvePath","isRequiredFieldGroup","fieldGroup","isDataField","isStaticallyMandatory","isAnnotatedRequiredProperty","isRequiredDataFieldForAnnotation","dataFieldForAnnotation","DataFieldForAnnotationFieldControlNotMandatory","hasFieldControlNotMandatory","hasFieldGroupTarget","hasDataPointTarget","Visualization","isRequiredDataPoint","isRequiredProperty","isRatingVisualizationFromDataFieldDefault","dataPoint","getTemplateType","TemplateType","ListReport","AnalyticalListPage","IsEditable","isDataFieldForAnnotation","_appendCustomTemplate","exportProperties","join","internalColumns","isColumnOverride","isSlotColumn","manifestColumn","Slot","isCustomColumn","_updateLinkedPropertiesOnCustomColumns","annotationTableColumns","replace","isPartOfCustomColumn","validateKey","baseTableColumn","position","anchor","placement","Placement","After","propertiesToOverwriteAnnotationColumn","getCustomExportSettings","tooltipText","fetchTextFromMetaModel","headerText","header","customColumnExportSettings","baseManifestColumn","HorizontalAlign","Begin","id","customTableColumn","Default","message","getDiagnostics","addIssue","IssueCategory","Manifest","IssueSeverity","Low","IssueCategoryType","AnnotationColumns","InvalidKey","columnWithSituationsIndicator","situationsIndicatorColumn","propertyKey","isSituationsIndicator","Computed","clipboardSettings","indexOfFirstVisibleColumn","findIndex","splice","columnsWithDraftIndicator","isDraftNode","isDraftRoot","columnWithDraftIndicator","draftIndicatorColumn","isDraftIndicator","columnIndexToInsertAfter","getContextPropertyRestriction","capabilities","InsertRestrictions","RequiredProperties","isCurrency","exportDataType","navProperty","lineItem","isPropertyNavigated","inheredPropertyDataModelObjectPath","isInheredPropertyNavigated","oProperty","oTargetMapping","isTypeDefinition","EDM_TYPE_MAPPING","underlyingType","$Scale","precision","$Precision","maxLength","$MaxLength","nullable","$Nullable","minimum","isNaN","Validation","Minimum","maximum","Maximum","isDigitSequence","IsDigitSequence","parseAsString","emptyString","parseKeepsEmptyString","relatedAnnotationColumns","existingColumn","columnKey","columnFromAnnotations","enableWrapping","customExportSettings"],"sources":["./Columns.ts"],"sourcesContent":["import type { EntityType, NavigationProperty, Property, PropertyPath } from \"@sap-ux/vocabularies-types\";\nimport type { FilterFunctions } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities\";\nimport type { EntitySetAnnotations_Capabilities } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities_Edm\";\nimport type { SemanticKey } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type {\n\tDataField,\n\tDataFieldAbstractTypes,\n\tDataFieldForAnnotation,\n\tDataFieldTypes,\n\tDataPoint,\n\tDataPointTypeTypes,\n\tFieldGroup,\n\tLineItem\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { BindingToolkitExpression, CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tEDM_TYPE_MAPPING,\n\tand,\n\tcompileExpression,\n\tconstant,\n\tequal,\n\tformatResult,\n\tgetExpressionFromAnnotation,\n\tifElse,\n\tnot,\n\tor,\n\tpathInModel\n} from \"sap/fe/base/BindingToolkit\";\nimport type ConverterContext from \"sap/fe/core/converters/ConverterContext\";\nimport type {\n\tAvailabilityType,\n\tCustomDefinedTableColumn,\n\tCustomDefinedTableColumnForOverride,\n\tFormatOptionsType,\n\tTableColumnSettings,\n\tTableManifestConfiguration\n} from \"sap/fe/core/converters/ManifestSettings\";\nimport { CreationMode, HorizontalAlign, Importance, TemplateType } from \"sap/fe/core/converters/ManifestSettings\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport type { ComplexPropertyInfo } from \"sap/fe/core/converters/annotations/DataField\";\nimport {\n\tcollectRelatedProperties,\n\tcollectRelatedPropertiesRecursively,\n\tgetDataFieldDataType,\n\tgetSemanticObjectPath,\n\tgetTargetValueOnDataPoint,\n\thasDataPointTarget,\n\thasFieldGroupTarget,\n\tisDataField,\n\tisDataFieldForAnnotation,\n\tisDataFieldTypes,\n\tisDataPointFromDataFieldDefault,\n\tisRatingVisualizationFromDataFieldDefault\n} from \"sap/fe/core/converters/annotations/DataField\";\nimport { type TableType } from \"sap/fe/core/converters/controls/Common/Table\";\nimport { AggregationHelper } from \"sap/fe/core/converters/helpers/Aggregation\";\nimport type { ConfigurableObject, CustomElement } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { OverrideType, Placement, insertCustomElements } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { isReferencePropertyStaticallyHidden } from \"sap/fe/core/converters/helpers/DataFieldHelper\";\nimport { IssueCategory, IssueCategoryType, IssueSeverity } from \"sap/fe/core/converters/helpers/IssueManager\";\nimport { KeyHelper } from \"sap/fe/core/converters/helpers/Key\";\nimport { UI } from \"sap/fe/core/helpers/BindingHelper\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport { replaceSpecialChars } from \"sap/fe/core/helpers/StableIdHelper\";\nimport * as TypeGuards from \"sap/fe/core/helpers/TypeGuards\";\nimport {\n\tisAnnotationOfType,\n\tisNavigationProperty,\n\tisPathAnnotationExpression,\n\tisProperty,\n\tisTypeDefinition\n} from \"sap/fe/core/helpers/TypeGuards\";\nimport {\n\tenhanceDataModelPath,\n\tgetContextPropertyRestriction,\n\tgetContextRelativeTargetObjectPath,\n\tgetTargetObjectPath,\n\ttype DataModelObjectPath\n} from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { getDisplayMode, type DisplayMode } from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport { getRestrictionsOnProperties, type RestrictionsOnProperties } from \"sap/fe/core/templating/EntitySetHelper\";\nimport { hasFieldControlNotMandatory, isStaticallyMandatory } from \"sap/fe/core/templating/FieldControlHelper\";\nimport {\n\tgetAssociatedCurrencyProperty,\n\tgetAssociatedCurrencyPropertyPath,\n\tgetAssociatedTextProperty,\n\tgetAssociatedTextPropertyPath,\n\tgetAssociatedTimezoneProperty,\n\tgetAssociatedUnitProperty,\n\tgetAssociatedUnitPropertyPath,\n\tgetStaticTimezone,\n\tgetStaticUnitOrCurrency,\n\tisTimezone\n} from \"sap/fe/core/templating/PropertyHelper\";\nimport { isMultiValueField } from \"sap/fe/core/templating/UIFormatters\";\nimport type { DefaultTypeForEdmType } from \"sap/fe/core/type/EDM\";\n// eslint-disable-next-line @typescript-eslint/no-restricted-imports\nimport tableFormatters from \"sap/fe/macros/formatters/TableFormatter\";\nimport type Control from \"sap/ui/core/Control\";\nimport type { MDCTablePropertyInfo as PropertyInfo, VisualSettings } from \"sap/ui/mdc/Table\";\n\n// Custom Column from Manifest\ntype ManifestDefinedCustomColumn = CustomDefinedTableColumn & {\n\ttype?: ColumnType.Default;\n};\n\n// Slot Column from Building Block\ntype FragmentDefinedSlotColumn = CustomDefinedTableColumn & {\n\ttype: ColumnType.Slot;\n};\n// Properties all ColumnTypes have:\ntype BaseTableColumn = ConfigurableObject & {\n\ttype: ColumnType; //Origin of the source where we are getting the templated information from\n\twidth?: string;\n\twidthIncludingColumnHeader?: boolean;\n\timportance?: Importance;\n\thorizontalAlign?: HorizontalAlign;\n\tavailability?: AvailabilityType;\n\tisNavigable?: boolean;\n\tcaseSensitive?: boolean;\n\tlabel?: string;\n\ttooltip?: string;\n};\n\n// Properties on Custom Columns and Slot Columns\nexport type CustomBasedTableColumn = BaseTableColumn & {\n\tid: string;\n\tname: string;\n\theader?: string;\n\ttemplate: string | Control;\n\tpropertyInfos?: string[];\n\texportSettings?: ColumnExportSettings | null;\n\tformatOptions: FormatOptionsType;\n\tisGroupable: boolean;\n\tisNavigable: boolean;\n\tsortable: boolean;\n\tvisualSettings: { widthCalculation: null };\n\tproperties?: string[];\n\trequired?: CompiledBindingToolkitExpression;\n};\n\nexport type ComputedTableColumn = BaseTableColumn & {\n\tname: string;\n\tlabel: string;\n\tpropertyKey: string;\n\tisDraftIndicator?: boolean;\n\tisSituationsIndicator?: boolean;\n\tformatOptions?: FormatOptionsType | null;\n\tpropertyInfos?: string[];\n\texportSettings?: ColumnExportSettings | null;\n\tclipboardSettings?: Object | null;\n\trequired?: CompiledBindingToolkitExpression;\n};\n\n// Properties derived from Manifest to override Annotation configurations\ntype AnnotationTableColumnForOverride = BaseTableColumn & {\n\tsettings?: TableColumnSettings;\n\tformatOptions?: FormatOptionsType;\n\texportSettings?: ColumnExportSettings | null;\n};\n\ntype PropertyTypeConstraints = Partial<{\n\tscale: number;\n\tprecision: number;\n\tmaxLength: number;\n\tnullable: boolean;\n\tminimum: string;\n\tmaximum: string;\n\tisDigitSequence: boolean;\n}>;\n\nexport type PropertyTypeFormatOptions = Partial<{\n\tparseAsString: boolean;\n\temptyString: string;\n\tparseKeepsEmptyString: boolean;\n\tstyle: string;\n}>;\n\nexport type PropertyTypeConfig = {\n\ttype?: string;\n\tconstraints: PropertyTypeConstraints;\n\tformatOptions: PropertyTypeFormatOptions;\n\ttypeInstance?: unknown;\n\tbaseType?: string;\n\tclassName?: keyof typeof DefaultTypeForEdmType;\n};\n\nexport type ColumnExportSettings = PropertyInfo[\"exportSettings\"] & {\n\tdataPointTargetValue?: string;\n\tisCurrency?: boolean;\n};\n\n// Properties for Annotation Columns\nexport type AnnotationTableColumn = PropertyInfo &\n\tAnnotationTableColumnForOverride & {\n\t\tname: string;\n\t\tannotationPath: string;\n\t\trelativePath: string;\n\t\ttooltip?: string;\n\t\tgroupLabel?: string;\n\t\tgroup?: string;\n\t\tFieldGroupHiddenExpressions?: CompiledBindingToolkitExpression;\n\t\tshowDataFieldsLabel?: boolean;\n\t\trequired?: CompiledBindingToolkitExpression;\n\t\tisGroupable?: boolean;\n\t\tunitText?: string;\n\t\ttimezoneText?: string;\n\t\ttimezone?: string;\n\t\tsemanticObjectPath?: string;\n\t\ttextArrangement?: {\n\t\t\ttextProperty: string;\n\t\t\tmode: DisplayMode;\n\t\t};\n\t\tadditionalPropertyInfos?: string[];\n\t\ttypeConfig?: PropertyTypeConfig;\n\t\tisPartOfLineItem?: boolean; // temporary indicator to only allow filtering on navigation properties when they're part of a line item\n\t\tisPartOfCustomColumn?: boolean;\n\t\tadditionalLabels?: string[];\n\t\texportDataPointTargetValue?: string;\n\t\textension?: ExtensionForAnalytics;\n\t\tisMultiValue?: boolean;\n\t\tdescriptionProperty?: string;\n\t\tmode?: DisplayMode;\n\t\tvalueProperty?: string;\n\t};\n\nexport type ExtensionForAnalytics = PropertyInfo[\"extension\"] & {\n\tadditionalProperties?: string[];\n};\n\nexport type TableColumn = CustomBasedTableColumn | AnnotationTableColumn | ComputedTableColumn;\n\ntype ManifestColumn = CustomElement<CustomBasedTableColumn | AnnotationTableColumnForOverride>;\n\nexport enum ColumnType {\n\tDefault = \"Default\", // Default Type (Custom Column)\n\tAnnotation = \"Annotation\",\n\tSlot = \"Slot\",\n\tComputed = \"Computed\"\n}\n/**\n * Returns an array of all columns, annotation-based as well as manifest-based.\n * They are sorted and some properties can be overwritten via the manifest (check out the keys that can be overwritten).\n * @param lineItemAnnotation Collection of data fields for representation in a table or list\n * @param tableType The type of the table\n * @param visualizationPath\n * @param converterContext\n * @returns Returns all table columns that should be available, regardless of templating or personalization or their origin\n */\nexport function getTableColumns(\n\tlineItemAnnotation: LineItem,\n\ttableType: TableType,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): TableColumn[] {\n\tconst annotationColumns = getColumnsFromAnnotations(lineItemAnnotation, tableType, visualizationPath, converterContext);\n\tconst manifestColumns = getColumnsFromManifest(\n\t\tconverterContext.getManifestControlConfiguration<TableManifestConfiguration>(visualizationPath).columns ?? {},\n\t\tannotationColumns,\n\t\tconverterContext,\n\t\tconverterContext.getAnnotationEntityType(lineItemAnnotation)\n\t);\n\n\tconst tableColumns: TableColumn[] = insertCustomElements(\n\t\tannotationColumns as TableColumn[],\n\t\tmanifestColumns as Record<string, CustomElement<TableColumn>>,\n\t\t{\n\t\t\twidth: OverrideType.overwrite,\n\t\t\twidthIncludingColumnHeader: OverrideType.overwrite,\n\t\t\timportance: OverrideType.overwrite,\n\t\t\thorizontalAlign: OverrideType.overwrite,\n\t\t\tavailability: OverrideType.overwrite,\n\t\t\tisNavigable: OverrideType.overwrite,\n\t\t\tsettings: OverrideType.overwrite,\n\t\t\tformatOptions: OverrideType.overwrite,\n\t\t\texportSettings: OverrideType.overwrite\n\t\t}\n\t);\n\n\treturn addComputedColumns(tableColumns, tableType, visualizationPath, converterContext);\n}\n\nexport function findColumnByPath(path: string, tableColumns: TableColumn[]): TableColumn | undefined {\n\treturn tableColumns.find((column) => {\n\t\tconst annotationColumn = column as AnnotationTableColumn;\n\t\treturn annotationColumn.propertyInfos === undefined && annotationColumn.relativePath === path;\n\t});\n}\n\n/**\n * Sets the 'unit', 'textArrangement', 'timezone' and 'exportsettings' properties in columns when necessary.\n * @param converterContext The instance of the converter context\n * @param tableColumns The columns to be updated\n */\nexport function updateLinkedProperties(converterContext: ConverterContext, tableColumns: TableColumn[]): void {\n\tconst dataModelObjectPath = converterContext.getConverterContextFor(converterContext.getContextPath()).getDataModelObjectPath();\n\ttableColumns.forEach((oColumn) => {\n\t\tconst tableColumn = oColumn as AnnotationTableColumn;\n\t\tif (tableColumn.propertyInfos === undefined && tableColumn.relativePath) {\n\t\t\tconst propertyDataModelObjectPath = enhanceDataModelPath<Property>(dataModelObjectPath, tableColumn.relativePath);\n\t\t\tconst property = propertyDataModelObjectPath.targetObject;\n\t\t\tif (property) {\n\t\t\t\taddCurrencyOrUoMToProperty(property, propertyDataModelObjectPath, tableColumns, tableColumn);\n\t\t\t\tconst timezoneProperty = getAssociatedTimezoneProperty(property);\n\t\t\t\tconst timezone = property?.annotations?.Common?.Timezone;\n\t\t\t\tif (timezoneProperty) {\n\t\t\t\t\tconst oTimezoneColumn = findColumnByPath(timezoneProperty.name, tableColumns);\n\t\t\t\t\ttableColumn.timezone = oTimezoneColumn?.name;\n\t\t\t\t} else if (timezone) {\n\t\t\t\t\ttableColumn.timezoneText = timezone.toString();\n\t\t\t\t}\n\t\t\t\taddTextArrangentInfoToProperty(property, propertyDataModelObjectPath, tableColumns, tableColumn);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Adds the \"unit\" property into the columns when neccesary for columns with unit of measure and currencies.\n * @param property The property referenced on the column\n * @param propertyDataModelObjectPath The property DataModelObjectPath.\n * @param tableColumns The list of columns displayed on the table\n * @param tableColumn The table column which adds the currency or unit\n */\nfunction addCurrencyOrUoMToProperty(\n\tproperty: Property,\n\tpropertyDataModelObjectPath: DataModelObjectPath<Property>,\n\ttableColumns: TableColumn[],\n\ttableColumn: AnnotationTableColumn\n): void {\n\tconst currencyOrUoMProperty = getAssociatedCurrencyPropertyPath(property) || getAssociatedUnitPropertyPath(property);\n\tif (currencyOrUoMProperty) {\n\t\tconst currencyOrUoMPropertyDataModelObjectPath = enhanceDataModelPath<Property>(propertyDataModelObjectPath, currencyOrUoMProperty);\n\t\tconst currencyOrUoMRelativePath = getContextRelativeTargetObjectPath(currencyOrUoMPropertyDataModelObjectPath);\n\t\tif (currencyOrUoMRelativePath) {\n\t\t\tconst unitColumn = findColumnByPath(currencyOrUoMRelativePath, tableColumns);\n\t\t\ttableColumn.unit = unitColumn?.name;\n\t\t}\n\t} else {\n\t\tconst unit = property?.annotations?.Measures?.ISOCurrency || property?.annotations?.Measures?.Unit;\n\t\tif (unit) {\n\t\t\ttableColumn.unitText = `${unit}`;\n\t\t}\n\t}\n}\n\n/**\n * Add the \"textArrangement\" object to columns when necessary for columns containing text, such as descriptions.\n * @param property The property referenced by the column\n * @param propertyDataModelObjectPath The property DataModelObjectPath.\n * @param tableColumns The list of columns displayed on the table\n * @param tableColumn The table column which adds the text\n */\nfunction addTextArrangentInfoToProperty(\n\tproperty: Property,\n\tpropertyDataModelObjectPath: DataModelObjectPath<Property>,\n\ttableColumns: TableColumn[],\n\ttableColumn: AnnotationTableColumn\n): void {\n\tconst displayMode = getDisplayMode(property),\n\t\ttextPropertyPath = getAssociatedTextPropertyPath(property);\n\tif (textPropertyPath && displayMode !== \"Value\") {\n\t\tconst textPropertyDataModelObjectPath = enhanceDataModelPath<Property>(propertyDataModelObjectPath, textPropertyPath);\n\t\tconst textRelativePath = getContextRelativeTargetObjectPath(textPropertyDataModelObjectPath);\n\t\tif (textRelativePath) {\n\t\t\tconst textColumn = findColumnByPath(textRelativePath, tableColumns);\n\t\t\tif (textColumn && textColumn.name !== tableColumn.name) {\n\t\t\t\ttableColumn.textArrangement = {\n\t\t\t\t\ttextProperty: textColumn.name,\n\t\t\t\t\tmode: displayMode\n\t\t\t\t};\n\t\t\t\t// If text properties are used but hidden, we must include them to the export as there are used in the paste\n\t\t\t\tif (!textColumn.exportSettings) {\n\t\t\t\t\ttextColumn.exportSettings = { type: \"String\" };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Retrieve the columns from the entityType.\n * @param columnsToBeCreated The columns to be created.\n * @param entityType The target entity type.\n * @param annotationColumns The array of columns created based on LineItem annotations.\n * @param converterContext The converter context.\n * @param tableType The table type.\n * @param tableCreationMode The creation mode of the table.\n * @param displayModeOfDescriptionPropertiesMap The map of properties referenced as description on a text arrangement annotation.\n * @param restrictionsOnProperties The existing restrictions on properties\n * @returns The column from the entityType\n */\nexport const getColumnsFromEntityType = function (\n\tcolumnsToBeCreated: Record<string, Property>,\n\tentityType: EntityType,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\ttableType: TableType,\n\ttableCreationMode: CreationMode,\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\trestrictionsOnProperties?: RestrictionsOnProperties\n): AnnotationTableColumn[] {\n\tif (annotationColumns === undefined) {\n\t\tannotationColumns = [];\n\t}\n\n\tlet propertiesNotToBeConsidered: string[] = [];\n\tconst aggregationHelper = new AggregationHelper(entityType, converterContext);\n\tconst groupableProperties = aggregationHelper.getGroupableProperties();\n\t//For Analytical table, we exclude all properties that are not groupable and used as Text in a groupable Property.\n\tif (tableType === \"AnalyticalTable\" && aggregationHelper.isAnalyticsSupported() && groupableProperties) {\n\t\tpropertiesNotToBeConsidered = groupableProperties\n\t\t\t.map((property) => property.$target)\n\t\t\t.filter((target) => target !== undefined)\n\t\t\t.map((target) => getAssociatedTextProperty(target as Property))\n\t\t\t.filter((textProp) => textProp && !aggregationHelper.isPropertyGroupable(textProp))\n\t\t\t.map((prop) => prop?.name)\n\t\t\t.filter((name) => name !== undefined) as string[];\n\t}\n\tentityType.entityProperties.forEach((property: Property) => {\n\t\t// Catch already existing columns - which were added before by LineItem Annotations\n\t\tconst exists = annotationColumns.some((column) => {\n\t\t\treturn column.name === property.name;\n\t\t});\n\t\t// if target type exists, it is a complex property and should be ignored\n\t\tif (!property.targetType && !exists && !propertiesNotToBeConsidered.includes(property.name)) {\n\t\t\tconst relatedPropertiesInfo: ComplexPropertyInfo = collectRelatedProperties(\n\t\t\t\tproperty.name,\n\t\t\t\tproperty,\n\t\t\t\tconverterContext,\n\t\t\t\ttrue,\n\t\t\t\ttableType\n\t\t\t);\n\t\t\tconst relatedPropertyNames: string[] = Object.keys(relatedPropertiesInfo.properties);\n\t\t\tconst additionalPropertyNames: string[] = Object.keys(relatedPropertiesInfo.additionalProperties);\n\t\t\t// Include the text properties and their corresponding text arrangement\n\t\t\trelatedPropertyNames.forEach((name) => {\n\t\t\t\taddPropertyToDisplayModeOfDescriptionPropertiesMap(displayModeOfDescriptionPropertiesMap, relatedPropertiesInfo, name);\n\t\t\t});\n\n\t\t\tconst columnInfo = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tconverterContext.getEntitySetBasedAnnotationPath(property.fullyQualifiedName),\n\t\t\t\tproperty.name,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode,\n\t\t\t\trelatedPropertiesInfo\n\t\t\t);\n\t\t\tif (relatedPropertyNames.length > 0) {\n\t\t\t\tcolumnInfo.propertyInfos = relatedPropertyNames;\n\t\t\t\tif (relatedPropertiesInfo.exportSettings.dataPointTargetValue) {\n\t\t\t\t\tcolumnInfo.exportDataPointTargetValue = relatedPropertiesInfo.exportSettings.dataPointTargetValue;\n\t\t\t\t}\n\t\t\t\t// Collect information of related columns to be created.\n\t\t\t\trelatedPropertyNames.forEach((name) => {\n\t\t\t\t\tcolumnsToBeCreated[name] = relatedPropertiesInfo.properties[name].annotationProperty;\n\t\t\t\t});\n\t\t\t}\n\t\t\t// update Property Label when it's referenced only once in a column, new label will be the label of the column\n\t\t\tupdatePropertyLabel(annotationColumns, columnsToBeCreated, columnInfo);\n\t\t\tif (additionalPropertyNames.length > 0) {\n\t\t\t\tcolumnInfo.additionalPropertyInfos = additionalPropertyNames;\n\t\t\t\t// Create columns for additional properties identified for ALP use case.\n\t\t\t\tadditionalPropertyNames.forEach((additionalPropertyName) => {\n\t\t\t\t\t// Intentional overwrite as we require only one new PropertyInfo for a related Property.\n\t\t\t\t\tcolumnsToBeCreated[additionalPropertyName] = relatedPropertiesInfo.additionalProperties[additionalPropertyName];\n\t\t\t\t});\n\t\t\t}\n\t\t\tannotationColumns.push(columnInfo);\n\t\t}\n\t\t// In case a property has defined a #TextOnly text arrangement that points to a text property (and not a 'hard coded text') don't only create the complex property with the text property as a child property,\n\t\t// but also the property itself as it can be used as within the sortConditions or on custom columns.\n\t\t// This step must be valid also from the columns added via LineItems or from a column available on the p13n.\n\t\tif (getDisplayMode(property) === \"Description\") {\n\t\t\trestrictionsOnProperties?.nonSortableProperties.push(property.name);\n\t\t\tif (isPathAnnotationExpression(property?.annotations?.Common?.Text)) {\n\t\t\t\tannotationColumns.push(\n\t\t\t\t\tgetColumnDefinitionFromProperty(\n\t\t\t\t\t\tproperty,\n\t\t\t\t\t\tconverterContext.getEntitySetBasedAnnotationPath(property.fullyQualifiedName),\n\t\t\t\t\t\tproperty.name,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\taggregationHelper,\n\t\t\t\t\t\tconverterContext,\n\t\t\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\t\t\trestrictionsOnProperties,\n\t\t\t\t\t\ttableCreationMode\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n\t// Create a propertyInfo for each related property.\n\tconst relatedColumns = _createRelatedColumns(\n\t\tcolumnsToBeCreated,\n\t\tannotationColumns,\n\t\tconverterContext,\n\t\tentityType,\n\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\ttableCreationMode,\n\t\trestrictionsOnProperties\n\t);\n\treturn annotationColumns.concat(relatedColumns);\n};\n\n/**\n * Create a column definition from a property.\n * @param property Entity type property for which the column is created\n * @param fullPropertyPath The full path to the target property\n * @param relativePath The relative path to the target property based on the context\n * @param useDataFieldPrefix Should be prefixed with \"DataField::\", else it will be prefixed with \"Property::\"\n * @param availableForAdaptation Decides whether the column should be available for adaptation\n * @param aggregationHelper The aggregationHelper for the entity\n * @param converterContext The converter context\n * @param displayModeOfDescriptionPropertiesMap The map of properties referenced as description on a text arrangement annotation\n * @param restrictionsOnProperties The existing restrictions on properties\n * @param tableCreationMode The creation mode of the table\n * @param relatedPropertiesInfo The properties identified so far for the column\n * @param relativePathForMultiValue The MDC path used for the 1:n property to allow filtering from MDC\n * @returns The annotation column definition\n */\nconst getColumnDefinitionFromProperty = function (\n\tproperty: Property,\n\tfullPropertyPath: string,\n\trelativePath: string,\n\tuseDataFieldPrefix: boolean,\n\tavailableForAdaptation: boolean,\n\taggregationHelper: AggregationHelper,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\trestrictionsOnProperties?: RestrictionsOnProperties,\n\ttableCreationMode?: CreationMode,\n\trelatedPropertiesInfo?: ComplexPropertyInfo,\n\trelativePathForMultiValue?: string\n): AnnotationTableColumn {\n\tconst semanticObjectAnnotationPath = getSemanticObjectPath(converterContext, property);\n\tconst isHidden = isReferencePropertyStaticallyHidden(property);\n\tconst groupPath: string | undefined = property.name ? _sliceAtSlash(property.name, true, false) : undefined;\n\tconst isGroup: boolean = groupPath != property.name;\n\tconst label = getLabel(property, isGroup);\n\tconst dataType = getDataFieldDataType(property);\n\tconst propertyTypeConfig = getTypeConfig(property, dataType);\n\tconst isAPropertyFromTextOnlyAnnotation = displayModeOfDescriptionPropertiesMap[relativePath] === \"Description\";\n\tconst sortable =\n\t\t(!isHidden || isAPropertyFromTextOnlyAnnotation) && !restrictionsOnProperties?.nonSortableProperties.includes(relativePath);\n\tconst filterable = !isAPropertyFromTextOnlyAnnotation && !restrictionsOnProperties?.nonFilterableProperties.includes(relativePath);\n\tconst typeConfig = {\n\t\tclassName: property.type || dataType,\n\t\tformatOptions: propertyTypeConfig.formatOptions,\n\t\tconstraints: propertyTypeConfig.constraints\n\t};\n\tlet exportSettings: PropertyInfo[\"exportSettings\"] = null;\n\tif (_isExportableColumn(property)) {\n\t\texportSettings = createColumnExportSettings(property, relatedPropertiesInfo);\n\t}\n\tconst availability: AvailabilityType =\n\t\t!isHidden && (availableForAdaptation || displayModeOfDescriptionPropertiesMap[relativePath]) ? \"Adaptation\" : \"Hidden\";\n\tconst collectedNavigationPropertyLabels: string[] | undefined = _getCollectedNavigationPropertyLabels(relativePath, converterContext);\n\tif (relativePathForMultiValue) {\n\t\trelativePath = relativePathForMultiValue;\n\t}\n\tconst name = useDataFieldPrefix ? relativePath : `Property::${relativePath}`;\n\tconst key = (useDataFieldPrefix ? \"DataField::\" : \"Property::\") + replaceSpecialChars(relativePath);\n\n\tconst column: AnnotationTableColumn = {\n\t\tkey: key,\n\t\ttype: ColumnType.Annotation,\n\t\tdataType: dataType ?? property.type,\n\t\tlabel: label ?? property.name,\n\t\tgroupLabel: isGroup ? getLabel(property) : undefined,\n\t\tgroup: isGroup ? groupPath : undefined,\n\t\tannotationPath: fullPropertyPath,\n\t\tsemanticObjectPath: semanticObjectAnnotationPath,\n\t\tavailability: availability,\n\t\tname: name,\n\t\trelativePath: relativePath,\n\t\tsortable: sortable,\n\t\tfilterable: filterable,\n\t\tisGroupable: aggregationHelper.isAnalyticsSupported() ? !!aggregationHelper.isPropertyGroupable(property) : sortable,\n\t\tisKey: property.isKey,\n\t\texportSettings: exportSettings,\n\t\tcaseSensitive: isFilteringCaseSensitive(converterContext),\n\t\ttypeConfig: typeConfig as PropertyTypeConfig,\n\t\timportance: getImportance(converterContext, property.annotations?.UI?.DataFieldDefault),\n\t\trequired: isRequiredColumn(converterContext, property, tableCreationMode),\n\t\tadditionalLabels: collectedNavigationPropertyLabels\n\t};\n\t_addToolTip(property, column);\n\t_setExportSettingsForDataPoint(property, column);\n\n\tif (\n\t\taggregationHelper.isAnalyticsSupported() &&\n\t\tModelHelper.isObjectPathDraftSupported(converterContext.getDataModelObjectPath()) &&\n\t\t(relativePath === \"HasActiveEntity\" || relativePath === \"HasDraftEntity\" || relativePath === \"IsActiveEntity\")\n\t) {\n\t\t// In case of analytical table on a draft-enabled entity, we always consider the HasDraftEntity, HasActiveEntity and IsActiveEntity properties as\n\t\t// technically groupable, as we need to load them for our internal logic.\n\t\tcolumn.extension = {\n\t\t\ttechnicallyAggregatable: false,\n\t\t\ttechnicallyGroupable: true\n\t\t};\n\t}\n\treturn column;\n};\n\n/**\n * Create the export settings for a given column.\n * @param column The given column from a line item as a data field or a property from the entity type\n * @param relatedPropertiesInfo The related properties linked to the column (named also complex property)\n * @returns The export settings in a the given column\n */\nconst createColumnExportSettings = function (\n\tcolumn: Property | DataFieldAbstractTypes,\n\trelatedPropertiesInfo?: ComplexPropertyInfo\n): ColumnExportSettings {\n\tlet unitProperty, timezoneProperty, unitText, timezoneText, utc, isATimezone, currencyProperty, scale;\n\tconst relatedPropertyNames = relatedPropertiesInfo ? Object.keys(relatedPropertiesInfo.properties) : [];\n\tif (relatedPropertiesInfo && relatedPropertyNames?.length === 1) {\n\t\t// Create the export settings of a column based on the related (child) property in case there is only one.\n\t\t// This is required when we have a text only annotation to compute the export settings from the text instead of the value\n\t\tcolumn = relatedPropertiesInfo.properties[relatedPropertyNames[0]].annotationProperty;\n\t}\n\tconst dataType = getDataFieldDataType(column);\n\tif (isProperty(column)) {\n\t\tunitProperty = getAssociatedUnitProperty(column);\n\t\tcurrencyProperty = getAssociatedCurrencyProperty(column);\n\t\ttimezoneProperty = getAssociatedTimezoneProperty(column);\n\t\tunitText = getStaticUnitOrCurrency(column);\n\t\ttimezoneText = getStaticTimezone(column);\n\t\tisATimezone = isTimezone(column);\n\t\tscale = column.scale;\n\t}\n\tunitProperty = relatedPropertiesInfo?.exportSettings?.unitProperty ?? unitProperty?.name ?? currencyProperty?.name;\n\ttimezoneProperty = relatedPropertiesInfo?.exportSettings?.timezoneProperty ?? timezoneProperty?.name;\n\tscale = relatedPropertiesInfo?.exportSettings?.scale ?? scale;\n\tconst exportType = getExportDataType(dataType, isATimezone, !!currencyProperty, relatedPropertiesInfo?.exportSettings);\n\tif (timezoneProperty || (exportType === \"DateTime\" && !timezoneText)) {\n\t\tutc = false;\n\t}\n\tconst exportSettings: ColumnExportSettings = {\n\t\ttype: exportType,\n\t\tinputFormat: getDateInputFormat(dataType),\n\t\tdelimiter: getDelimiter(dataType),\n\t\tscale: scale,\n\t\tunitProperty: unitProperty,\n\t\tunit: relatedPropertiesInfo?.exportSettings.unit ?? unitText,\n\t\ttimezoneProperty: timezoneProperty,\n\t\ttimezone: relatedPropertiesInfo?.exportSettings.timezone ?? timezoneText?.toString(),\n\t\ttemplate: relatedPropertiesInfo?.exportSettings.template,\n\t\t//only in case of complex properties, wrap the cell content\ton the excel exported file\n\t\twrap: relatedPropertiesInfo?.exportSettings.wrap,\n\t\tutc: utc\n\t};\n\tif (exportSettings.unitProperty || exportSettings.unit) {\n\t\texportSettings.autoScale = true;\n\t}\n\treturn removeUndefinedFromExportSettings(exportSettings);\n};\n\n/**\n * Gets the export format template for columns with dates.\n * @param dataType The data type of the column\n * @returns The inputFormat\n */\nconst getDateInputFormat = function (dataType?: string): string | undefined {\n\treturn dataType === \"Edm.Date\" ? \"YYYY-MM-DD\" : undefined;\n};\n\n/**\n * Gets the delimiter in numeric columns.\n * The delimiter is used to display thousands separator in numeric columns.\n * @param dataType The data type of the column\n * @returns True to display thousands separator in numeric columns\n */\nconst getDelimiter = function (dataType?: string): boolean | undefined {\n\treturn dataType === \"Edm.Int64\" ? true : undefined;\n};\n\n/**\n * Removes undefined values from the export settings object of a column.\n * @param exportSettings The export settings configurations for a column\n * @returns The export settings configurations without undefined values\n */\nconst removeUndefinedFromExportSettings = function (exportSettings: ColumnExportSettings): ColumnExportSettings {\n\t//Remove undefined settings from exportSetting object\n\tfor (const setting in exportSettings) {\n\t\tif (exportSettings[setting as keyof ColumnExportSettings] === undefined) {\n\t\t\tdelete exportSettings[setting as keyof ColumnExportSettings];\n\t\t}\n\t}\n\treturn exportSettings;\n};\n\n/**\n * Update property label in case it's only referenced in one column. The label of the column must be used instead of the property label.\n * This update also is applied for the tooltip as it is based on the column's label.\n * @param annotationColumns The array of columns created based on LineItem annotations.\n * @param columnsToBeCreated The columns to be created\n * @param columnInfo The column definition\n * @param columnName The name of the column\n */\nfunction updatePropertyLabel(\n\tannotationColumns: AnnotationTableColumn[],\n\tcolumnsToBeCreated: Record<string, Property>,\n\tcolumnInfo: AnnotationTableColumn,\n\tcolumnName?: string\n): void {\n\tconst linkedAnnotationColumns = annotationColumns.filter(\n\t\t(col) => col.propertyInfos?.includes(columnInfo.relativePath) || (columnName && col.propertyInfos?.includes(columnName))\n\t);\n\tif (\n\t\tlinkedAnnotationColumns?.length === 1 &&\n\t\t(columnsToBeCreated[columnInfo.relativePath] || (columnName && columnsToBeCreated[columnName])) &&\n\t\tlinkedAnnotationColumns[0].propertyInfos?.length === 1\n\t) {\n\t\tcolumnInfo.label = linkedAnnotationColumns[0].label;\n\t\tcolumnInfo.tooltip = linkedAnnotationColumns[0].tooltip;\n\t}\n}\n\n/**\n * Returns Boolean true for exportable columns, false for non exportable columns.\n * @param source The dataField or property to be evaluated\n * @returns True for exportable column, false for non exportable column\n */\nfunction _isExportableColumn(source: DataFieldAbstractTypes | Property): boolean {\n\tlet propertyType, property;\n\tconst dataFieldDefaultProperty = (source as Property).annotations.UI?.DataFieldDefault;\n\tif (isProperty(source)) {\n\t\tif (isReferencePropertyStaticallyHidden(source)) {\n\t\t\treturn false;\n\t\t}\n\t\tpropertyType = dataFieldDefaultProperty?.$Type;\n\t} else if (isReferencePropertyStaticallyHidden(source)) {\n\t\treturn false;\n\t} else {\n\t\tproperty = source;\n\t\tpropertyType = property.$Type;\n\t\tif (propertyType === UIAnnotationTypes.DataFieldForAnnotation && (property as DataFieldForAnnotation).Target?.$target?.$Type) {\n\t\t\t//For Chart\n\t\t\tpropertyType = (property as DataFieldForAnnotation).Target?.$target?.$Type;\n\t\t\treturn propertyType !== undefined && !UIAnnotationTypes.ChartDefinitionType.includes(propertyType);\n\t\t} else if (\n\t\t\t(property as DataField).Value?.$target?.annotations?.Core?.MediaType?.term === \"Org.OData.Core.V1.MediaType\" &&\n\t\t\t(property as DataField).Value?.$target?.annotations?.Core?.isURL !== true\n\t\t) {\n\t\t\t//For Stream\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn propertyType\n\t\t? ![\n\t\t\t\tUIAnnotationTypes.DataFieldForAction,\n\t\t\t\tUIAnnotationTypes.DataFieldForIntentBasedNavigation,\n\t\t\t\tUIAnnotationTypes.DataFieldForActionGroup\n\t\t  ].includes(propertyType)\n\t\t: true;\n}\n\n/**\n * Returns Boolean true for valid columns, false for invalid columns.\n * @param dataField Different DataField types defined in the annotations\n * @returns True for valid columns, false for invalid columns\n */\nconst _isValidColumn = function (dataField: DataFieldAbstractTypes): boolean {\n\tswitch (dataField.$Type) {\n\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\treturn !!dataField.Inline;\n\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataField:\n\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\t// Todo: Replace with proper Log statement once available\n\t\t\t//  throw new Error(\"Unhandled DataField Abstract type: \" + dataField.$Type);\n\t\t\treturn false;\n\t}\n};\n\n/**\n * Returns the binding expression to evaluate the visibility of a DataField or DataPoint annotation.\n *\n * SAP Fiori elements will evaluate either the UI.Hidden annotation defined on the annotation itself or on the target property.\n * @param dataFieldModelPath The metapath referring to the annotation that is evaluated by SAP Fiori elements.\n * @returns An expression that you can bind to the UI.\n */\nconst _getVisibleExpression = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes>\n): BindingToolkitExpression<boolean> {\n\tconst targetObject = dataFieldModelPath.targetObject;\n\tlet propertyValue;\n\tif (targetObject) {\n\t\tswitch (targetObject.$Type) {\n\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\tcase UIAnnotationTypes.DataPointType:\n\t\t\t\tpropertyValue = targetObject.Value.$target;\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t// if it is a DataFieldForAnnotation pointing to a DataPoint we look at the dataPoint's value\n\t\t\t\tif (targetObject?.Target?.$target?.$Type === UIAnnotationTypes.DataPointType) {\n\t\t\t\t\tpropertyValue = targetObject.Target.$target?.Value.$target;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\tdefault:\n\t\t\t\tpropertyValue = undefined;\n\t\t}\n\t}\n\tconst isAnalyticalGroupHeaderExpanded = /*formatOptions?.isAnalytics ? UI.IsExpanded :*/ constant(false);\n\tconst isAnalyticalLeaf = /*formatOptions?.isAnalytics ? equal(UI.NodeLevel, 0) :*/ constant(false);\n\t// A data field is visible if:\n\t// - the UI.Hidden expression in the original annotation does not evaluate to 'true'\n\t// - the UI.Hidden expression in the target property does not evaluate to 'true'\n\t// - in case of Analytics it's not visible for an expanded GroupHeader\n\treturn and(\n\t\t...[\n\t\t\tnot(equal(getExpressionFromAnnotation(targetObject?.annotations?.UI?.Hidden), true)),\n\t\t\tifElse(\n\t\t\t\t!!propertyValue,\n\t\t\t\tpropertyValue && not(equal(getExpressionFromAnnotation(propertyValue.annotations?.UI?.Hidden), true)),\n\t\t\t\ttrue\n\t\t\t),\n\t\t\tor(not(isAnalyticalGroupHeaderExpanded), isAnalyticalLeaf)\n\t\t]\n\t);\n};\n\n/**\n * Returns hidden binding expressions for a field group.\n * @param dataFieldGroup DataField defined in the annotations\n * @returns Compile binding of field group expressions.\n */\nconst _getFieldGroupHiddenExpressions = function (dataFieldGroup: DataFieldAbstractTypes): CompiledBindingToolkitExpression | undefined {\n\tconst fieldGroupHiddenExpressions: BindingToolkitExpression<boolean>[] = [];\n\tif (\n\t\tdataFieldGroup.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\tdataFieldGroup.Target?.$target?.$Type === UIAnnotationTypes.FieldGroupType\n\t) {\n\t\tif (dataFieldGroup?.annotations?.UI?.Hidden) {\n\t\t\treturn compileExpression(not(equal(getExpressionFromAnnotation(dataFieldGroup.annotations.UI.Hidden), true)));\n\t\t} else {\n\t\t\tdataFieldGroup.Target.$target.Data?.forEach((innerDataField: DataFieldAbstractTypes | DataPointTypeTypes) => {\n\t\t\t\tfieldGroupHiddenExpressions.push(\n\t\t\t\t\t_getVisibleExpression({ targetObject: innerDataField } as DataModelObjectPath<\n\t\t\t\t\t\tDataFieldAbstractTypes | DataPointTypeTypes\n\t\t\t\t\t>)\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn compileExpression(ifElse(or(...fieldGroupHiddenExpressions), constant(true), constant(false)));\n\t\t}\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\n/**\n * Returns the label for the property and dataField.\n * @param [property] Property, DataField or Navigation Property defined in the annotations\n * @param isGroup\n * @returns Label of the property or DataField\n */\nconst getLabel = function (property: DataFieldAbstractTypes | Property | NavigationProperty, isGroup = false): string | undefined {\n\tif (!property) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(property) || isNavigationProperty(property)) {\n\t\tconst dataFieldDefault = (property as Property).annotations?.UI?.DataFieldDefault;\n\t\tif (dataFieldDefault && !dataFieldDefault.qualifier && dataFieldDefault.Label) {\n\t\t\treturn dataFieldDefault.Label?.toString();\n\t\t}\n\t\treturn property.annotations.Common?.Label?.toString() ?? property.name;\n\t} else if (isDataFieldTypes(property)) {\n\t\tif (!!isGroup && property.$Type === UIAnnotationTypes.DataFieldWithIntentBasedNavigation) {\n\t\t\treturn property?.Label?.toString();\n\t\t}\n\t\treturn (\n\t\t\tproperty?.Label?.toString() ??\n\t\t\tcompileExpression(\n\t\t\t\tgetExpressionFromAnnotation(property.Value?.$target?.annotations?.Common?.Label, [], property.Value?.$target?.name)\n\t\t\t)\n\t\t);\n\t} else if (property.$Type === UIAnnotationTypes.DataFieldForAnnotation) {\n\t\treturn (\n\t\t\tproperty.Label?.toString() ??\n\t\t\tcompileExpression(\n\t\t\t\tgetExpressionFromAnnotation((property.Target?.$target as DataPoint)?.Value?.$target?.annotations?.Common?.Label?.valueOf())\n\t\t\t)\n\t\t);\n\t} else {\n\t\treturn property.Label?.toString();\n\t}\n};\n\nconst _getTooltip = function (source: DataFieldAbstractTypes | Property): string | undefined {\n\tif (!source) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(source) || source.annotations?.Common?.QuickInfo) {\n\t\treturn source.annotations?.Common?.QuickInfo\n\t\t\t? compileExpression(getExpressionFromAnnotation(source.annotations.Common.QuickInfo))\n\t\t\t: undefined;\n\t} else if (isDataFieldTypes(source)) {\n\t\treturn source.Value?.$target?.annotations?.Common?.QuickInfo\n\t\t\t? compileExpression(getExpressionFromAnnotation(source.Value.$target.annotations.Common.QuickInfo))\n\t\t\t: undefined;\n\t} else if (source.$Type === UIAnnotationTypes.DataFieldForAnnotation) {\n\t\tconst datapointTarget = source.Target?.$target as DataPoint;\n\t\treturn datapointTarget?.Value?.$target?.annotations?.Common?.QuickInfo\n\t\t\t? compileExpression(getExpressionFromAnnotation(datapointTarget.Value.$target.annotations.Common.QuickInfo))\n\t\t\t: undefined;\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\nexport function getRowStatusVisibility(colName: string, isSemanticKeyInFieldGroup?: boolean): BindingToolkitExpression<boolean> {\n\treturn formatResult(\n\t\t[\n\t\t\tpathInModel(`semanticKeyHasDraftIndicator`, \"internal\"),\n\t\t\tpathInModel(`filteredMessages`, \"internal\"),\n\t\t\tcolName,\n\t\t\tisSemanticKeyInFieldGroup\n\t\t],\n\t\ttableFormatters.getErrorStatusTextVisibilityFormatter\n\t);\n}\n\n/**\n * Creates a PropertyInfo for each identified property consumed by a LineItem.\n * @param columnsToBeCreated Identified properties.\n * @param existingColumns The list of columns created for LineItems and Properties of entityType.\n * @param converterContext The converter context.\n * @param entityType The entity type for the LineItem\n * @param displayModeOfDescriptionPropertiesMap The map of properties referenced as text on a text arrangement annotation.\n * @param tableCreationMode The creation mode of the table\n * @param restrictionsOnProperties The existing restrictions on properties\n * @returns The array of columns created.\n */\nconst _createRelatedColumns = function (\n\tcolumnsToBeCreated: Record<string, Property>,\n\texistingColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType,\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\ttableCreationMode?: CreationMode,\n\trestrictionsOnProperties?: RestrictionsOnProperties\n): AnnotationTableColumn[] {\n\tconst relatedColumns: AnnotationTableColumn[] = [];\n\tconst relatedPropertyNameMap: Record<string, string> = {};\n\tconst aggregationHelper = new AggregationHelper(entityType, converterContext);\n\tObject.keys(columnsToBeCreated).forEach((name) => {\n\t\tconst property = columnsToBeCreated[name],\n\t\t\tannotationPath = converterContext.getAbsoluteAnnotationPath(name),\n\t\t\t// Check whether the related column already exists.\n\t\t\trelatedColumn = existingColumns.find((column) => column.name === name);\n\t\tconst dataModelObjectPath = converterContext.getConverterContextFor(converterContext.getContextPath()).getDataModelObjectPath();\n\t\tconst propertyObjectPath = enhanceDataModelPath<PageContextPathTarget>(dataModelObjectPath, name);\n\t\tif (isMultiValueField(propertyObjectPath)) {\n\t\t\tconst newNameRelativeTargetPath = getContextRelativeTargetObjectPath(propertyObjectPath, false, true);\n\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tannotationPath,\n\t\t\t\tname,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode,\n\t\t\t\tundefined,\n\t\t\t\tnewNameRelativeTargetPath\n\t\t\t);\n\t\t\tcomputeHiddenOnRelatedColumns(existingColumns, name, column);\n\t\t\tupdatePropertyLabel(existingColumns, columnsToBeCreated, column, name);\n\t\t\trelatedColumns.push(column);\n\t\t\trelatedPropertyNameMap[name] = newNameRelativeTargetPath ?? name;\n\t\t} else if (relatedColumn === undefined) {\n\t\t\t// Case 1: Key contains DataField prefix to ensure all property columns have the same key format.\n\t\t\t// New created property column is set to hidden.\n\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tannotationPath,\n\t\t\t\tname,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode\n\t\t\t);\n\t\t\tcomputeHiddenOnRelatedColumns(existingColumns, name, column);\n\t\t\tupdatePropertyLabel(existingColumns, columnsToBeCreated, column);\n\t\t\trelatedColumns.push(column);\n\t\t} else if (relatedColumn.annotationPath !== annotationPath || relatedColumn.propertyInfos) {\n\t\t\t// Case 2: The existing column points to a LineItem (or)\n\t\t\t// Case 3: This is a self reference from an existing column\n\t\t\tconst newName = `Property::${name}`;\n\t\t\t// Checking whether the related property column has already been created in a previous iteration.\n\t\t\tif (!existingColumns.some((column) => column.name === newName)) {\n\t\t\t\t// Create a new property column with 'Property::' prefix,\n\t\t\t\t// Set it to hidden as it is only consumed by Complex property infos.\n\t\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\t\tproperty,\n\t\t\t\t\tannotationPath,\n\t\t\t\t\tname,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\taggregationHelper,\n\t\t\t\t\tconverterContext,\n\t\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\t\trestrictionsOnProperties,\n\t\t\t\t\ttableCreationMode\n\t\t\t\t);\n\t\t\t\tcomputeHiddenOnRelatedColumns(existingColumns, name, column);\n\t\t\t\tupdatePropertyLabel(existingColumns, columnsToBeCreated, column);\n\t\t\t\trelatedColumns.push(column);\n\t\t\t\trelatedPropertyNameMap[name] = newName;\n\t\t\t} else if (\n\t\t\t\texistingColumns.some((column) => column.name === newName) &&\n\t\t\t\texistingColumns.some((column) => column.propertyInfos?.includes(name))\n\t\t\t) {\n\t\t\t\trelatedPropertyNameMap[name] = newName;\n\t\t\t}\n\t\t} else if (\n\t\t\tdisplayModeOfDescriptionPropertiesMap[name] === \"Description\" &&\n\t\t\t!relatedColumn.filterable &&\n\t\t\t!restrictionsOnProperties?.nonFilterableProperties.includes(name)\n\t\t) {\n\t\t\t// Case 4: The column is a referenced text only property. Set it to hidden, non sortable nor groupable.\n\t\t\t// Case 5: The column isn't already available for filtering as it could be referenced on another column (e.g. text first).\n\t\t\trestrictionsOnProperties?.nonSortableProperties.push(name);\n\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tannotationPath,\n\t\t\t\tname,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\t{},\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode\n\t\t\t);\n\t\t\tcolumn.isGroupable = false;\n\t\t\trelatedColumns.push(column);\n\t\t}\n\t});\n\t// The property 'name' has been prefixed with 'Property::' for uniqueness.\n\t// Update the same in other propertyInfos[] references which point to this property.\n\texistingColumns.forEach((column) => {\n\t\tcolumn.propertyInfos = column.propertyInfos?.map((propertyInfo) => relatedPropertyNameMap[propertyInfo] ?? propertyInfo);\n\t\tcolumn.additionalPropertyInfos = column.additionalPropertyInfos?.map(\n\t\t\t(propertyInfo) => relatedPropertyNameMap[propertyInfo] ?? propertyInfo\n\t\t);\n\t});\n\treturn relatedColumns;\n};\n\n/**\n * Getting the Column Name\n * If it points to a DataField with one property or DataPoint with one property, it will use the property name\n * here to be consistent with the existing flex changes.\n * @param dataField Different DataField types defined in the annotations\n * @returns The name of annotation columns\n */\nconst _getAnnotationColumnName = function (dataField: DataFieldAbstractTypes): string {\n\t// This is needed as we have flexibility changes already that we have to check against\n\tif (isDataFieldTypes(dataField) && dataField.Value?.path) {\n\t\treturn dataField.Value?.path;\n\t} else if (dataField.$Type === UIAnnotationTypes.DataFieldForAnnotation && (dataField.Target?.$target as DataPoint)?.Value?.path) {\n\t\t// This is for removing duplicate properties. For example, 'Progress' Property is removed if it is already defined as a DataPoint\n\t\treturn (dataField.Target?.$target as DataPoint)?.Value.path;\n\t} else {\n\t\treturn KeyHelper.generateKeyFromDataField(dataField);\n\t}\n};\n\n/**\n * Determines if the data field labels have to be displayed in the table.\n * @param fieldGroupName The `DataField` name being processed.\n * @param visualizationPath\n * @param converterContext\n * @returns `showDataFieldsLabel` value from the manifest\n */\nconst _getShowDataFieldsLabel = function (\n\tfieldGroupName: string,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): boolean | undefined {\n\tconst columns = converterContext.getManifestControlConfiguration<TableManifestConfiguration>(visualizationPath)?.columns;\n\tconst columnKeys = columns && Object.keys(columns);\n\treturn (\n\t\tcolumnKeys &&\n\t\t!!columnKeys.find(function (key: string) {\n\t\t\treturn key === fieldGroupName && (columns[key] as CustomDefinedTableColumnForOverride).showDataFieldsLabel;\n\t\t})\n\t);\n};\n\n/**\n * Determines the relative path of the property with respect to the root entity.\n * @param dataField The `DataField` being processed.\n * @returns The relative path\n */\nconst _getRelativePath = function (dataField: DataFieldAbstractTypes): string {\n\tlet relativePath = \"\";\n\tswitch (dataField.$Type) {\n\t\tcase UIAnnotationTypes.DataField:\n\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\trelativePath = (dataField as DataField)?.Value?.path;\n\t\t\tbreak;\n\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\trelativePath = dataField?.Target?.value;\n\t\t\tbreak;\n\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\trelativePath = KeyHelper.generateKeyFromDataField(dataField);\n\t\t\tbreak;\n\t}\n\treturn relativePath;\n};\n\nconst _sliceAtSlash = function (path: string, isLastSlash: boolean, isLastPart: boolean): string {\n\tconst iSlashIndex = isLastSlash ? path.lastIndexOf(\"/\") : path.indexOf(\"/\");\n\tif (iSlashIndex === -1) {\n\t\treturn path;\n\t}\n\treturn isLastPart ? path.substring(iSlashIndex + 1, path.length) : path.substring(0, iSlashIndex);\n};\n\n/**\n * Determines if the column contains a multi-value field.\n * @param dataField The DataField being processed\n * @param converterContext The converter context\n * @returns True if the DataField corresponds to a multi-value field.\n */\nconst _isColumnMultiValued = function (\n\tdataField: DataFieldAbstractTypes,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): boolean {\n\tif (isDataFieldTypes(dataField) && isPathAnnotationExpression(dataField.Value)) {\n\t\tconst propertyObjectPath = enhanceDataModelPath<PageContextPathTarget>(\n\t\t\tconverterContext.getDataModelObjectPath(),\n\t\t\tdataField.Value.path\n\t\t);\n\t\treturn isMultiValueField(propertyObjectPath);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n * Determine whether a column is sortable.\n * @param dataField The data field being processed\n * @param propertyPath The property path\n * @param nonSortableColumns Collection of non-sortable column names as per annotation\n * @param relatedPropertiesInfo The related properties linked to the column\n * @returns True if the column is sortable\n */\nconst _isColumnSortable = function (\n\tdataField: DataFieldAbstractTypes,\n\tpropertyPath: string,\n\tnonSortableColumns: string[],\n\trelatedPropertiesInfo: ComplexPropertyInfo\n): boolean {\n\treturn (\n\t\t!nonSortableColumns.includes(propertyPath) && // Column is not marked as non-sortable via annotation\n\t\t(((dataField.$Type === UIAnnotationTypes.DataField || dataField.$Type === UIAnnotationTypes.DataFieldForAnnotation) &&\n\t\t\tObject.keys(relatedPropertiesInfo.properties).some((propName) => {\n\t\t\t\tconst isHidden = isReferencePropertyStaticallyHidden(relatedPropertiesInfo.properties[propName].annotationProperty);\n\t\t\t\treturn !isHidden && !nonSortableColumns.includes(propName);\n\t\t\t})) ||\n\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldWithUrl ||\n\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldWithIntentBasedNavigation ||\n\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldWithAction)\n\t);\n};\n\n/**\n * Returns whether filtering on the table is case sensitive.\n * @param converterContext The instance of the converter context\n * @returns Returns 'false' if FilterFunctions annotation supports 'tolower', else 'true'\n */\nexport const isFilteringCaseSensitive = function (converterContext: ConverterContext<PageContextPathTarget>): boolean {\n\tconst filterFunctions: FilterFunctions | undefined = _getFilterFunctions(converterContext);\n\treturn ModelHelper.isFilteringCaseSensitive(undefined, filterFunctions);\n};\n\nfunction _getFilterFunctions(ConverterContext: ConverterContext<PageContextPathTarget>): FilterFunctions | undefined {\n\tconst entitySet = ConverterContext.getEntitySet();\n\tif (TypeGuards.isEntitySet(entitySet)) {\n\t\treturn (\n\t\t\tentitySet.annotations.Capabilities?.FilterFunctions ??\n\t\t\tConverterContext.getEntityContainer().annotations.Capabilities?.FilterFunctions\n\t\t);\n\t}\n\treturn undefined;\n}\n\n/**\n * Returns default format options for text fields in a table.\n * @param formatOptions\n * @returns Collection of format options with default values\n */\nfunction _getDefaultFormatOptionsForTable(formatOptions: FormatOptionsType | undefined): FormatOptionsType | undefined {\n\treturn formatOptions === undefined\n\t\t? undefined\n\t\t: {\n\t\t\t\ttextLinesEdit: 4,\n\t\t\t\t...formatOptions\n\t\t  };\n}\n\nfunction _findSemanticKeyValues(semanticKeys: SemanticKey, name: string): { values: string[]; semanticKeyFound: boolean } {\n\tconst aSemanticKeyValues: string[] = [];\n\tlet bSemanticKeyFound = false;\n\tfor (let i = 0; i < semanticKeys.length; i++) {\n\t\taSemanticKeyValues.push(semanticKeys[i].value);\n\t\tif (semanticKeys[i].value === name) {\n\t\t\tbSemanticKeyFound = true;\n\t\t}\n\t}\n\treturn {\n\t\tvalues: aSemanticKeyValues,\n\t\tsemanticKeyFound: bSemanticKeyFound\n\t};\n}\n\nfunction _findProperties(\n\tsemanticKeyValues: string[],\n\tfieldGroupProperties: string[]\n): { semanticKeyHasPropertyInFieldGroup: boolean; fieldGroupPropertyPath?: string } {\n\tlet semanticKeyHasPropertyInFieldGroup = false;\n\tlet sPropertyPath;\n\tif (semanticKeyValues && semanticKeyValues.length >= 1 && fieldGroupProperties && fieldGroupProperties.length >= 1) {\n\t\tfor (let i = 0; i < semanticKeyValues.length; i++) {\n\t\t\tif ([semanticKeyValues[i]].some((tmp) => fieldGroupProperties.includes(tmp))) {\n\t\t\t\tsemanticKeyHasPropertyInFieldGroup = true;\n\t\t\t\tsPropertyPath = semanticKeyValues[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tsemanticKeyHasPropertyInFieldGroup: semanticKeyHasPropertyInFieldGroup,\n\t\tfieldGroupPropertyPath: sPropertyPath\n\t};\n}\n\n/**\n * Find the first property in the fieldGroup that is part of the semantic keys.\n * @param dataFieldGroup\n * @param semanticKeyValues\n * @returns An object containing a flag true if a property is found and a propertyPath.\n */\nfunction _findSemanticKeyValuesInFieldGroup(\n\tdataFieldGroup: DataFieldAbstractTypes | null,\n\tsemanticKeyValues: string[]\n): { semanticKeyHasPropertyInFieldGroup: boolean; propertyPath?: string } {\n\t// this info is used in FieldHelper#isDraftIndicatorVisibleInFieldGroup to show a draft indicator at the end of a field group\n\tconst aProperties: string[] = [];\n\tlet _propertiesFound: { semanticKeyHasPropertyInFieldGroup: boolean; fieldGroupPropertyPath?: string } = {\n\t\tsemanticKeyHasPropertyInFieldGroup: false,\n\t\tfieldGroupPropertyPath: undefined\n\t};\n\tif (\n\t\tdataFieldGroup &&\n\t\tdataFieldGroup.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\tdataFieldGroup.Target?.$target?.$Type === UIAnnotationTypes.FieldGroupType\n\t) {\n\t\tdataFieldGroup.Target.$target.Data?.forEach((innerDataField: DataFieldAbstractTypes) => {\n\t\t\tif (\n\t\t\t\t(innerDataField.$Type === UIAnnotationTypes.DataField || innerDataField.$Type === UIAnnotationTypes.DataFieldWithUrl) &&\n\t\t\t\tinnerDataField.Value\n\t\t\t) {\n\t\t\t\taProperties.push(innerDataField.Value.path);\n\t\t\t}\n\t\t\t_propertiesFound = _findProperties(semanticKeyValues, aProperties);\n\t\t});\n\t}\n\treturn {\n\t\tsemanticKeyHasPropertyInFieldGroup: _propertiesFound.semanticKeyHasPropertyInFieldGroup,\n\t\tpropertyPath: _propertiesFound.fieldGroupPropertyPath\n\t};\n}\n\n/**\n * Returns default format options with draftIndicator for a column.\n * @param name\n * @param semanticKeys\n * @param dataFieldGroup\n * @returns Collection of format options with default values\n */\nfunction getDefaultDraftIndicatorForColumn(\n\tname: string,\n\tsemanticKeys: SemanticKey,\n\tdataFieldGroup: DataFieldAbstractTypes | null\n): Partial<{\n\tfieldGroupDraftIndicatorPropertyPath: string;\n\tfieldGroupName: string;\n\tshowErrorObjectStatus: CompiledBindingToolkitExpression;\n\thasDraftIndicator: boolean;\n}> {\n\tif (!semanticKeys) {\n\t\treturn {};\n\t}\n\tconst semanticKey = _findSemanticKeyValues(semanticKeys, name);\n\tconst semanticKeyInFieldGroup = _findSemanticKeyValuesInFieldGroup(dataFieldGroup, semanticKey.values);\n\tif (semanticKeyInFieldGroup.semanticKeyHasPropertyInFieldGroup) {\n\t\t// Semantic Key has a property in a FieldGroup\n\t\treturn {\n\t\t\t//TODO we should rather store hasSemanticKeyInFieldGroup\n\t\t\tfieldGroupDraftIndicatorPropertyPath: semanticKeyInFieldGroup.propertyPath,\n\t\t\tfieldGroupName: name,\n\t\t\tshowErrorObjectStatus: compileExpression(getRowStatusVisibility(name, true))\n\t\t};\n\t} else if (semanticKey.semanticKeyFound) {\n\t\treturn {\n\t\t\thasDraftIndicator: true,\n\t\t\tshowErrorObjectStatus: compileExpression(getRowStatusVisibility(name, false))\n\t\t};\n\t}\n\treturn {};\n}\n\nfunction _getImpNumber(dataField: DataFieldTypes): number {\n\tconst importance = dataField?.annotations?.UI?.Importance as string;\n\tif (importance && importance.includes(\"UI.ImportanceType/High\")) {\n\t\treturn 3;\n\t}\n\tif (importance && importance.includes(\"UI.ImportanceType/Medium\")) {\n\t\treturn 2;\n\t}\n\tif (importance && importance.includes(\"UI.ImportanceType/Low\")) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction _getDataFieldImportance(dataField: DataFieldTypes): Importance {\n\tconst importance = dataField?.annotations?.UI?.Importance as string;\n\treturn importance ? (importance.split(\"/\")[1] as Importance) : Importance.None;\n}\n\n/**\n * Sets the export settings of a column containing datapoints.\n * @param property The property referenced on a given column\n * @param column The column to be updated\n */\nfunction _setExportSettingsForDataPoint(property: Property, column: AnnotationTableColumn): void {\n\tconst targetValuefromDP = getTargetValueOnDataPoint(property);\n\tif (\n\t\tisDataPointFromDataFieldDefault(property) &&\n\t\ttypeof targetValuefromDP === \"string\" &&\n\t\tcolumn.exportSettings &&\n\t\tcolumn.exportSettings?.unit !== \"%\"\n\t) {\n\t\tcolumn.exportDataPointTargetValue = targetValuefromDP;\n\t\tcolumn.exportSettings.template = \"{0}/\" + targetValuefromDP;\n\t}\n}\n\nfunction _getMaxImportance(fields: DataFieldTypes[]): Importance {\n\tif (fields && fields.length > 0) {\n\t\tlet maxImpNumber = -1;\n\t\tlet impNumber = -1;\n\t\tlet DataFieldWithMaxImportance;\n\t\tfor (const field of fields) {\n\t\t\timpNumber = _getImpNumber(field);\n\t\t\tif (impNumber > maxImpNumber) {\n\t\t\t\tmaxImpNumber = impNumber;\n\t\t\t\tDataFieldWithMaxImportance = field;\n\t\t\t}\n\t\t}\n\t\treturn _getDataFieldImportance(DataFieldWithMaxImportance as DataFieldTypes);\n\t}\n\treturn Importance.None;\n}\n\n/**\n * Returns the importance value for a column.\n * @param converterContext\n * @param dataField\n * @returns The importance value\n */\nexport function getImportance(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdataField: DataFieldAbstractTypes | undefined\n): Importance | undefined {\n\tif (!dataField) {\n\t\treturn undefined;\n\t}\n\tconst semanticKeys = converterContext.getDataModelObjectPath().targetEntityType.annotations.Common?.SemanticKey ?? [];\n\tconst requiredProperties = getRequiredProperties(converterContext);\n\tconst highKeys = [...semanticKeys, ...requiredProperties].map((propertyPath) => propertyPath.$target?.fullyQualifiedName);\n\t//Evaluate default Importance is not set explicitly\n\tlet fieldsWithImportance;\n\tif (isAnnotationOfType<DataFieldForAnnotation>(dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\tconst dataFieldTarget = dataField.Target.$target;\n\t\tif (isAnnotationOfType<FieldGroup>(dataFieldTarget, UIAnnotationTypes.FieldGroupType)) {\n\t\t\tconst fieldGroupData = dataFieldTarget.Data;\n\t\t\t//If a FieldGroup contains a semanticKey or required property, importance set to High\n\t\t\tif (\n\t\t\t\tfieldGroupData.some(function (fieldGroupDataField: DataFieldAbstractTypes): boolean {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tisDataFieldTypes(fieldGroupDataField) && highKeys.includes(fieldGroupDataField.Value?.$target?.fullyQualifiedName)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\treturn Importance.High;\n\t\t\t} else {\n\t\t\t\t//If the DataFieldForAnnotation has an Importance we take it\n\t\t\t\tif (dataField?.annotations?.UI?.Importance) {\n\t\t\t\t\treturn _getDataFieldImportance(dataField as unknown as DataFieldTypes);\n\t\t\t\t}\n\t\t\t\t// else the highest importance (if any) is returned\n\t\t\t\tfieldsWithImportance = fieldGroupData.filter(function (item) {\n\t\t\t\t\treturn item?.annotations?.UI?.Importance;\n\t\t\t\t});\n\t\t\t\treturn _getMaxImportance(fieldsWithImportance as DataFieldTypes[]);\n\t\t\t}\n\t\t}\n\t}\n\treturn highKeys.includes((dataField as DataFieldTypes).Value?.$target?.fullyQualifiedName)\n\t\t? Importance.High\n\t\t: _getDataFieldImportance(dataField as unknown as DataFieldTypes);\n}\n\n/**\n * Returns line items from metadata annotations.\n * @param lineItemAnnotation Collection of data fields with their annotations\n * @param tableType The table type\n * @param visualizationPath The visualization path\n * @param converterContext The converter context\n * @returns The columns from the annotations\n */\nconst getColumnsFromAnnotations = function (\n\tlineItemAnnotation: LineItem,\n\ttableType: TableType,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): AnnotationTableColumn[] {\n\tconst entityType: EntityType = converterContext.getAnnotationEntityType(lineItemAnnotation),\n\t\tannotationColumns: AnnotationTableColumn[] = [],\n\t\tcolumnsToBeCreated: Record<string, Property> = {},\n\t\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode> = {},\n\t\trestrictionsOnProperties = getRestrictionsOnProperties(converterContext),\n\t\ttableManifestSettings: TableManifestConfiguration = converterContext.getManifestControlConfiguration(visualizationPath),\n\t\tdefaultCreationMode =\n\t\t\tconverterContext.getManifestWrapper().getSapFeManifestConfiguration()?.macros?.table?.defaultCreationMode ===\n\t\t\t\"InlineCreationRows\"\n\t\t\t\t? CreationMode.InlineCreationRows\n\t\t\t\t: undefined,\n\t\ttableCreationMode: CreationMode =\n\t\t\ttableManifestSettings?.tableSettings?.creationMode?.name ?? defaultCreationMode ?? CreationMode.Inline;\n\tconst semanticKeys: SemanticKey = converterContext.getAnnotationsByTerm(\"Common\", CommonAnnotationTerms.SemanticKey, [\n\t\tconverterContext.getEntityType()\n\t])[0] as SemanticKey;\n\tif (lineItemAnnotation) {\n\t\tconst tableConverterContext = converterContext.getConverterContextFor<PageContextPathTarget>(\n\t\t\tgetTargetObjectPath(converterContext.getDataModelObjectPath())\n\t\t);\n\t\tlineItemAnnotation.forEach((dataField) => {\n\t\t\t// TODO: variable name should be datafield and not lineItem\n\t\t\tif (!_isValidColumn(dataField)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet exportSettings: PropertyInfo[\"exportSettings\"] = null;\n\t\t\tconst semanticObjectAnnotationPath =\n\t\t\t\tisDataFieldTypes(dataField) && dataField.Value?.$target?.fullyQualifiedName\n\t\t\t\t\t? getSemanticObjectPath(converterContext, dataField)\n\t\t\t\t\t: undefined;\n\t\t\tconst relativePath = _getRelativePath(dataField);\n\t\t\t// Determine properties which are consumed by this LineItem.\n\t\t\tconst relatedPropertiesInfo: ComplexPropertyInfo = collectRelatedPropertiesRecursively(dataField, converterContext, tableType);\n\t\t\tconst relatedPropertyNames: string[] = Object.keys(relatedPropertiesInfo.properties);\n\t\t\tconst additionalPropertyNames: string[] = Object.keys(relatedPropertiesInfo.additionalProperties);\n\t\t\tconst groupPath: string | undefined = relativePath ? _sliceAtSlash(relativePath, true, false) : undefined;\n\t\t\tconst isGroup: boolean = groupPath != relativePath;\n\t\t\tconst label = getLabel(dataField, isGroup);\n\t\t\tconst name = _getAnnotationColumnName(dataField);\n\t\t\tconst isFieldGroupColumn: boolean = groupPath ? groupPath.includes(`@${UIAnnotationTerms.FieldGroup}`) : false;\n\t\t\tconst showDataFieldsLabel: boolean | undefined = isFieldGroupColumn\n\t\t\t\t? _getShowDataFieldsLabel(name, visualizationPath, converterContext)\n\t\t\t\t: false;\n\t\t\tconst dataType: string | undefined = getDataFieldDataType(dataField);\n\t\t\tconst formatOptions = _getDefaultFormatOptionsForTable(getDefaultDraftIndicatorForColumn(name, semanticKeys, dataField));\n\t\t\tconst propertyDataModelObjectPath = enhanceDataModelPath<DataFieldAbstractTypes>(\n\t\t\t\tconverterContext.getDataModelObjectPath(),\n\t\t\t\trelativePath\n\t\t\t);\n\t\t\t// Determine if we need a situations indicator\n\t\t\tconst navigationProperties: NavigationProperty[] = propertyDataModelObjectPath.targetEntityType.navigationProperties;\n\t\t\tconst situationsNavProps = navigationProperties.filter(\n\t\t\t\t(navigationProperty) =>\n\t\t\t\t\t!navigationProperty.isCollection &&\n\t\t\t\t\tnavigationProperty.targetType.annotations.Common?.SAPObjectNodeType?.Name === \"BusinessSituation\"\n\t\t\t);\n\t\t\tconst situationsNavProp: NavigationProperty | undefined = situationsNavProps.length >= 1 ? situationsNavProps[0] : undefined;\n\t\t\tif (situationsNavProp && formatOptions) {\n\t\t\t\tformatOptions.hasSituationsIndicator = true;\n\t\t\t}\n\n\t\t\tlet fieldGroupHiddenExpressions: CompiledBindingToolkitExpression;\n\t\t\tif (\n\t\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\t\t\tdataField.Target?.$target?.$Type === UIAnnotationTypes.FieldGroupType\n\t\t\t) {\n\t\t\t\tfieldGroupHiddenExpressions = _getFieldGroupHiddenExpressions(dataField);\n\t\t\t}\n\t\t\tconst isMultiValue = _isColumnMultiValued(dataField, tableConverterContext);\n\t\t\tif (!isMultiValue && _isExportableColumn(dataField)) {\n\t\t\t\t//exclude the types listed above for the Export (generates error on Export as PDF)\n\t\t\t\texportSettings = createColumnExportSettings(dataField, relatedPropertiesInfo);\n\t\t\t}\n\t\t\tlet propertyTypeConfig: PropertyTypeConfig | undefined;\n\t\t\tif (dataType) {\n\t\t\t\tpropertyTypeConfig = getTypeConfig(dataField, dataType);\n\t\t\t}\n\t\t\tconst typeConfig: PropertyTypeConfig = {\n\t\t\t\tclassName: dataType as keyof typeof DefaultTypeForEdmType,\n\t\t\t\tformatOptions: {\n\t\t\t\t\t...formatOptions,\n\t\t\t\t\t...propertyTypeConfig?.formatOptions\n\t\t\t\t},\n\t\t\t\tconstraints: { ...propertyTypeConfig?.constraints }\n\t\t\t};\n\t\t\tconst visualSettings: VisualSettings = {};\n\t\t\tif (!dataType || !typeConfig) {\n\t\t\t\t// for charts\n\t\t\t\tvisualSettings.widthCalculation = null;\n\t\t\t}\n\t\t\tconst sortable =\n\t\t\t\t!isMultiValue &&\n\t\t\t\t_isColumnSortable(dataField, relativePath, restrictionsOnProperties.nonSortableProperties, relatedPropertiesInfo);\n\t\t\tconst availability = isReferencePropertyStaticallyHidden(dataField) ? \"Hidden\" : \"Default\";\n\t\t\tconst column: AnnotationTableColumn = {\n\t\t\t\tkey: KeyHelper.generateKeyFromDataField(dataField),\n\t\t\t\ttype: ColumnType.Annotation,\n\t\t\t\tlabel: label ?? name,\n\t\t\t\tgroupLabel: isGroup ? getLabel(dataField) : undefined,\n\t\t\t\tgroup: isGroup ? groupPath : undefined,\n\t\t\t\tFieldGroupHiddenExpressions: fieldGroupHiddenExpressions,\n\t\t\t\tannotationPath: converterContext.getEntitySetBasedAnnotationPath(dataField.fullyQualifiedName),\n\t\t\t\tsemanticObjectPath: semanticObjectAnnotationPath,\n\t\t\t\tavailability: availability,\n\t\t\t\tname: name,\n\t\t\t\tshowDataFieldsLabel: showDataFieldsLabel,\n\t\t\t\trequired: isRequiredColumn(converterContext, dataField as DataFieldTypes, tableCreationMode),\n\t\t\t\trelativePath: relativePath,\n\t\t\t\tsortable: sortable,\n\t\t\t\tpropertyInfos: relatedPropertyNames.length ? relatedPropertyNames : undefined,\n\t\t\t\tadditionalPropertyInfos: additionalPropertyNames.length > 0 ? additionalPropertyNames : undefined,\n\t\t\t\texportSettings: exportSettings,\n\t\t\t\twidth: (dataField.annotations?.HTML5?.CssDefaults?.width?.valueOf() as string) || undefined,\n\t\t\t\timportance: getImportance(converterContext, dataField as DataFieldTypes),\n\t\t\t\tisNavigable: true,\n\t\t\t\tformatOptions: formatOptions,\n\t\t\t\tcaseSensitive: isFilteringCaseSensitive(converterContext),\n\t\t\t\ttypeConfig: typeConfig,\n\t\t\t\tvisualSettings: visualSettings as PropertyInfo[\"visualSettings\"],\n\t\t\t\ttimezoneText: exportSettings?.timezone,\n\t\t\t\tisPartOfLineItem: true,\n\t\t\t\tdataType: dataType ?? (\"Edm.String\" as keyof typeof DefaultTypeForEdmType),\n\t\t\t\tisMultiValue\n\t\t\t};\n\t\t\tconst tooltip = _getTooltip(dataField) ?? label;\n\t\t\tif (tooltip) {\n\t\t\t\tcolumn.tooltip = tooltip;\n\t\t\t}\n\t\t\tif (relatedPropertiesInfo.exportSettings.dataPointTargetValue) {\n\t\t\t\tcolumn.exportDataPointTargetValue = relatedPropertiesInfo.exportSettings.dataPointTargetValue;\n\t\t\t}\n\t\t\tannotationColumns.push(column);\n\t\t\t// Collect information of related columns to be created.\n\t\t\trelatedPropertyNames.forEach((relatedPropertyName) => {\n\t\t\t\tcolumnsToBeCreated[relatedPropertyName] = relatedPropertiesInfo.properties[relatedPropertyName].annotationProperty;\n\t\t\t\t// In case of a multi-value, related properties cannot be sorted as we go through a 1-n relation\n\t\t\t\tif (isMultiValue) {\n\t\t\t\t\trestrictionsOnProperties.nonSortableProperties.push(relatedPropertyName);\n\t\t\t\t}\n\t\t\t\taddPropertyToDisplayModeOfDescriptionPropertiesMap(\n\t\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\t\trelatedPropertiesInfo,\n\t\t\t\t\trelatedPropertyName\n\t\t\t\t);\n\t\t\t\t// In case the lineItem points to a navigation property with a textArrangement TextOnly, we need to create the column with the value navigation property.\n\t\t\t\t// The text property is referenced on the related properties of the lineItem, so will be created on the _createRelatedColumns method.\n\t\t\t\tif (relatedPropertiesInfo.properties[relatedPropertyName].displayModeOfPropertyUsedAsDescription === \"Description\") {\n\t\t\t\t\tcreatePropertyAnnotatedTextOnly(\n\t\t\t\t\t\tconverterContext,\n\t\t\t\t\t\tpropertyDataModelObjectPath,\n\t\t\t\t\t\tdataField,\n\t\t\t\t\t\tcolumnsToBeCreated,\n\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\trestrictionsOnProperties\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// Create columns for additional properties identified for ALP use case.\n\t\t\tadditionalPropertyNames.forEach((additionalPropertyName) => {\n\t\t\t\t// Intentional overwrite as we require only one new PropertyInfo for a related Property.\n\t\t\t\tcolumnsToBeCreated[additionalPropertyName] = relatedPropertiesInfo.additionalProperties[additionalPropertyName];\n\t\t\t});\n\t\t});\n\t}\n\t// Get columns from the Properties of EntityType\n\treturn getColumnsFromEntityType(\n\t\tcolumnsToBeCreated,\n\t\tentityType,\n\t\tannotationColumns,\n\t\tconverterContext,\n\t\ttableType,\n\t\ttableCreationMode,\n\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\trestrictionsOnProperties\n\t);\n};\n\n/**\n * Gets the property names from the manifest and checks against existing properties already added by annotations.\n * If a not yet stored property is found it adds it for sorting and filtering only to the annotationColumns.\n * @param properties\n * @param annotationColumns\n * @param converterContext\n * @param entityType\n * @returns The columns from the annotations\n */\nconst _getPropertyNames = function (\n\tproperties: string[] | string | undefined,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType\n): string[] | undefined {\n\tlet matchedProperties: string[] | undefined;\n\tif (Array.isArray(properties)) {\n\t\tmatchedProperties = properties.map(function (propertyPath) {\n\t\t\tconst annotationColumn = annotationColumns.find(function (annotationColumn) {\n\t\t\t\treturn annotationColumn.relativePath === propertyPath && annotationColumn.propertyInfos === undefined;\n\t\t\t});\n\t\t\tif (annotationColumn) {\n\t\t\t\treturn annotationColumn.name;\n\t\t\t} else {\n\t\t\t\tconst relatedColumns = _createRelatedColumns(\n\t\t\t\t\t{ [propertyPath]: entityType.resolvePath(propertyPath) },\n\t\t\t\t\tannotationColumns,\n\t\t\t\t\tconverterContext,\n\t\t\t\t\tentityType,\n\t\t\t\t\t{}\n\t\t\t\t);\n\t\t\t\tannotationColumns.push(relatedColumns[0]);\n\t\t\t\treturn relatedColumns[0].name;\n\t\t\t}\n\t\t});\n\t}\n\treturn matchedProperties;\n};\n\n/**\n * Determines if the field group has to be flagged as required.\n * @param converterContext The converter context\n * @param fieldGroup The fieldGroup being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the fieldGroup is required.\n */\nconst isRequiredFieldGroup = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tfieldGroup: FieldGroup,\n\ttableCreationMode: CreationMode\n): boolean {\n\tconst fieldGroupData = fieldGroup.Data;\n\treturn fieldGroupData.some(function (item) {\n\t\t// we exclude boolean type, the end-user may want to keep the underlying check box empty on purpose\n\t\tif (isDataField(item) && item?.Value?.$target.type !== \"Edm.Boolean\") {\n\t\t\treturn (\n\t\t\t\tisStaticallyMandatory(item) ||\n\t\t\t\t(tableCreationMode === CreationMode.InlineCreationRows &&\n\t\t\t\t\tisAnnotatedRequiredProperty(item.Value.$target.fullyQualifiedName, converterContext))\n\t\t\t);\n\t\t}\n\t});\n};\n\n/**\n * Determines if the dataFieldForAnnotation has to be flagged as required.\n * @param converterContext The converter context\n * @param dataFieldForAnnotation The property being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the property is required.\n */\nconst isRequiredDataFieldForAnnotation = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdataFieldForAnnotation: DataFieldForAnnotation,\n\ttableCreationMode: CreationMode\n): boolean {\n\tconst dataFieldTarget = dataFieldForAnnotation.Target.$target;\n\tconst DataFieldForAnnotationFieldControlNotMandatory = hasFieldControlNotMandatory(dataFieldForAnnotation);\n\t// Check if the DataFieldForAnnotation points to a FieldGroup\n\tif (hasFieldGroupTarget(dataFieldForAnnotation)) {\n\t\tif (isRequiredFieldGroup(converterContext, dataFieldTarget as FieldGroup, tableCreationMode)) {\n\t\t\treturn true;\n\t\t}\n\t\tconst fieldGroupData = (dataFieldTarget as FieldGroup).Data;\n\t\treturn fieldGroupData.some((innerDataField: DataFieldAbstractTypes) => {\n\t\t\treturn isRequiredColumn(converterContext, innerDataField, tableCreationMode);\n\t\t});\n\t}\n\t/*If the underlying datapoint is a rating indicator, the end-user may want to keep the rating empty (value 0) on purpose.\n\tBesides, currently, only a fieldControl set on a dataFieldForAnnotation pointing to a dataPoint has an influence in the table.\n\tAccordingly, if a datapoint comes from a dataFieldForAnnotation with a fieldControl set as not mandatory, this dataPoint must not be flagged as \"required\"*/\n\tif (hasDataPointTarget(dataFieldForAnnotation) && (dataFieldTarget as DataPoint).Visualization !== \"UI.VisualizationType/Rating\") {\n\t\tif (DataFieldForAnnotationFieldControlNotMandatory) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isStaticallyMandatory(dataFieldForAnnotation)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn isRequiredDataPoint(converterContext, dataFieldTarget as DataPoint, tableCreationMode);\n\t}\n\treturn false;\n};\n\n/**\n * Determines if the property has to be flagged as required.\n * @param converterContext The converter context\n * @param property The property being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the property is required.\n */\nconst isRequiredProperty = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tproperty: Property,\n\ttableCreationMode: CreationMode\n): boolean {\n\treturn (\n\t\tproperty.type !== \"Edm.Boolean\" &&\n\t\t!isRatingVisualizationFromDataFieldDefault(property) &&\n\t\t(isStaticallyMandatory(property) ||\n\t\t\t(tableCreationMode === CreationMode.InlineCreationRows &&\n\t\t\t\tisAnnotatedRequiredProperty(property.fullyQualifiedName, converterContext)))\n\t);\n};\n\n/**\n * Determines if the dataPoint has to be flagged as required.\n * @param converterContext The converter context\n * @param dataPoint The dataPoint being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the dataPoint is required.\n */\nconst isRequiredDataPoint = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdataPoint: DataPoint,\n\ttableCreationMode: CreationMode\n): boolean {\n\treturn (\n\t\tisStaticallyMandatory(dataPoint) ||\n\t\t(tableCreationMode === CreationMode.InlineCreationRows &&\n\t\t\tisAnnotatedRequiredProperty(dataPoint.Value.$target.fullyQualifiedName, converterContext))\n\t);\n};\n\n/**\n * Determines if the underlying column has to be flagged as required.\n * @param converterContext The converter context\n * @param target The target being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns The binding expression for the 'required' property of the table column.\n */\nconst isRequiredColumn = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\ttarget: DataFieldAbstractTypes | Property,\n\ttableCreationMode?: CreationMode\n): CompiledBindingToolkitExpression {\n\tconst creationMode = tableCreationMode || CreationMode.Inline;\n\tif (\n\t\tconverterContext.getTemplateType() === TemplateType.ListReport ||\n\t\tconverterContext.getTemplateType() === TemplateType.AnalyticalListPage\n\t) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(target)) {\n\t\treturn isRequiredProperty(converterContext, target, creationMode) ? compileExpression(UI.IsEditable) : undefined;\n\t}\n\t// Check if the dataField is of type DataFieldForAnnotation\n\tif (isDataFieldForAnnotation(target)) {\n\t\treturn isRequiredDataFieldForAnnotation(converterContext, target, creationMode) ? compileExpression(UI.IsEditable) : undefined;\n\t}\n\t//If the underlying property is a boolean, the end-user may want to keep the check box empty on purpose\n\tif (isDataField(target) && target.Value?.$target?.type !== \"Edm.Boolean\") {\n\t\treturn isStaticallyMandatory(target) ||\n\t\t\t(creationMode === CreationMode.InlineCreationRows &&\n\t\t\t\tisAnnotatedRequiredProperty(target.Value.$target.fullyQualifiedName, converterContext))\n\t\t\t? compileExpression(UI.IsEditable)\n\t\t\t: undefined;\n\t}\n\treturn undefined;\n};\n\nconst _appendCustomTemplate = function (\n\tproperties: string[] | undefined,\n\texportProperties: string[] | string | undefined\n): string | undefined {\n\tif (Array.isArray(exportProperties)) {\n\t\tproperties = exportProperties;\n\t}\n\tif (properties) {\n\t\treturn properties\n\t\t\t.map((property) => {\n\t\t\t\treturn `{${properties!.indexOf(property)}}`;\n\t\t\t})\n\t\t\t.join(`${\"\\n\"}`);\n\t}\n\treturn undefined;\n};\n\n/**\n * Returns table column definitions from manifest.\n *\n * These may be custom columns defined in the manifest, slot columns coming through\n * a building block, or annotation columns to overwrite annotation-based columns.\n * @param columns\n * @param annotationColumns\n * @param converterContext\n * @param entityType\n * @returns The columns from the manifest\n */\nconst getColumnsFromManifest = function (\n\tcolumns: Record<string, CustomDefinedTableColumn | CustomDefinedTableColumnForOverride>,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType\n): Record<string, ManifestColumn> {\n\tconst internalColumns: Record<string, ManifestColumn> = {};\n\tfunction isColumnOverride(\n\t\tcolumn: CustomDefinedTableColumn | CustomDefinedTableColumnForOverride,\n\t\tkey: string\n\t): column is CustomDefinedTableColumnForOverride {\n\t\treturn annotationColumns.some((annotationColumn) => annotationColumn.key === key);\n\t}\n\tfunction isSlotColumn(manifestColumn: CustomDefinedTableColumn): manifestColumn is FragmentDefinedSlotColumn {\n\t\treturn manifestColumn.type === ColumnType.Slot;\n\t}\n\tfunction isCustomColumn(manifestColumn: CustomDefinedTableColumn): manifestColumn is ManifestDefinedCustomColumn {\n\t\treturn manifestColumn.type === undefined && !!manifestColumn.template;\n\t}\n\tfunction _updateLinkedPropertiesOnCustomColumns(propertyInfos: string[], annotationTableColumns: AnnotationTableColumn[]): void {\n\t\tconst restrictionsOnProperties = getRestrictionsOnProperties(converterContext);\n\t\tpropertyInfos.forEach((property) => {\n\t\t\tannotationTableColumns.forEach((prop) => {\n\t\t\t\tif (prop.name === property) {\n\t\t\t\t\tprop.sortable = !restrictionsOnProperties.nonSortableProperties.includes(property.replace(\"Property::\", \"\"));\n\t\t\t\t\tprop.isGroupable = prop.sortable;\n\t\t\t\t\tprop.filterable = !restrictionsOnProperties.nonFilterableProperties.includes(property.replace(\"Property::\", \"\"));\n\t\t\t\t\tprop.isPartOfCustomColumn = true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\tfor (const key in columns) {\n\t\tconst manifestColumn = columns[key];\n\t\tKeyHelper.validateKey(key);\n\t\t// BaseTableColumn\n\t\tconst baseTableColumn = {\n\t\t\tkey: key,\n\t\t\twidthIncludingColumnHeader: manifestColumn.widthIncludingColumnHeader,\n\t\t\twidth: manifestColumn.width || undefined,\n\t\t\tposition: {\n\t\t\t\tanchor: manifestColumn.position?.anchor,\n\t\t\t\tplacement: manifestColumn.position === undefined ? Placement.After : manifestColumn.position.placement\n\t\t\t},\n\t\t\tcaseSensitive: isFilteringCaseSensitive(converterContext)\n\t\t};\n\t\tif (isColumnOverride(manifestColumn, key)) {\n\t\t\tconst propertiesToOverwriteAnnotationColumn: CustomElement<AnnotationTableColumnForOverride> = {\n\t\t\t\t...baseTableColumn,\n\t\t\t\timportance: manifestColumn?.importance,\n\t\t\t\thorizontalAlign: manifestColumn?.horizontalAlign,\n\t\t\t\tavailability: manifestColumn?.availability,\n\t\t\t\ttype: ColumnType.Annotation,\n\t\t\t\tisNavigable: undefined,\n\t\t\t\tsettings: manifestColumn.settings,\n\t\t\t\tformatOptions: _getDefaultFormatOptionsForTable(manifestColumn.formatOptions),\n\t\t\t\texportSettings: getCustomExportSettings(\n\t\t\t\t\tmanifestColumn?.exportSettings,\n\t\t\t\t\tannotationColumns,\n\t\t\t\t\tconverterContext,\n\t\t\t\t\tentityType,\n\t\t\t\t\tundefined,\n\t\t\t\t\tkey\n\t\t\t\t)\n\t\t\t};\n\t\t\tinternalColumns[key] = propertiesToOverwriteAnnotationColumn;\n\t\t} else {\n\t\t\tconst propertyInfos: string[] | undefined = _getPropertyNames(\n\t\t\t\tmanifestColumn.properties,\n\t\t\t\tannotationColumns,\n\t\t\t\tconverterContext,\n\t\t\t\tentityType\n\t\t\t);\n\t\t\tconst tooltipText = converterContext.fetchTextFromMetaModel(manifestColumn.tooltip),\n\t\t\t\theaderText = converterContext.fetchTextFromMetaModel(manifestColumn.header);\n\n\t\t\tconst customColumnExportSettings: ColumnExportSettings | null = propertyInfos\n\t\t\t\t? getCustomExportSettings(manifestColumn?.exportSettings, annotationColumns, converterContext, entityType, propertyInfos)\n\t\t\t\t: null;\n\t\t\tconst baseManifestColumn = {\n\t\t\t\t...baseTableColumn,\n\t\t\t\theader: headerText,\n\t\t\t\timportance: manifestColumn?.importance || Importance.None,\n\t\t\t\thorizontalAlign: manifestColumn?.horizontalAlign || HorizontalAlign.Begin,\n\t\t\t\tavailability: manifestColumn?.availability || \"Default\",\n\t\t\t\ttemplate: manifestColumn.template,\n\t\t\t\tpropertyInfos: propertyInfos,\n\t\t\t\texportSettings: customColumnExportSettings,\n\t\t\t\tid: `CustomColumn::${key}`,\n\t\t\t\tname: `CustomColumn::${key}`,\n\t\t\t\t//Needed for MDC:\n\t\t\t\tformatOptions: { textLinesEdit: 4 },\n\t\t\t\tisGroupable: false,\n\t\t\t\tisNavigable: false,\n\t\t\t\tsortable: false,\n\t\t\t\tvisualSettings: { widthCalculation: null },\n\t\t\t\ttooltip: tooltipText ? tooltipText : headerText,\n\t\t\t\tproperties: manifestColumn.properties,\n\t\t\t\trequired:\n\t\t\t\t\tmanifestColumn.required &&\n\t\t\t\t\tconverterContext.getTemplateType() !== TemplateType.ListReport &&\n\t\t\t\t\tconverterContext.getTemplateType() !== TemplateType.AnalyticalListPage\n\t\t\t\t\t\t? compileExpression(UI.IsEditable)\n\t\t\t\t\t\t: undefined\n\t\t\t};\n\t\t\tif (propertyInfos) {\n\t\t\t\t_updateLinkedPropertiesOnCustomColumns(propertyInfos, annotationColumns);\n\t\t\t}\n\t\t\tif (isSlotColumn(manifestColumn)) {\n\t\t\t\tconst customTableColumn: CustomElement<CustomBasedTableColumn> = {\n\t\t\t\t\t...baseManifestColumn,\n\t\t\t\t\ttype: ColumnType.Slot\n\t\t\t\t};\n\t\t\t\tinternalColumns[key] = customTableColumn;\n\t\t\t} else if (isCustomColumn(manifestColumn)) {\n\t\t\t\tconst customTableColumn: CustomElement<CustomBasedTableColumn> = {\n\t\t\t\t\t...baseManifestColumn,\n\t\t\t\t\ttype: ColumnType.Default\n\t\t\t\t};\n\t\t\t\tinternalColumns[key] = customTableColumn;\n\t\t\t} else {\n\t\t\t\tconst message = `The annotation column '${key}' referenced in the manifest is not found`;\n\t\t\t\tconverterContext\n\t\t\t\t\t.getDiagnostics()\n\t\t\t\t\t.addIssue(\n\t\t\t\t\t\tIssueCategory.Manifest,\n\t\t\t\t\t\tIssueSeverity.Low,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tIssueCategoryType,\n\t\t\t\t\t\tIssueCategoryType?.AnnotationColumns?.InvalidKey\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn internalColumns;\n};\n\n/**\n * Adds computed columns such as the draft status and situations status.\n * @param tableColumns The table columns collected so far\n * @param tableType The table type\n * @param visualizationPath\n * @param converterContext\n * @returns The enriched set of table columns\n */\nexport function addComputedColumns(\n\ttableColumns: TableColumn[],\n\ttableType: TableType,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): TableColumn[] {\n\tif (![\"GridTable\", \"TreeTable\", \"AnalyticalTable\"].includes(tableType)) {\n\t\t// Computed columns are not used in Responsive tables\n\t\treturn tableColumns;\n\t}\n\n\t// In case a grid table or tree table is used, we display the situations indicator in a separate column\n\t// so we have to disable it here to ensure, that the field building block\n\t// does not render it into the ID column\n\tconst columnWithSituationsIndicator: TableColumn | undefined = tableColumns.find(\n\t\t(column) => column.formatOptions?.hasSituationsIndicator !== undefined && column.formatOptions?.hasSituationsIndicator === true\n\t);\n\tif (columnWithSituationsIndicator?.formatOptions) {\n\t\t// Switch off the situations indicator in the found column\n\t\tcolumnWithSituationsIndicator.formatOptions.hasSituationsIndicator = false;\n\n\t\t// Insert a separate situations indicator column\n\t\tconst situationsIndicatorColumn: ComputedTableColumn = {\n\t\t\tkey: \"situationsIndicator\",\n\t\t\tname: \"situationsIndicator\",\n\t\t\tpropertyKey: columnWithSituationsIndicator.name,\n\t\t\tisSituationsIndicator: true,\n\t\t\tavailability: \"Default\",\n\t\t\tlabel: \"{sap.fe.i18n>C_SITUATIONS_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttooltip: \"{sap.fe.i18n>C_SITUATIONS_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttype: ColumnType.Computed,\n\t\t\tformatOptions: null,\n\t\t\texportSettings: null,\n\t\t\tclipboardSettings: null,\n\t\t\tpropertyInfos: undefined,\n\t\t\tcaseSensitive: false\n\t\t};\n\n\t\t// Place the draft status column after the first visible column\n\t\tconst indexOfFirstVisibleColumn: int = tableColumns.findIndex((column) => column.availability !== \"Hidden\");\n\t\ttableColumns.splice(indexOfFirstVisibleColumn + 1, 0, situationsIndicatorColumn);\n\t}\n\n\t// In case a grid table or tree table is used, we display the draft indicator in a separate column\n\t// so we have to disable it here to ensure, that the field building block\n\t// does not render it into the ID column\n\t// The additional column is only added for tables on a LR and in case tehe entity is draft enabled!\n\tconst columnsWithDraftIndicator: TableColumn[] = tableColumns.filter((column) => column.formatOptions?.hasDraftIndicator === true);\n\tif (\n\t\tcolumnsWithDraftIndicator.length &&\n\t\tconverterContext.getTemplateType() === TemplateType.ListReport &&\n\t\t(ModelHelper.isDraftNode(converterContext.getEntitySet()) || ModelHelper.isDraftRoot(converterContext.getEntitySet()))\n\t) {\n\t\t// Switch off the draft indicator in the found column\n\t\tcolumnsWithDraftIndicator.forEach((columnWithDraftIndicator: TableColumn) => {\n\t\t\tif (columnWithDraftIndicator?.formatOptions) {\n\t\t\t\tcolumnWithDraftIndicator.formatOptions.hasDraftIndicator = false;\n\t\t\t}\n\t\t});\n\n\t\t// Insert a separate draft indicator column\n\t\tconst draftIndicatorColumn: ComputedTableColumn = {\n\t\t\tkey: \"draftStatus\",\n\t\t\tname: \"draftStatus\",\n\t\t\tpropertyKey: columnsWithDraftIndicator[0].name,\n\t\t\tisDraftIndicator: true,\n\t\t\tavailability: \"Default\",\n\t\t\tlabel: \"{sap.fe.i18n>C_DRAFT_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttooltip: \"{sap.fe.i18n>C_DRAFT_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttype: ColumnType.Computed,\n\t\t\tformatOptions: null,\n\t\t\texportSettings: null,\n\t\t\tcaseSensitive: false\n\t\t};\n\t\tlet columnIndexToInsertAfter: int = 0;\n\t\tif (columnWithSituationsIndicator) {\n\t\t\t// If there's a situations indicator column, place the draft status column before it\n\t\t\tcolumnIndexToInsertAfter =\n\t\t\t\ttableColumns.findIndex((column) => (column as ComputedTableColumn).isSituationsIndicator === true) - 1;\n\t\t} else {\n\t\t\t// Otherwise place the draft status column after the first visible column\n\t\t\tcolumnIndexToInsertAfter = tableColumns.findIndex((column) => column.availability !== \"Hidden\");\n\t\t}\n\t\ttableColumns.splice(columnIndexToInsertAfter + 1, 0, draftIndicatorColumn);\n\t}\n\n\treturn tableColumns;\n}\n\n/**\n * Provides the required properties set on the annotations.\n * @param converterContext  The instance of the converter context\n * @returns The paths of the restricted properties\n */\nexport function getRequiredProperties(converterContext: ConverterContext<PageContextPathTarget>): PropertyPath[] {\n\treturn getContextPropertyRestriction(\n\t\tconverterContext.getDataModelObjectPath(),\n\t\t(capabilities) => {\n\t\t\treturn (capabilities as EntitySetAnnotations_Capabilities | undefined)?.InsertRestrictions?.RequiredProperties;\n\t\t},\n\t\tfalse\n\t);\n}\n\n/**\n * Determines if the property is annotated as a required property.\n * @param name The name of the property\n * @param converterContext The instance of the converter context\n * @returns True if the property is required\n */\nfunction isAnnotatedRequiredProperty(name: string, converterContext: ConverterContext<PageContextPathTarget>): boolean {\n\treturn getRequiredProperties(converterContext)\n\t\t.map((property) => property.$target?.fullyQualifiedName)\n\t\t.includes(name);\n}\n\n/**\n * Gets the data type of a column for the export.\n * @param dataType The data type of a property, column\n * @param isATimezone Is the given property a timezone\n * @param isCurrency Is the given property a currency\n * @param exportSettings The already detected export settings from datafields\n * @returns The supported export type\n */\nfunction getExportDataType(\n\tdataType: string | undefined,\n\tisATimezone = false,\n\tisCurrency = false,\n\texportSettings?: ColumnExportSettings\n): string {\n\tlet exportDataType = \"String\";\n\tif (!dataType || exportSettings?.dataPointTargetValue) {\n\t\treturn exportDataType;\n\t}\n\tif (exportSettings?.isCurrency || isCurrency) {\n\t\treturn \"Currency\";\n\t}\n\tif (isATimezone) {\n\t\treturn \"Timezone\";\n\t}\n\tif (exportSettings?.wrap) {\n\t\treturn exportDataType;\n\t}\n\tswitch (dataType) {\n\t\tcase \"Edm.Decimal\":\n\t\tcase \"Edm.Int32\":\n\t\tcase \"Edm.Int64\":\n\t\tcase \"Edm.Double\":\n\t\tcase \"Edm.Byte\":\n\t\t\texportDataType = \"Number\";\n\t\t\tbreak;\n\t\tcase \"Edm.DateOfTime\":\n\t\tcase \"Edm.Date\":\n\t\t\texportDataType = \"Date\";\n\t\t\tbreak;\n\t\tcase \"Edm.DateTimeOffset\":\n\t\t\texportDataType = \"DateTime\";\n\t\t\tbreak;\n\t\tcase \"Edm.TimeOfDay\":\n\t\t\texportDataType = \"Time\";\n\t\t\tbreak;\n\t\tcase \"Edm.Boolean\":\n\t\t\texportDataType = \"Boolean\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texportDataType = \"String\";\n\t}\n\treturn exportDataType;\n}\n\n/**\n * Adds the tooltip configuration for a given column.\n * @param property The property referenced on the column\n * @param column The column to be updated\n */\nfunction _addToolTip(property: Property, column: AnnotationTableColumn): void {\n\tconst tooltip = _getTooltip(property) ?? column.label;\n\tif (tooltip) {\n\t\tcolumn.tooltip = tooltip;\n\t}\n}\n\nfunction _getCollectedNavigationPropertyLabels(\n\trelativePath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): string[] | undefined {\n\tconst navigationProperties = enhanceDataModelPath(converterContext.getDataModelObjectPath(), relativePath).navigationProperties;\n\tif (navigationProperties?.length > 0) {\n\t\tconst collectedNavigationPropertyLabels: string[] = [];\n\t\tnavigationProperties.forEach((navProperty) => {\n\t\t\tcollectedNavigationPropertyLabels.push(getLabel(navProperty) || navProperty.name);\n\t\t});\n\t\treturn collectedNavigationPropertyLabels;\n\t}\n}\n\n/**\n * Creates a property using the text arrangement annotation set to text only.\n * @param converterContext The converter context.\n * @param propertyDataModelObjectPath The corresponding DataModelObjectPath.\n * @param lineItem The column to be evaluated.\n * @param columnsToBeCreated The list of columns to be created.\n * @param relativePath The relative path to the target property based on the context.\n * @param restrictionsOnProperties The existing restrictions on properties\n */\nfunction createPropertyAnnotatedTextOnly(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tpropertyDataModelObjectPath: DataModelObjectPath<DataFieldAbstractTypes>,\n\tlineItem: DataFieldAbstractTypes,\n\tcolumnsToBeCreated: Record<string, Property>,\n\trelativePath: string,\n\trestrictionsOnProperties: RestrictionsOnProperties\n): void {\n\tconst isPropertyNavigated =\n\t\tpropertyDataModelObjectPath.navigationProperties.length !== converterContext.getDataModelObjectPath().navigationProperties.length;\n\tif (isPropertyNavigated && isDataField(lineItem)) {\n\t\tcolumnsToBeCreated[relativePath] = lineItem.Value.$target;\n\t\trestrictionsOnProperties.nonSortableProperties.push(relativePath);\n\t} else if (isDataFieldForAnnotation(lineItem) && hasFieldGroupTarget(lineItem)) {\n\t\t(lineItem.Target.$target as FieldGroup).Data.forEach((field) => {\n\t\t\tif (isDataField(field) && getDisplayMode(field.Value.$target) === \"Description\") {\n\t\t\t\tconst inheredPropertyDataModelObjectPath = enhanceDataModelPath(\n\t\t\t\t\tconverterContext.getDataModelObjectPath(),\n\t\t\t\t\tfield.Value.path\n\t\t\t\t);\n\t\t\t\tconst isInheredPropertyNavigated =\n\t\t\t\t\tinheredPropertyDataModelObjectPath.navigationProperties.length !==\n\t\t\t\t\tconverterContext.getDataModelObjectPath().navigationProperties.length;\n\t\t\t\tif (isInheredPropertyNavigated) {\n\t\t\t\t\tcolumnsToBeCreated[field.Value.path] = field.Value.$target;\n\t\t\t\t\trestrictionsOnProperties.nonSortableProperties.push(field.Value.path);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function getTypeConfig(oProperty: Property | DataFieldAbstractTypes | undefined, dataType: string | undefined): PropertyTypeConfig {\n\tlet oTargetMapping;\n\tif (isProperty(oProperty)) {\n\t\toTargetMapping = isTypeDefinition(oProperty.targetType)\n\t\t\t? EDM_TYPE_MAPPING[oProperty.targetType.underlyingType]\n\t\t\t: EDM_TYPE_MAPPING[oProperty.type];\n\t}\n\tif (oTargetMapping === undefined && dataType !== undefined) {\n\t\toTargetMapping = EDM_TYPE_MAPPING[dataType];\n\t}\n\tconst propertyTypeConfig: PropertyTypeConfig = {\n\t\ttype: oTargetMapping?.type,\n\t\tconstraints: {},\n\t\tformatOptions: {}\n\t};\n\tif (isProperty(oProperty) && oTargetMapping !== undefined) {\n\t\tpropertyTypeConfig.constraints = {\n\t\t\tscale: oTargetMapping.constraints?.$Scale ? oProperty.scale : undefined,\n\t\t\tprecision: oTargetMapping.constraints?.$Precision ? oProperty.precision : undefined,\n\t\t\tmaxLength: oTargetMapping.constraints?.$MaxLength ? oProperty.maxLength : undefined,\n\t\t\tnullable: oTargetMapping.constraints?.$Nullable ? oProperty.nullable : undefined,\n\t\t\tminimum:\n\t\t\t\toTargetMapping.constraints?.[\"@Org.OData.Validation.V1.Minimum/$Decimal\"] &&\n\t\t\t\t!isNaN(oProperty.annotations?.Validation?.Minimum)\n\t\t\t\t\t? `${oProperty.annotations?.Validation?.Minimum}`\n\t\t\t\t\t: undefined,\n\t\t\tmaximum:\n\t\t\t\toTargetMapping.constraints?.[\"@Org.OData.Validation.V1.Maximum/$Decimal\"] &&\n\t\t\t\t!isNaN(oProperty.annotations?.Validation?.Maximum)\n\t\t\t\t\t? `${oProperty.annotations?.Validation?.Maximum}`\n\t\t\t\t\t: undefined,\n\t\t\tisDigitSequence:\n\t\t\t\tpropertyTypeConfig.type === \"sap.ui.model.odata.type.String\" &&\n\t\t\t\toTargetMapping.constraints?.[`@${CommonAnnotationTerms.IsDigitSequence}`] &&\n\t\t\t\toProperty.annotations?.Common?.IsDigitSequence\n\t\t\t\t\t? true\n\t\t\t\t\t: undefined\n\t\t};\n\t}\n\tpropertyTypeConfig.formatOptions = {\n\t\tparseAsString:\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Double\") === 0\n\t\t\t\t? false\n\t\t\t\t: undefined,\n\t\temptyString:\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Double\") === 0\n\t\t\t\t? \"\"\n\t\t\t\t: undefined,\n\t\tparseKeepsEmptyString:\n\t\t\tpropertyTypeConfig.type === \"sap.ui.model.odata.type.String\" && propertyTypeConfig.constraints.nullable === false\n\t\t\t\t? true\n\t\t\t\t: undefined\n\t};\n\treturn propertyTypeConfig;\n}\n\n/**\n * Add a description property to the list of description properties used by the columns of a table.\n * @param displayModeOfDescriptionPropertiesMap The list of properties referenced as text on a text arrangement annotation\n * @param relatedPropertiesInfo The related properties linked to the column (named also complex property)\n * @param relatedPropertyName The property name to be added\n */\nfunction addPropertyToDisplayModeOfDescriptionPropertiesMap(\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\trelatedPropertiesInfo: ComplexPropertyInfo,\n\trelatedPropertyName: string\n): void {\n\tif (\n\t\trelatedPropertiesInfo.properties[relatedPropertyName].displayModeOfPropertyUsedAsDescription &&\n\t\t!displayModeOfDescriptionPropertiesMap[relatedPropertyName]\n\t) {\n\t\tdisplayModeOfDescriptionPropertiesMap[relatedPropertyName] =\n\t\t\trelatedPropertiesInfo.properties[relatedPropertyName].displayModeOfPropertyUsedAsDescription!;\n\t}\n}\n\n/**\n * Computes the referenced properties of a LineItem in case the LineItem is annotated as hidden.\n * @param existingColumns The list of columns created from LineItems and from properties of entityType\n * @param name The name of the property to be evaluated\n * @param column The given column from lineItem or property of entitySet\n */\nfunction computeHiddenOnRelatedColumns(existingColumns: AnnotationTableColumn[], name: string, column: AnnotationTableColumn): void {\n\tconst relatedAnnotationColumns = existingColumns.filter(\n\t\t(existingColumn) =>\n\t\t\t(existingColumn.propertyInfos?.includes(name) && existingColumn.isPartOfLineItem) ||\n\t\t\t(existingColumn.isPartOfLineItem && existingColumn.relativePath === column.relativePath)\n\t);\n\tcolumn.isPartOfLineItem = !!relatedAnnotationColumns.length;\n\tif (\n\t\trelatedAnnotationColumns.length &&\n\t\t!relatedAnnotationColumns?.some((annotationColumn) => annotationColumn.availability !== \"Hidden\")\n\t) {\n\t\tcolumn.sortable = false;\n\t\tcolumn.isGroupable = false;\n\t\tcolumn.filterable = false;\n\t}\n}\n\n/**\n * Gets the export settings properties of a manifest column.\n * @param exportSettings The customized/overwritten export settings of a manifest column\n * @param annotationColumns The list of columns created from LineItems\n * @param converterContext The converter context\n * @param entityType The target entity type\n * @param propertyInfos The properties linked to a complex column\n * @param columnKey The column key of the column to be overwritten\n * @returns The export settings of the column merging customized export settings with the default values detected on the annotation column\n */\nfunction getCustomExportSettings(\n\texportSettings: ColumnExportSettings | undefined,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType,\n\tpropertyInfos?: string[],\n\tcolumnKey?: string\n): ColumnExportSettings | null {\n\tlet columnFromAnnotations;\n\tif (columnKey) {\n\t\tcolumnFromAnnotations = annotationColumns.find((annotationColumn) => annotationColumn.key === columnKey);\n\t\tif (columnFromAnnotations?.exportSettings === null) {\n\t\t\treturn columnFromAnnotations?.exportSettings;\n\t\t}\n\t}\n\tconst enableWrapping =\n\t\texportSettings?.wrap ??\n\t\t(!!(exportSettings?.property && exportSettings.property?.length > 1) || !!(propertyInfos && propertyInfos.length > 1));\n\tconst customExportSettings: ColumnExportSettings = {\n\t\t...columnFromAnnotations?.exportSettings,\n\t\ttype: exportSettings?.type ?? columnFromAnnotations?.exportSettings?.type,\n\t\ttemplate:\n\t\t\texportSettings?.template ??\n\t\t\t_appendCustomTemplate(propertyInfos, exportSettings?.property) ??\n\t\t\tcolumnFromAnnotations?.exportSettings?.template,\n\t\tproperty: exportSettings?.property\n\t\t\t? _getPropertyNames(exportSettings?.property, annotationColumns, converterContext, entityType)\n\t\t\t: undefined,\n\t\twidth: exportSettings?.width,\n\t\twrap: enableWrapping\n\t};\n\treturn removeUndefinedFromExportSettings(customExportSettings);\n}\n"],"mappings":"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","ignoreList":[]}