{"version":3,"file":"AdditionalValueHelper.js","names":["AdditionalValueGroupKey","_exports","additionalValueHelper","requestForAdditionalValueContextData","async","additionalValues","valueHelpListBinding","valueHelpBindingInfo","payload","sorters","field","allListBinding","additionalValueContextPromise","reverseRecommendationValues","filter","value","groupKey","recommendation","reverse","parameters","$select","qualifiers","valueHelpQualifier","vhProperties","searchTerm","$search","isValueListWithFixedValues","$count","listSorters","forEach","sorter","push","Sorter","name","descending","valueHelpListModel","getModel","additionalValueListBindings","this","getAdditionalValueContextBindings","length","requestContexts","submitBatch","additionalValuesContext","Promise","all","count","getCount","getBindingContext","setProperty","recommendationContexts","allContexts","recommendationValuesContextData","map","context","getObject","othersValuesContextData","additionalValueContextBindings","valueHelpFilters","getValueHelpBindingFilters","recommendationValueFilters","getAdditionalValueFilters","bindList","path","undefined","filters","Array","isArray","resumeValueListBindingAndResetChanges","isSuspended","resumeAsync","resetChanges","error","sortAndFilterListBinding","Filter","NONE","FilterType","Application","modifiedSorters","getSorterFunction","sort","reverseAdditionalValues","additionalValue","values","propertyPath","value1","operator","resourceBundle","Library","getResourceBundleFor","getProperty","getText","recentValue","createTransientContextsForAdditionalValueContextData","recentValuesContextData","createGroupedTransientContexts","other","additionalValueContextData","contextData","create","created","canceled","Log","getRelevantRecommendations","data","bindingContext","bindingPath","relevantRecommendations","Object","keys","getRecommendationPropertyPath","version","getAdditionalValueFromPropertyPath","valueData","_checkForKeysInRecommendations","keyProperties","key","getAdditionalValueFromKeys","recommendationData","result","recData","allKeysMatch","_getRecommendation","oldData","assign","includes","propertyPaths","split","navPropPath","splice","join","standardRecommendationHelper","getStandardRecommendations","getRelevantOthersValuesContextData","valueHelpKeys","checkValuesMatch","getRelevantRecentValuesContextData","bindingInfo","recentValuesModel","JSONModel","recentValuesList","getAllCurrentContexts","recentValueContextData","filterRecentValuesContextData","contextDataToBeMatched","contextDataList","obj","match","getRelevantRecommendationValuesContextData","recommendationValues","arguments","valueListProperty","relevantRecommendationValuesContextData","foundObject","find","updateFinished","event","source","getSource","tableBindingContext","actual","total","reason","getParameters","paginationData","additionalData","getBinding"],"sources":["./AdditionalValueHelper.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type {\n\tInCompletenessInfoType,\n\tInternalPropertyAdditionalValue,\n\tKeyPropertiesDataType,\n\tRecommendationDataForNavPropertyType,\n\tRecommendationValueType\n} from \"sap/fe/core/helpers/RecommendationHelper\";\nimport type { RecommendationInfo, StandardRecommendationDataType } from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport { standardRecommendationHelper } from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport type { FieldDataType } from \"sap/fe/core/services/ValueHelpHistoryServiceFactory\";\nimport type { SorterType, ValueHelpPayload } from \"sap/fe/macros/internal/valuehelp/ValueListHelper\";\nimport type UI5Event from \"sap/ui/base/Event\";\nimport type EventProvider from \"sap/ui/base/EventProvider\";\nimport type { BaseAggregationBindingInfo } from \"sap/ui/base/ManagedObject\";\nimport Library from \"sap/ui/core/Lib\";\nimport type Field from \"sap/ui/mdc/Field\";\nimport type FilterField from \"sap/ui/mdc/FilterField\";\nimport type MultiValueField from \"sap/ui/mdc/MultiValueField\";\nimport type MTable from \"sap/ui/mdc/valuehelp/content/MTable\";\nimport type Context from \"sap/ui/model/Context\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterType from \"sap/ui/model/FilterType\";\nimport Sorter from \"sap/ui/model/Sorter\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type V4Context from \"sap/ui/model/odata/v4/Context\";\nimport type { ContextErrorType } from \"sap/ui/model/odata/v4/Context\";\nimport type ODataListBinding from \"sap/ui/model/odata/v4/ODataListBinding\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\n\nenum AdditionalValueGroupKey {\n\trecommendation = \"recommendation\",\n\trecentValue = \"recentValue\",\n\tother = \"other\"\n}\nexport type AdditionalValueType = {\n\tpropertyPath: string;\n\tvalues: (string | number | boolean)[];\n\tgroupKey: AdditionalValueGroupKey; // unique identifier for the group\n};\nexport type BindingInfoParameters = {\n\t$select: string[];\n\t$expand?: string[];\n\t$search: string;\n\t$count: boolean;\n};\n\nexport type AdditionValueDefinition =\n\t| InCompletenessInfoType\n\t| RecommendationDataForNavPropertyType[]\n\t| InternalPropertyAdditionalValue\n\t| object;\nconst additionalValueHelper = {\n\t/**\n\t * This function is responsible to create context based on additional value filters and custom sorter and request contexts from it.\n\t * @param additionalValues Array of additional values\n\t * @param valueHelpListBinding List binding\n\t * @param valueHelpBindingInfo The binding info object to be used to bind the list to the model\n\t * @param payload Payload of the value help\n\t * @param sorters Sorters of the value help list binding\n\t * @param field\tField for which the value help is requested\n\t * @returns Additional value contexts\n\t */\n\trequestForAdditionalValueContextData: async function (\n\t\tadditionalValues: AdditionalValueType[],\n\t\tvalueHelpListBinding: ODataListBinding,\n\t\tvalueHelpBindingInfo: BaseAggregationBindingInfo,\n\t\tpayload: ValueHelpPayload,\n\t\tsorters: SorterType[],\n\t\tfield: FilterField | MultiValueField | Field\n\t): Promise<{\n\t\trecommendationValuesContextData: FieldDataType[];\n\t\tothersValuesContextData: FieldDataType[];\n\t}> {\n\t\tlet allListBinding: ODataListBinding | undefined;\n\t\tconst additionalValueContextPromise: Promise<V4Context[]>[] = [];\n\t\t// reverse the array so that while creating transient context first additional value is grouped first\n\t\tconst reverseRecommendationValues = [\n\t\t\t...additionalValues.filter((value) => value.groupKey === AdditionalValueGroupKey.recommendation)\n\t\t].reverse();\n\n\t\t// logic to add $select for multi-level navigation properties as filling $select is sufficient for the model to create the expand calls\n\t\t(valueHelpBindingInfo.parameters as BindingInfoParameters).$select =\n\t\t\tpayload.qualifiers[payload.valueHelpQualifier].vhProperties ?? [];\n\n\t\t// check if there is any input in the field\n\t\t// This information is used to determine to show the \"others\" section or not\n\t\t// and also to determine if typeAhead should open or not\n\t\tconst searchTerm = (valueHelpBindingInfo.parameters as BindingInfoParameters).$search;\n\t\t(valueHelpBindingInfo.parameters as BindingInfoParameters).$search = searchTerm;\n\t\tif (payload.isValueListWithFixedValues) {\n\t\t\t(valueHelpBindingInfo.parameters as BindingInfoParameters).$count = true;\n\t\t}\n\t\tconst listSorters: Sorter[] = [];\n\t\tsorters.forEach((sorter: SorterType) => listSorters.push(new Sorter(sorter.name ?? \"\", sorter.descending)));\n\t\tconst valueHelpListModel: ODataModel = valueHelpListBinding.getModel() as ODataModel;\n\t\t// get the list binding for recommendation values and others values\n\t\tconst additionalValueListBindings: ODataListBinding[] = this.getAdditionalValueContextBindings(\n\t\t\treverseRecommendationValues,\n\t\t\tsearchTerm,\n\t\t\tpayload,\n\t\t\tvalueHelpListModel,\n\t\t\tvalueHelpBindingInfo,\n\t\t\tlistSorters\n\t\t);\n\t\tif (additionalValueListBindings.length > 0) {\n\t\t\tif (additionalValueListBindings.length === 2) {\n\t\t\t\tadditionalValueContextPromise.push(additionalValueListBindings[0].requestContexts(0, 10, \"additionalValue\"));\n\t\t\t\tallListBinding = additionalValueListBindings[1];\n\t\t\t} else {\n\t\t\t\tallListBinding = additionalValueListBindings[0];\n\t\t\t}\n\t\t\t// in case of dropdown, we fetch first 100 records on first load and then make subsequent requests upon user's scroll.\n\t\t\tadditionalValueContextPromise.push(\n\t\t\t\tallListBinding.requestContexts(0, payload.isValueListWithFixedValues ? 100 : 10, \"additionalValue\")\n\t\t\t);\n\t\t}\n\t\tawait valueHelpListModel.submitBatch(\"additionalValue\");\n\t\tconst additionalValuesContext = await Promise.all(additionalValueContextPromise);\n\t\t// we store this list bindings in order to be able to make subsequent requests on user's scroll\n\t\tconst count = allListBinding?.getCount();\n\t\tif (count && count > 100) {\n\t\t\tfield.getBindingContext(\"internal\")?.setProperty(\"allListBinding\", allListBinding);\n\t\t}\n\t\tlet recommendationContexts: V4Context[] = [],\n\t\t\tallContexts: V4Context[] = [];\n\t\tif (reverseRecommendationValues.length > 0) {\n\t\t\trecommendationContexts = additionalValuesContext[0];\n\t\t\tif (searchTerm || payload.isValueListWithFixedValues) {\n\t\t\t\tallContexts = additionalValuesContext[1];\n\t\t\t}\n\t\t} else if (searchTerm || payload.isValueListWithFixedValues) {\n\t\t\tallContexts = additionalValuesContext[0];\n\t\t}\n\n\t\tconst recommendationValuesContextData = recommendationContexts.map((context) => context.getObject() as FieldDataType);\n\t\tconst othersValuesContextData: FieldDataType[] = allContexts.map((context) => context.getObject() as FieldDataType);\n\n\t\treturn {\n\t\t\trecommendationValuesContextData,\n\t\t\tothersValuesContextData\n\t\t};\n\t},\n\t/**\n\t * Method to retrieve all relevant list bindings (recommendation and others) that is needed to make a backend call.\n\t * @param reverseRecommendationValues Reversed recommendation values\n\t * @param searchTerm Search term entered by the user\n\t * @param payload Payload of the value help\n\t * @param valueHelpListModel Model of the value help\n\t * @param valueHelpBindingInfo Binding info of the value help\n\t * @param sorter Custom sorter which needs to be applied to the list binding\n\t * @returns All the list binding which would be used to trigger calls to the backend.\n\t */\n\tgetAdditionalValueContextBindings: function (\n\t\treverseRecommendationValues: AdditionalValueType[],\n\t\tsearchTerm: string,\n\t\tpayload: ValueHelpPayload,\n\t\tvalueHelpListModel: ODataModel,\n\t\tvalueHelpBindingInfo: BaseAggregationBindingInfo,\n\t\tsorter: Sorter[]\n\t): ODataListBinding[] {\n\t\tconst additionalValueContextBindings: ODataListBinding[] = [];\n\t\tconst valueHelpFilters: Filter[] = [...this.getValueHelpBindingFilters(valueHelpBindingInfo)];\n\t\tconst recommendationValueFilters = this.getAdditionalValueFilters(reverseRecommendationValues, [...valueHelpFilters]);\n\n\t\tif (reverseRecommendationValues.length > 0) {\n\t\t\t// binding represent recommendation list binding.\n\t\t\tadditionalValueContextBindings.push(\n\t\t\t\tvalueHelpListModel.bindList(\n\t\t\t\t\tvalueHelpBindingInfo.path,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\trecommendationValueFilters,\n\t\t\t\t\tvalueHelpBindingInfo.parameters\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (searchTerm || payload.isValueListWithFixedValues) {\n\t\t\t// binding represent all data list bindings.\n\t\t\tadditionalValueContextBindings.push(\n\t\t\t\tvalueHelpListModel.bindList(valueHelpBindingInfo.path, undefined, sorter, valueHelpFilters, valueHelpBindingInfo.parameters)\n\t\t\t);\n\t\t}\n\n\t\treturn additionalValueContextBindings;\n\t},\n\t/**\n\t * This function is responsible to fetch the valuehelp binding filters.\n\t * @param valueHelpBindingInfo The binding info object to be used to bind the list to the model\n\t * @returns Filters of valuehelp binding\n\t */\n\tgetValueHelpBindingFilters: function (valueHelpBindingInfo: BaseAggregationBindingInfo): Filter[] {\n\t\t// get all existing filters from the binding info\n\t\t// this + additional value filters will be used later on to fetch additional values from the backend\n\t\tif (valueHelpBindingInfo.filters) {\n\t\t\tif (Array.isArray(valueHelpBindingInfo.filters)) {\n\t\t\t\treturn valueHelpBindingInfo.filters;\n\t\t\t} else {\n\t\t\t\treturn [valueHelpBindingInfo.filters];\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t},\n\t/**\n\t * This function resumes the suspended list binding and then resets changes on it.\n\t * @param valueHelpListBinding List binding\n\t */\n\tresumeValueListBindingAndResetChanges: async function (valueHelpListBinding: ODataListBinding): Promise<void> {\n\t\tif (valueHelpListBinding.isSuspended()) {\n\t\t\tawait valueHelpListBinding.resumeAsync();\n\t\t}\n\t\t// get rid of existing transient contexts.\n\n\t\t// destroying causes issues sometimes, contexts are not always available to destroy but appear afterwards magically\n\t\ttry {\n\t\t\tawait valueHelpListBinding.resetChanges();\n\t\t} catch (error: unknown) {\n\t\t\t//We do not do anything here as we know the model will always throw an error and this will fill up the console with errors.\n\t\t}\n\t},\n\t/**\n\t * This function is used for sorting and filtering the list binding.\n\t * @param valueHelpListBinding List Binding\n\t * @param sorters Sorters of the value help list binding\n\t */\n\tsortAndFilterListBinding: function (valueHelpListBinding: ODataListBinding, sorters: SorterType[]): void {\n\t\t// In order to not show the list at all, we pass an empty filter which would render an empty list\n\t\tvalueHelpListBinding.filter(Filter.NONE, FilterType.Application);\n\n\t\tif (sorters.length) {\n\t\t\tconst modifiedSorters: Sorter[] = [];\n\t\t\tsorters.forEach((sorter: SorterType) =>\n\t\t\t\tmodifiedSorters.push(new Sorter(sorter.name ?? \"\", sorter.descending, this.getSorterFunction))\n\t\t\t);\n\t\t\tvalueHelpListBinding.sort(modifiedSorters);\n\t\t} else valueHelpListBinding.sort(new Sorter(\"\", false, this.getSorterFunction));\n\t},\n\t/**\n\t * This functions creates the filters for additional values.\n\t * @param reverseAdditionalValues Array of additional values in reverse order\n\t * @param filters Existing valuehelp binding filters\n\t * @returns Additional value filters\n\t */\n\tgetAdditionalValueFilters: function (reverseAdditionalValues: AdditionalValueType[], filters: Filter[]): Filter[] {\n\t\treverseAdditionalValues.forEach((additionalValue) => {\n\t\t\tif (additionalValue.values.length > 0) {\n\t\t\t\tconst values = additionalValue.values;\n\t\t\t\tconst propertyPath = additionalValue.propertyPath;\n\t\t\t\t// add additional value filters to existing filters from the binding info\n\t\t\t\tvalues.forEach((value) => {\n\t\t\t\t\t// update the value help binding info to get additional values from the backend\n\t\t\t\t\tfilters.push(\n\t\t\t\t\t\tnew Filter({\n\t\t\t\t\t\t\tpath: propertyPath,\n\t\t\t\t\t\t\tvalue1: value,\n\t\t\t\t\t\t\toperator: \"EQ\"\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn filters;\n\t},\n\t/**\n\t * This function is a callback to the custom sorter.\n\t * @param context Context of the Field\n\t * @returns Group key that can be used for sorting\n\t */\n\tgetSorterFunction: function (context: V4Context): string {\n\t\t//eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.macros\")!;\n\t\t//get the client side annotation to figure out the group key\n\t\tconst groupKey = context.getProperty(\"@$fe.additionalValueGroupKey\") as AdditionalValueGroupKey;\n\t\tif (groupKey === AdditionalValueGroupKey.recommendation) {\n\t\t\treturn resourceBundle.getText(\"M_ADDITIONALVALUEHELPER_RECOMMENDATIONS\");\n\t\t} else if (groupKey === AdditionalValueGroupKey.recentValue) {\n\t\t\treturn resourceBundle.getText(\"M_ADDITIONALVALUEHELPER_RECENTVALUE\");\n\t\t} else {\n\t\t\treturn resourceBundle.getText(\"M_ADDITIONALVALUEHELPER_OTHERS\");\n\t\t}\n\t},\n\t/**\n\t * Method to create transient contexts of the value help list binding for the given different types additional value context data.\n\t * @param recommendationValuesContextData Recommendation values context data\n\t * @param recentValuesContextData Recent values context data\n\t * @param othersValuesContextData Other values context data\n\t * @param valueHelpListBinding List binding\n\t */\n\tcreateTransientContextsForAdditionalValueContextData: function (\n\t\trecommendationValuesContextData: FieldDataType[],\n\t\trecentValuesContextData: FieldDataType[],\n\t\tothersValuesContextData: FieldDataType[],\n\t\tvalueHelpListBinding: ODataListBinding\n\t): void {\n\t\tthis.createGroupedTransientContexts(othersValuesContextData, valueHelpListBinding, AdditionalValueGroupKey.other);\n\t\tthis.createGroupedTransientContexts(recentValuesContextData, valueHelpListBinding, AdditionalValueGroupKey.recentValue);\n\t\tthis.createGroupedTransientContexts(recommendationValuesContextData, valueHelpListBinding, AdditionalValueGroupKey.recommendation);\n\t},\n\t/**\n\t * Method to create transient context for the given additional value context data. It also adds a key for each context which is used to group the newly created transient contexts accordingly.\n\t * @param additionalValueContextData Additional value context data\n\t * @param valueHelpListBinding List binding\n\t * @param groupKey Key which indicates the group of the additional value context data\n\t */\n\tcreateGroupedTransientContexts: function (\n\t\tadditionalValueContextData: FieldDataType[],\n\t\tvalueHelpListBinding: ODataListBinding,\n\t\tgroupKey: AdditionalValueGroupKey\n\t): void {\n\t\t// reverse of the context data is required so that the context which needs to be shown below in the list gets created first\n\t\t[...additionalValueContextData].reverse().forEach(async (contextData: FieldDataType) => {\n\t\t\t// groupKey is added in order to properly group the transient contexts amongst all 3 groups\n\t\t\tcontextData[\"@$fe.additionalValueGroupKey\"] = groupKey;\n\t\t\tconst context = valueHelpListBinding.create(contextData);\n\t\t\ttry {\n\t\t\t\tawait context.created();\n\t\t\t} catch (error) {\n\t\t\t\t// For transient contexts the canceled is set to true and for other cases it will be false. Atleast in recommendations\n\t\t\t\t// use case we do not face the scenario where canceled is set to false. For now we are just logging the error.\n\t\t\t\tif (!(error as ContextErrorType).canceled) {\n\t\t\t\t\tLog.error((error as ContextErrorType).name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * This functions returns the relevant recommendations for the valuelist.\n\t * @param data Object containing recommendation model data\n\t * @param bindingContext Binding context of the Field\n\t * @param propertyPath Property Path of the Field\n\t * @param bindingPath\n\t * @returns Relevant recommendations for the valuelist\n\t */\n\tgetRelevantRecommendations: function (\n\t\tdata: InCompletenessInfoType | object,\n\t\tbindingContext: V4Context,\n\t\tpropertyPath: string,\n\t\tbindingPath?: string\n\t): Array<string | number> | null | undefined {\n\t\tconst values: Array<string | number> = [];\n\t\tlet relevantRecommendations: InternalPropertyAdditionalValue | undefined;\n\t\tif (Object.keys(data).length > 0) {\n\t\t\t//get the right property path by eliminating the starting / and also main entityset name\n\t\t\tpropertyPath = this.getRecommendationPropertyPath(propertyPath);\n\t\t\tif ((data as RecommendationInfo).version === 2.0 && bindingPath) {\n\t\t\t\tpropertyPath = bindingPath;\n\t\t\t}\n\t\t\t//get the recommendations based on property path and binding context passed\n\t\t\trelevantRecommendations = this.getAdditionalValueFromPropertyPath(propertyPath, bindingContext, data) as\n\t\t\t\t| InternalPropertyAdditionalValue\n\t\t\t\t| undefined;\n\t\t\t//if we get recommendations then push the values\n\t\t\tif (relevantRecommendations && Object.keys(relevantRecommendations).length > 0) {\n\t\t\t\trelevantRecommendations.additionalValues.forEach((valueData: RecommendationValueType) => {\n\t\t\t\t\tvalues.push(valueData.value);\n\t\t\t\t});\n\t\t\t\treturn values;\n\t\t\t} else {\n\t\t\t\t//if recommendations are not found then return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\n\t_checkForKeysInRecommendations: function (keyProperties: KeyPropertiesDataType, contextData: Record<string, string>): boolean {\n\t\tfor (const key in keyProperties) {\n\t\t\tif (keyProperties[key] !== contextData[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\t/**\n\t * This function is responsible to fetch the exact object from an array of objects that contains relevant recommendationData based on keys.\n\t * @param recommendationData Array containing additional values\n\t * @param bindingContext Binding context of the Field\n\t * @returns Relevant object from an array of object that contains the additional value\n\t */\n\tgetAdditionalValueFromKeys: function (\n\t\trecommendationData: AdditionValueDefinition,\n\t\tbindingContext?: V4Context | Context\n\t): AdditionValueDefinition {\n\t\tconst contextData = bindingContext?.getObject() as Record<string, string> | undefined;\n\t\tlet result: AdditionValueDefinition = {};\n\t\t//loop through the recommendationData and check if the keyProperties match with the binding context data\n\t\tif (bindingContext && contextData) {\n\t\t\tif (Array.isArray(recommendationData)) {\n\t\t\t\t(recommendationData as RecommendationDataForNavPropertyType[]).forEach((recData) => {\n\t\t\t\t\tconst keyProperties = recData.keyProperties as KeyPropertiesDataType;\n\t\t\t\t\tconst allKeysMatch = this._checkForKeysInRecommendations(keyProperties, contextData);\n\t\t\t\t\t//if every key value matches with the binding context data then assign it to result which will be returned\n\t\t\t\t\tif (allKeysMatch) {\n\t\t\t\t\t\tresult = recData as AdditionValueDefinition;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t_getRecommendation: function (\n\t\tpropertyPath: string,\n\t\tbindingContext: Context,\n\t\trecommendationData: AdditionValueDefinition\n\t): AdditionValueDefinition {\n\t\t//create a copy of the recommendationData to store its previous value as it will change because of the recursive approach\n\t\tlet oldData = Object.assign(recommendationData, {});\n\t\t//check if property path exists on the recommendationData object and if so then return the object pointing to the property path\n\t\tif (Object.keys(recommendationData).includes(propertyPath)) {\n\t\t\treturn (recommendationData as InCompletenessInfoType)[propertyPath] as AdditionValueDefinition;\n\t\t} else {\n\t\t\t//if property path is not present then check if it is 1:n mapping and we need to do a recursive approach to land on the exact object containing the relevant recommendations\n\t\t\t//continue the while loop till the property path is found in the previous recommendationData\n\t\t\twhile (Object.keys(oldData).length > 0 && !Object.keys(oldData).includes(propertyPath)) {\n\t\t\t\t// as it might be 1:n mapping so first seperate the navprop name and actual prop name to make sure we find the navprop first and then from its pointing object we find the property path\n\t\t\t\t//eg: _Item/Material will be first divided into _Item and we search for it and then from its relevant object we search for Material\n\t\t\t\tconst propertyPaths = propertyPath.split(\"/\");\n\t\t\t\tif (propertyPaths.length > 1) {\n\t\t\t\t\t//getting the navprop path\n\t\t\t\t\tconst navPropPath = propertyPaths[0];\n\t\t\t\t\t//removing the navprop path from propertypaths so that we only check for actual property path\n\t\t\t\t\tpropertyPaths.splice(0, 1);\n\t\t\t\t\tpropertyPath = propertyPaths.join(\"/\");\n\t\t\t\t\t//using getAdditionalValueFromPropertyPath and passing navPropPath we get the exact array of objects pointing to the navProp\n\t\t\t\t\trecommendationData = this.getAdditionalValueFromPropertyPath(\n\t\t\t\t\t\tnavPropPath,\n\t\t\t\t\t\tbindingContext,\n\t\t\t\t\t\trecommendationData\n\t\t\t\t\t) as RecommendationDataForNavPropertyType[];\n\t\t\t\t\t//no pass the array of objects of navProp to getAdditionalValueFromKeys and get the exact object that contains the recommendationData based on keys\n\t\t\t\t\trecommendationData = this.getAdditionalValueFromKeys(recommendationData, bindingContext);\n\t\t\t\t\tif (Object.keys(recommendationData).length > 0) {\n\t\t\t\t\t\t//set the recommendationData to oldData before assigning the new value to it\n\t\t\t\t\t\toldData = Object.assign(recommendationData, {});\n\t\t\t\t\t\t//here we check for the actual property path from the object we found from getAdditionalValueFromKeys\n\t\t\t\t\t\t//eg: Material can be found in the object which is part of array of objects of _Item\n\t\t\t\t\t\trecommendationData = this.getAdditionalValueFromPropertyPath(\n\t\t\t\t\t\t\tpropertyPath,\n\t\t\t\t\t\t\tbindingContext,\n\t\t\t\t\t\t\trecommendationData\n\t\t\t\t\t\t) as AdditionValueDefinition;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn recommendationData;\n\t\t}\n\t},\n\n\t/**\n\t * This function is responsible for getting the additional value based on property path and binding context passed.\n\t * @param propertyPath Property path of the field\n\t * @param bindingContext Binding context of the field\n\t * @param recommendationData Object containing additional value\n\t * @returns Additional value based on property path and binding context passed\n\t */\n\tgetAdditionalValueFromPropertyPath: function (\n\t\tpropertyPath: string,\n\t\tbindingContext: V4Context | Context,\n\t\trecommendationData?: AdditionValueDefinition | RecommendationInfo\n\t): AdditionValueDefinition | StandardRecommendationDataType | undefined {\n\t\tif ((recommendationData as RecommendationInfo).version === 2) {\n\t\t\treturn standardRecommendationHelper.getStandardRecommendations(\n\t\t\t\tbindingContext,\n\t\t\t\tpropertyPath,\n\t\t\t\trecommendationData as RecommendationInfo\n\t\t\t);\n\t\t}\n\t\tif (recommendationData) {\n\t\t\treturn this._getRecommendation(propertyPath, bindingContext, recommendationData);\n\t\t}\n\t},\n\t/**\n\t * This function returns the property path of the field by removing the leading '/' and main entity set name.\n\t * @param propertyPath Property Path of the Field\n\t * @returns Property path of the field by removing the leading '/' and main entity set name.\n\t */\n\tgetRecommendationPropertyPath: function (propertyPath: string): string {\n\t\t//First we split the property path based on /\n\t\tconst propertyPaths = propertyPath.split(\"/\");\n\t\t//Now remove the first two elements of the array. As first element will always be '' and second element will be main entity set name\n\t\tpropertyPaths.splice(0, 2);\n\t\t//Now join the remaining elements to create a new property path and return it\n\t\treturn propertyPaths.join(\"/\");\n\t},\n\t/**\n\t * Method to filter Others values context data and remove values which are also present in Recently Used and Recommendation group.\n\t * @param recommendationValuesContextData Recommendation values context data\n\t * @param recentValuesContextData Recent values context data\n\t * @param othersValuesContextData Others values context data\n\t * @param valueHelpKeys ValueListProperty of the payload\n\t * @returns Others values context data.\n\t */\n\tgetRelevantOthersValuesContextData: function (\n\t\trecommendationValuesContextData: FieldDataType[],\n\t\trecentValuesContextData: FieldDataType[],\n\t\tothersValuesContextData: FieldDataType[],\n\t\tvalueHelpKeys: string[]\n\t): FieldDataType[] {\n\t\treturn othersValuesContextData.filter(\n\t\t\t(contextData) =>\n\t\t\t\t!this.checkValuesMatch(contextData, recommendationValuesContextData, valueHelpKeys) &&\n\t\t\t\t!this.checkValuesMatch(contextData, recentValuesContextData, valueHelpKeys)\n\t\t);\n\t},\n\t/**\n\t * Method to check whether recent values matches either with the search term or with the others values.\n\t * @param othersValuesContextData Others values context data\n\t * @param recentValuesContextData Recent values context data\n\t * @param valueHelpKeys ValueListProperty of the payload\n\t * @param searchTerm Search term entered by the user\n\t * @param bindingInfo Binding info object of the value help\n\t * @returns Recent values context data which needs to be show in the Recently Used group in the type ahead suggestion list.\n\t */\n\tgetRelevantRecentValuesContextData: function (\n\t\tothersValuesContextData: FieldDataType[],\n\t\trecentValuesContextData: FieldDataType[],\n\t\tvalueHelpKeys: string[],\n\t\tsearchTerm: string,\n\t\tbindingInfo: BaseAggregationBindingInfo\n\t): FieldDataType[] {\n\t\t// filter out recent value based on existing value help filters\n\t\tconst recentValuesModel = new JSONModel({ recentValuesContextData });\n\t\tconst recentValuesList = recentValuesModel.bindList(\n\t\t\t\"/recentValuesContextData\",\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tthis.getValueHelpBindingFilters(bindingInfo)\n\t\t);\n\t\trecentValuesContextData = recentValuesList.getAllCurrentContexts().map((context) => context.getObject() as FieldDataType);\n\n\t\t// consider only those recent values which either matches with the search term or with the response received from backend for the Others group.\n\t\t// Both the filters needs to be applied so that so that order of the recent values does not change, which is important for the order in which\n\t\t// the data would be shown in the type ahead suggestion list.\n\t\treturn recentValuesContextData.filter((recentValueContextData) =>\n\t\t\tthis.filterRecentValuesContextData(recentValueContextData, searchTerm, valueHelpKeys, othersValuesContextData)\n\t\t);\n\t},\n\t/**\n\t * Method to check whether the given recent value context data matches with the given search term or the others values.\n\t * @param recentValueContextData Recent values context data\n\t * @param searchTerm Search term entered by the user\n\t * @param valueHelpKeys ValueListProperty of the payload\n\t * @param othersValuesContextData Others values context data\n\t * @returns True if the given recent value context satisfies the filter condition.\n\t */\n\tfilterRecentValuesContextData: function (\n\t\trecentValueContextData: FieldDataType,\n\t\tsearchTerm: string,\n\t\tvalueHelpKeys: string[],\n\t\tothersValuesContextData: FieldDataType[]\n\t): boolean {\n\t\tfor (const key in recentValueContextData) {\n\t\t\tif (typeof recentValueContextData[key] === \"object\") {\n\t\t\t\tif (\n\t\t\t\t\tthis.filterRecentValuesContextData(\n\t\t\t\t\t\trecentValueContextData[key] as FieldDataType,\n\t\t\t\t\t\tsearchTerm,\n\t\t\t\t\t\tvalueHelpKeys,\n\t\t\t\t\t\tothersValuesContextData\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (typeof recentValueContextData[key] === \"string\") {\n\t\t\t\tif (\n\t\t\t\t\t(!searchTerm && othersValuesContextData.length === 0) || // Case where focus is just set to the value help field\n\t\t\t\t\t(recentValueContextData[key] as string).includes(searchTerm) ||\n\t\t\t\t\t(valueHelpKeys.includes(key) && this.checkValuesMatch(recentValueContextData, othersValuesContextData, valueHelpKeys))\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\t/**\n\t * Checks if the values of specified keys in contextDataToBeMatched match with any object in contextDataList.\n\t * @param contextDataToBeMatched The context data object to compare\n\t * @param contextDataList The array of context data objects to compare against\n\t * @param valueHelpKeys The keys to compare from contextDataToBeMatched with contextDataList objects\n\t * @returns Returns true if any object in contextDataList matches the values of the specified keys in contextDataToBeMatched, otherwise false.\n\t */\n\tcheckValuesMatch: function (contextDataToBeMatched: FieldDataType, contextDataList: FieldDataType[], valueHelpKeys: string[]): boolean {\n\t\tfor (const obj of contextDataList) {\n\t\t\tlet match = true;\n\t\t\tfor (const key of valueHelpKeys) {\n\t\t\t\t// Check if the value of the key in recentValuesContextData\n\t\t\t\t// matches the value of the key in the current object from othersValuesContextData\n\t\t\t\tif (contextDataToBeMatched[key] !== obj[key]) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\t/**\n\t * Method to rearrange the given additional value context data as per the chronological order of the given additional values.\n\t * This is to ensure that the recommendation data fetched from backend are shown in the same order of recommendation values fetched from recommendation service.\n\t * @param recommendationValuesContextData Recommendation values context data\n\t * @param recommendationValues Recommendation values\n\t * @param valueListProperty Value list property of the value help\n\t * @returns Recommendation values context data in the correct order.\n\t */\n\tgetRelevantRecommendationValuesContextData: function (\n\t\trecommendationValuesContextData: FieldDataType[],\n\t\trecommendationValues: (string | number | boolean)[] = [],\n\t\tvalueListProperty: string\n\t): FieldDataType[] {\n\t\tconst relevantRecommendationValuesContextData: FieldDataType[] = [];\n\t\trecommendationValues.forEach((value) => {\n\t\t\tconst foundObject = recommendationValuesContextData.find((contextData) => contextData[valueListProperty] === value);\n\t\t\tif (foundObject) {\n\t\t\t\trelevantRecommendationValuesContextData.push(foundObject);\n\t\t\t}\n\t\t});\n\n\t\treturn relevantRecommendationValuesContextData;\n\t},\n\t/**\n\t * Method to make batch calls to support pagination.\n\t * This is to ensure that the additional data fetched from the backend is displayed in the correct order.\n\t * @param event An event object that consists of an ID, source, and a parameter map.\n\t */\n\tupdateFinished: async function name(event: UI5Event): Promise<void> {\n\t\tconst source = event.getSource() as { source?: EventProvider } as MTable;\n\t\tconst tableBindingContext: Context | undefined | null = source.getBindingContext(\"internal\"),\n\t\t\tallListBinding = tableBindingContext?.getProperty(\"allListBinding\") as ODataListBinding | undefined;\n\t\tconst { actual, total, reason } = event.getParameters() as { actual: number; total: number; reason: string };\n\t\t// as user scrolls down and once we reach end of the list, we fetch the next set of data from the backend\n\t\tif (allListBinding && reason === \"Growing\" && actual === total) {\n\t\t\tconst paginationData = await allListBinding.requestContexts(total, 100),\n\t\t\t\tadditionalData = paginationData.map((data: V4Context) => data.getObject() as FieldDataType);\n\t\t\tadditionalData.forEach(async (contextData: FieldDataType) => {\n\t\t\t\tconst context = (source.getBinding(\"items\") as ODataListBinding).create(contextData, undefined, true);\n\t\t\t\ttry {\n\t\t\t\t\tawait context.created();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tLog.error((error as ContextErrorType).name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\nexport { AdditionalValueGroupKey, RecommendationValueType, additionalValueHelper };\n"],"mappings":"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","ignoreList":[]}