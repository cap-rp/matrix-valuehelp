{"version":3,"file":"CommonHelper.js","names":["_getRestrictions","aDefaultOps","aExpressionOps","filter","sElement","includes","_getDefaultOperators","sPropertyType","oDataClass","TypeMap","getDataTypeClassName","oBaseType","getBaseType","FilterOperatorUtil","getOperatorsForType","ValueColor","mLibrary","CommonHelper","getPathToKey","oCtx","getObject","getParameterEditMode","target","oInterface","oModel","context","getModel","sPropertyPath","getPath","oAnnotations","fieldControl","immutable","computed","sEditMode","FieldEditMode","Editable","ReadOnly","$EnumMember","Disabled","$Path","getMetaPath","undefined","getMetaModelId","convertTypes","getId","isDesktop","Device","system","desktop","getTargetCollectionPath","navCollection","sPath","model","metaModel","isA","getMetaModel","aParts","split","sPart","entitySet","length","navigationCollection","slice","join","isPropertyFilterable","oDataField","skipHiddenFilters","sPropertyLocationPath","getLocationForPropertyPath","sProperty","replace","$Type","iLength","sCollectionPath","lastIndexOf","indexOf","gotoActionParameter","oContext","sPropertyName","CommonUtils","getParameterPath","getEntitySetName","oMetaModel","sEntityType","oEntityContainer","key","getActionPath","oAction","bReturnOnlyPath","sActionName","bCheckStaticValue","sContextPath","sEntityTypeName","sEntityName","this","sBindingParameter","getNavigationContext","ODataModelAnnotationHelper","getNavigationPath","bKeepProperty","bStartsWithEntityType","startsWith","part","shift","pop","getActionContext","getPathToBoundActionOverload","addSingleQuotes","sValue","bEscape","escapeSingleQuotes","generateFunction","sFuncName","sParams","i","arguments","sFunction","getHeaderDataPointLinkVisibility","path","isClickable","compileExpression","ifElse","constant","equal","pathInModel","notEqual","objectToString","oParams","iNumberOfKeys","Object","keys","sKey","removeEscapeCharacters","sExpression","stringifyObject","sStringified","oObject","JSON","parse","Array","isArray","oUI5Object","ui5object","assign","stringify","sType","Log","error","Error","stringifyCustomData","vData","Context","parseCustomData","hasOwnProperty","getContextPath","oValue","getSortConditions","oPresentationVariant","sPresentationVariantPath","_isPresentationVariantAnnotation","SortOrder","aSortConditions","sorters","sEntityPath","forEach","oCondition","oSortProperty","oSorter","DynamicProperty","$AnnotationPath","Name","Property","$PropertyPath","name","descending","Descending","push","annotationPath","createPresentationPathContext","oPresentationContext","aPaths","createBindingContext","getPressHandlerForDataFieldForIBN","sContext","bNavigateWithConfirmationDialog","forContextMenu","mNavigationParameters","navigationContexts","RequiresContext","Inline","applicableProperty","notApplicableProperty","applicableContexts","SemanticObject","Action","notApplicableContexts","label","Label","Mapping","semanticObjectMapping","getEntitySet","ModelHelper","getEntitySetPath","getCriticalityCalculationBinding","sImprovementDirection","sDeviationLow","sToleranceLow","sAcceptanceLow","sAcceptanceHigh","sToleranceHigh","sDeviationHigh","sCriticalityExpression","Neutral","Infinity","Good","Critical","warning","getMeasureAttributeIndex","iMeasure","oChartAnnotations","isMicroChart","aMeasures","sMeasurePropertyPath","Measures","value","DynamicMeasures","bMeasureAttributeExists","aMeasureAttributes","MeasureAttributes","iMeasureAttribute","fnCheckMeasure","sMeasurePath","oMeasureAttribute","index","Measure","DynamicMeasure","some","bind","getMeasureAttribute","async","sChartAnnotationPath","requestObject","then","sMeasureAttributePath","DataPoint","getMeasureAttributeForMeasure","substring","isDraftParentEntityForContainment","oTargetCollectionContainsTarget","oTableMetadata","parentEntitySet","sParentEntitySetPath","oDraftRoot","oDraftNode","getDataFromTemplate","dataElement","splitPath","dataKey","connectedDataPath","connectedObject","template","Template","splitTemp","tempArray","trim","Data","notLastIndex","element","isLastIndex","templateInfo","lastIndex","getDelimiter","setMetaModel","getParameters","oParameterInfo","getParameterInfo","parameterProperties","buildActionWrapper","oThis","aParams","ref","handlerModule","handlerMethod","id","internalModelPath","oAdditionalParams","contexts","fn","getHiddenPathExpression","dataFieldAnnotations","hidden","getOperatorsForProperty","sEntitySetPath","bUseSemanticDateRange","settings","oFilterRestrictions","getFilterRestrictionsByPath","aEqualsOps","aSingleRangeOps","aSingleRangeDTBasicOps","aMultiRangeOps","aSearchExpressionOps","aBasicSemanticDateOps","SemanticDateOperators","getBasicSemanticDateOperations","bSemanticDateRange","aSemanticDateOps","oSettings","customData","operatorConfiguration","getFilterOperations","DefaultSemanticDateOperators","getSemanticDateOperations","aDefaultOperators","supportedOperators","extendedSemanticDateOperators","ExtendedSemanticDateOperators","restrictions","FilterAllowedExpressions","sAllowedExpression","getSpecificAllowedExpression","singleValueDateOps","getSingleValueDateOperations","aSingleValueOps","multiValueOperators","sOperators","concat","getOperatorsForDateProperty","propertyType","getAIIcon","aiIcon","requiresIContext"],"sources":["./CommonHelper.ts"],"sourcesContent":["import type {\n\tChart,\n\tChartMeasureAttributeType,\n\tDataFieldForIntentBasedNavigation,\n\tDataFieldTypes,\n\tPresentationVariant\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport type { CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression, constant, equal, fn, ifElse, notEqual, pathInModel, ref } from \"sap/fe/base/BindingToolkit\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport type { FilterSettings } from \"sap/fe/core/converters/ManifestSettings\";\n\nimport type { PropertyPath } from \"@sap-ux/vocabularies-types\";\nimport { aiIcon, type CustomAction } from \"sap/fe/core/converters/controls/Common/Action\";\nimport { convertTypes } from \"sap/fe/core/converters/MetaModelConverter\";\nimport { isPropertyFilterable } from \"sap/fe/core/helpers/MetaModelFunction\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport type { ComputedAnnotationInterface } from \"sap/fe/core/templating/UIFormatters\";\nimport * as DefaultSemanticDateOperators from \"sap/fe/macros/filterBar/DefaultSemanticDateOperators\";\nimport ExtendedSemanticDateOperators from \"sap/fe/macros/filterBar/ExtendedSemanticDateOperators\";\nimport SemanticDateOperators from \"sap/fe/macros/filterBar/SemanticDateOperators\";\nimport mLibrary from \"sap/m/library\";\nimport Device from \"sap/ui/Device\";\nimport FilterOperatorUtil from \"sap/ui/mdc/condition/FilterOperatorUtil\";\nimport FieldEditMode from \"sap/ui/mdc/enums/FieldEditMode\";\nimport TypeMap from \"sap/ui/mdc/odata/v4/TypeMap\";\nimport Context from \"sap/ui/model/Context\";\nimport ODataModelAnnotationHelper from \"sap/ui/model/odata/v4/AnnotationHelper\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\nimport type { MetaModelType } from \"../../../../../../types/metamodel_types\";\n\ntype MetaModelMeasure = {\n\t$PropertyPath: string;\n};\n\nfunction _getRestrictions(aDefaultOps: string[], aExpressionOps: string[]): string[] {\n\t// From the default set of Operators for the Base Type, select those that are defined in the Allowed Value.\n\t// In case that no operators are found, return undefined so that the default set is used.\n\treturn aDefaultOps.filter(function (sElement) {\n\t\treturn aExpressionOps.includes(sElement);\n\t});\n}\n\nfunction _getDefaultOperators(sPropertyType?: string): string[] {\n\t// mdc defines the full set of operations that are meaningful for each Edm Type\n\t// TODO Replace with model / internal way of retrieving the actual model type used for the property\n\tconst oDataClass = TypeMap.getDataTypeClassName(sPropertyType);\n\t// TODO need to pass proper formatOptions, constraints here\n\tconst oBaseType = TypeMap.getBaseType(oDataClass, {}, {});\n\treturn FilterOperatorUtil.getOperatorsForType(oBaseType);\n}\n\nconst ValueColor = mLibrary.ValueColor;\nconst CommonHelper = {\n\tgetPathToKey: function (oCtx: Context): object {\n\t\treturn oCtx.getObject();\n\t},\n\n\t/**\n\t * Determine if field is editable.\n\t * @param target Target instance\n\t * @param oInterface Interface instance\n\t * @returns A Binding Expression to determine if a field should be editable or not.\n\t */\n\tgetParameterEditMode: function (target: object, oInterface: ComputedAnnotationInterface): string {\n\t\tconst oModel = oInterface.context.getModel(),\n\t\t\tsPropertyPath = oInterface.context.getPath(),\n\t\t\toAnnotations = oModel.getObject(`${sPropertyPath}@`),\n\t\t\tfieldControl = oAnnotations[\"@com.sap.vocabularies.Common.v1.FieldControl\"],\n\t\t\timmutable = oAnnotations[\"@Org.OData.Core.V1.Immutable\"],\n\t\t\tcomputed = oAnnotations[\"@Org.OData.Core.V1.Computed\"];\n\n\t\tlet sEditMode: FieldEditMode | string = FieldEditMode.Editable;\n\n\t\tif (immutable || computed) {\n\t\t\tsEditMode = FieldEditMode.ReadOnly;\n\t\t} else if (fieldControl) {\n\t\t\tif (fieldControl.$EnumMember) {\n\t\t\t\tif (fieldControl.$EnumMember === \"com.sap.vocabularies.Common.v1.FieldControlType/ReadOnly\") {\n\t\t\t\t\tsEditMode = FieldEditMode.ReadOnly;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tfieldControl.$EnumMember === \"com.sap.vocabularies.Common.v1.FieldControlType/Inapplicable\" ||\n\t\t\t\t\tfieldControl.$EnumMember === \"com.sap.vocabularies.Common.v1.FieldControlType/Hidden\"\n\t\t\t\t) {\n\t\t\t\t\tsEditMode = FieldEditMode.Disabled;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fieldControl.$Path) {\n\t\t\t\tsEditMode =\n\t\t\t\t\t\"{= %{\" +\n\t\t\t\t\tfieldControl.$Path +\n\t\t\t\t\t\"} < 3 ? (%{\" +\n\t\t\t\t\tfieldControl.$Path +\n\t\t\t\t\t\"} === 0 ? '\" +\n\t\t\t\t\tFieldEditMode.Disabled +\n\t\t\t\t\t\"' : '\" +\n\t\t\t\t\tFieldEditMode.ReadOnly +\n\t\t\t\t\t\"') : '\" +\n\t\t\t\t\tFieldEditMode.Editable +\n\t\t\t\t\t\"'}\";\n\t\t\t}\n\t\t}\n\n\t\treturn sEditMode;\n\t},\n\t/**\n\t * Get the complete metapath to the target.\n\t * @param target\n\t * @param oInterface\n\t * @returns The metapath\n\t */\n\tgetMetaPath: function (target: unknown, oInterface: ComputedAnnotationInterface): string | undefined {\n\t\treturn (oInterface && oInterface.context && oInterface.context.getPath()) || undefined;\n\t},\n\tgetMetaModelId: function (target: Context, oInterface: ComputedAnnotationInterface): string {\n\t\tconvertTypes(oInterface.context.getModel());\n\t\treturn oInterface.context.getModel().getId();\n\t},\n\tisDesktop: function (): boolean {\n\t\treturn Device.system.desktop === true;\n\t},\n\tgetTargetCollectionPath: function (context: Context, navCollection?: string): string {\n\t\tlet sPath = context.getPath();\n\t\tif (\n\t\t\t(context.getObject(\"$kind\") as unknown as string) === \"EntitySet\" ||\n\t\t\t(context.getObject(\"$ContainsTarget\") as unknown as boolean) === true\n\t\t) {\n\t\t\treturn sPath;\n\t\t}\n\n\t\tconst model = context.getModel() as ODataModel | ODataMetaModel;\n\t\tconst metaModel = model.isA<ODataMetaModel>(\"sap.ui.model.odata.v4.ODataMetaModel\") ? model : model.getMetaModel();\n\t\tsPath = metaModel.getMetaPath(sPath);\n\n\t\t//Supporting sPath of any format, either '/<entitySet>/<navigationCollection>' <OR> '/<entitySet>/$Type/<navigationCollection>'\n\t\tconst aParts = sPath.split(\"/\").filter(function (sPart: string): boolean {\n\t\t\treturn !!sPart && sPart != \"$Type\";\n\t\t}); //filter out empty strings and parts referring to '$Type'\n\t\tconst entitySet = `/${aParts[0]}`;\n\t\tif (aParts.length === 1) {\n\t\t\treturn entitySet;\n\t\t}\n\t\tconst navigationCollection = navCollection === undefined ? aParts.slice(1).join(\"/$NavigationPropertyBinding/\") : navCollection;\n\t\treturn `${entitySet}/$NavigationPropertyBinding/${navigationCollection}`; // used in gotoTargetEntitySet method in the same file\n\t},\n\n\tisPropertyFilterable: function (\n\t\tcontext: Context,\n\t\toDataField?: MetaModelType<DataFieldTypes>,\n\t\tskipHiddenFilters?: boolean\n\t): boolean | CompiledBindingToolkitExpression {\n\t\tconst oModel = context.getModel() as ODataMetaModel,\n\t\t\tsPropertyPath = context.getPath(),\n\t\t\t// LoacationPath would be the prefix of sPropertyPath, example: sPropertyPath = '/Customer/Set/Name' -> sPropertyLocationPath = '/Customer/Set'\n\t\t\tsPropertyLocationPath = CommonHelper.getLocationForPropertyPath(oModel, sPropertyPath),\n\t\t\tsProperty = sPropertyPath.replace(`${sPropertyLocationPath}/`, \"\");\n\n\t\tif (\n\t\t\toDataField &&\n\t\t\t(oDataField.$Type === \"com.sap.vocabularies.UI.v1.DataFieldForAction\" ||\n\t\t\t\toDataField.$Type === \"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation\")\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isPropertyFilterable(oModel, sPropertyLocationPath, sProperty, skipHiddenFilters);\n\t},\n\n\tgetLocationForPropertyPath: function (oModel: ODataMetaModel, sPropertyPath: string): string {\n\t\tlet iLength;\n\t\tlet sCollectionPath = sPropertyPath.slice(0, sPropertyPath.lastIndexOf(\"/\"));\n\t\tif (oModel.getObject(`${sCollectionPath}/$kind`) === \"EntityContainer\") {\n\t\t\tiLength = sCollectionPath.length + 1;\n\t\t\tsCollectionPath = sPropertyPath.slice(iLength, sPropertyPath.indexOf(\"/\", iLength));\n\t\t}\n\t\treturn sCollectionPath;\n\t},\n\tgotoActionParameter: function (oContext: Context): string {\n\t\tconst sPath = oContext.getPath(),\n\t\t\tsPropertyName = oContext.getObject(`${sPath}/$Name`);\n\n\t\treturn CommonUtils.getParameterPath(sPath, sPropertyName);\n\t},\n\t/**\n\t * Returns the entity set name from the entity type name.\n\t * @param oMetaModel OData v4 metamodel instance\n\t * @param sEntityType EntityType of the actiom\n\t * @returns The EntitySet of the bound action\n\t * @private\n\t */\n\tgetEntitySetName: function (oMetaModel: ODataMetaModel, sEntityType: string): string | undefined {\n\t\tconst oEntityContainer = oMetaModel.getObject(\"/\");\n\t\tfor (const key in oEntityContainer) {\n\t\t\tif (typeof oEntityContainer[key] === \"object\" && oEntityContainer[key].$Type === sEntityType) {\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t},\n\t/**\n\t * Returns the metamodel path correctly for bound actions if used with bReturnOnlyPath as true,\n\t * else returns an object which has 3 properties related to the action. They are the entity set name,\n\t * the $Path value of the OperationAvailable annotation and the binding parameter name. If\n\t * bCheckStaticValue is true, returns the static value of OperationAvailable annotation, if present.\n\t * e.g. for bound action someNameSpace.SomeBoundAction\n\t * of entity set SomeEntitySet, the string \"/SomeEntitySet/someNameSpace.SomeBoundAction\" is returned.\n\t * @param oAction The context object of the action\n\t * @param bReturnOnlyPath If false, additional info is returned along with metamodel path to the bound action\n\t * @param sActionName The name of the bound action of the form someNameSpace.SomeBoundAction\n\t * @param bCheckStaticValue If true, the static value of OperationAvailable is returned, if present\n\t * @returns The string or object as specified by bReturnOnlyPath\n\t * @private\n\t */\n\tgetActionPath: function (\n\t\toAction: Context,\n\t\tbReturnOnlyPath: boolean,\n\t\tsActionName?: string,\n\t\tbCheckStaticValue?: boolean\n\t):\n\t\t| string\n\t\t| {\n\t\t\t\tsContextPath: string;\n\t\t\t\tsProperty: string;\n\t\t\t\tsBindingParameter: string;\n\t\t  } {\n\t\tlet sContextPath = oAction.getPath().split(\"/@\")[0];\n\n\t\tsActionName = !sActionName ? oAction.getObject(oAction.getPath()) : sActionName;\n\n\t\tif (sActionName && sActionName.includes(\"(\")) {\n\t\t\t// action bound to another entity type\n\t\t\tsActionName = sActionName.split(\"(\")[0];\n\t\t} else if (oAction.getObject(sContextPath)) {\n\t\t\t// TODO: this logic sounds wrong, to be corrected\n\t\t\tconst sEntityTypeName = oAction.getObject(sContextPath).$Type;\n\t\t\tconst sEntityName = this.getEntitySetName(oAction.getModel(), sEntityTypeName);\n\t\t\tif (sEntityName) {\n\t\t\t\tsContextPath = `/${sEntityName}`;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sContextPath;\n\t\t}\n\n\t\tif (bCheckStaticValue) {\n\t\t\treturn oAction.getObject(`${sContextPath}/${sActionName}@Org.OData.Core.V1.OperationAvailable`);\n\t\t}\n\t\tif (bReturnOnlyPath) {\n\t\t\treturn `${sContextPath}/${sActionName}`;\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tsContextPath: sContextPath,\n\t\t\t\tsProperty: oAction.getObject(`${sContextPath}/${sActionName}@Org.OData.Core.V1.OperationAvailable/$Path`),\n\t\t\t\tsBindingParameter: oAction.getObject(`${sContextPath}/${sActionName}/@$ui5.overload/0/$Parameter/0/$Name`)\n\t\t\t};\n\t\t}\n\t},\n\n\tgetNavigationContext: function (oContext: Context): string {\n\t\treturn ODataModelAnnotationHelper.getNavigationPath(oContext.getPath());\n\t},\n\n\t/**\n\t * Returns the path without the entity type (potentially first) and property (last) part (optional).\n\t * The result can be an empty string if it is a simple direct property.\n\t *\n\t * If and only if the given property path starts with a slash (/), it is considered that the entity type\n\t * is part of the path and will be stripped away.\n\t * @param sPropertyPath\n\t * @param bKeepProperty\n\t * @returns The navigation path\n\t */\n\tgetNavigationPath: function (sPropertyPath: string, bKeepProperty?: boolean): string {\n\t\tconst bStartsWithEntityType = sPropertyPath.startsWith(\"/\");\n\t\tconst aParts = sPropertyPath.split(\"/\").filter(function (part: string) {\n\t\t\treturn !!part;\n\t\t});\n\t\tif (bStartsWithEntityType) {\n\t\t\taParts.shift();\n\t\t}\n\t\tif (!bKeepProperty) {\n\t\t\taParts.pop();\n\t\t}\n\t\treturn aParts.join(\"/\");\n\t},\n\n\t/**\n\t * Returns the correct metamodel path for bound actions.\n\t *\n\t * Since this method is called irrespective of the action type, this will be applied to unbound actions.\n\t * In such a case, if an incorrect path is returned, it is ignored during templating.\n\t *\n\t * Example: for the bound action someNameSpace.SomeBoundAction of entity set SomeEntitySet,\n\t * the string \"/SomeEntitySet/someNameSpace.SomeBoundAction\" is returned.\n\t * @param oAction Context object for the action\n\t * @returns Correct metamodel path for bound and incorrect path for unbound actions\n\t * @private\n\t */\n\tgetActionContext: function (oAction: Context): string {\n\t\treturn CommonHelper.getActionPath(oAction, true) as string;\n\t},\n\t/**\n\t * Returns the metamodel path correctly for overloaded bound actions. For unbound actions,\n\t * the incorrect path is returned, but ignored during templating.\n\t * e.g. for bound action someNameSpace.SomeBoundAction of entity set SomeEntitySet,\n\t * the string \"/SomeEntitySet/someNameSpace.SomeBoundAction/@$ui5.overload/0\" is returned.\n\t * @param oAction The context object for the action\n\t * @returns The correct metamodel path for bound action overload and incorrect path for unbound actions\n\t * @private\n\t */\n\tgetPathToBoundActionOverload: function (oAction: Context): string {\n\t\tconst sPath = CommonHelper.getActionPath(oAction, true);\n\t\treturn `${sPath}/@$ui5.overload/0`;\n\t},\n\n\t/**\n\t * Returns the string with single quotes.\n\t * @param sValue Some string that needs to be converted into single quotes\n\t * @param [bEscape] Should the string be escaped beforehand\n\t * @returns - String with single quotes\n\t */\n\taddSingleQuotes: function (sValue: string, bEscape?: boolean): string {\n\t\tif (bEscape && sValue) {\n\t\t\tsValue = this.escapeSingleQuotes(sValue);\n\t\t}\n\t\treturn `'${sValue}'`;\n\t},\n\n\t/**\n\t * Returns the string with escaped single quotes.\n\t * @param sValue Some string that needs escaping of single quotes\n\t * @returns - String with escaped single quotes\n\t */\n\tescapeSingleQuotes: function (sValue: string): string {\n\t\treturn sValue.replace(/[']/g, \"\\\\'\");\n\t},\n\n\t/**\n\t * Returns the function string\n\t * The first argument of generateFunction is name of the generated function string.\n\t * Remaining arguments of generateFunction are arguments of the newly generated function string.\n\t * @param sFuncName Some string for the function name\n\t * @param args The remaining arguments\n\t * @returns - Function string depends on arguments passed\n\t */\n\tgenerateFunction: function (sFuncName: string, ...args: string[]): string {\n\t\tlet sParams = \"\";\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tsParams += args[i];\n\t\t\tif (i < args.length - 1) {\n\t\t\t\tsParams += \", \";\n\t\t\t}\n\t\t}\n\n\t\tlet sFunction = `${sFuncName}()`;\n\t\tif (sParams) {\n\t\t\tsFunction = `${sFuncName}(${sParams})`;\n\t\t}\n\t\treturn sFunction;\n\t},\n\t/*\n\t * Returns the visibility expression for datapoint title/link\n\t *\n\t * @function\n\t * @param {string} [path] annotation path of data point or Microchart\n\t * @param {boolean} [isClickable] true if link is visible\n\t * @returns {CompiledBindingToolkitExpression} visibilityExp Used to get the visibility binding for DataPoints title in the Header.\n\t *\n\t */\n\n\tgetHeaderDataPointLinkVisibility: function (path: string, isClickable: boolean): CompiledBindingToolkitExpression {\n\t\treturn compileExpression(\n\t\t\tifElse(\n\t\t\t\tconstant(isClickable),\n\t\t\t\tequal(pathInModel(`isHeaderDPLinkVisible/${path}`, \"internal\"), true),\n\t\t\t\tnotEqual(pathInModel(`isHeaderDPLinkVisible/${path}`, \"internal\"), true)\n\t\t\t)\n\t\t);\n\t},\n\n\t/**\n\t * Converts object to string(different from JSON.stringify or.toString).\n\t * @param oParams Some object\n\t * @returns - Object string\n\t */\n\tobjectToString: function (oParams: Record<string, unknown>): string {\n\t\tlet iNumberOfKeys = Object.keys(oParams).length,\n\t\t\tsParams = \"\";\n\n\t\tfor (const sKey in oParams) {\n\t\t\tlet sValue = oParams[sKey];\n\t\t\tif (sValue && typeof sValue === \"object\") {\n\t\t\t\tsValue = this.objectToString(sValue as Record<string, unknown>);\n\t\t\t}\n\t\t\tsParams += `${sKey}: ${sValue}`;\n\t\t\tif (iNumberOfKeys > 1) {\n\t\t\t\t--iNumberOfKeys;\n\t\t\t\tsParams += \", \";\n\t\t\t}\n\t\t}\n\n\t\treturn `{ ${sParams}}`;\n\t},\n\n\t/**\n\t * Removes escape characters (\\) from an expression.\n\t * @param sExpression An expression with escape characters\n\t * @returns Expression string without escape characters or undefined\n\t */\n\tremoveEscapeCharacters: function (sExpression?: string): string | undefined {\n\t\treturn sExpression ? sExpression.replace(/\\\\?\\\\([{}])/g, \"$1\") : undefined;\n\t},\n\n\t/**\n\t * Makes updates to a stringified object so that it works properly in a template by adding ui5Object:true.\n\t * @param sStringified\n\t * @returns The updated string representation of the object\n\t */\n\tstringifyObject: function (sStringified: string): string | undefined {\n\t\tif (!sStringified || sStringified === \"{}\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst oObject = JSON.parse(sStringified);\n\t\t\tif (typeof oObject === \"object\" && !Array.isArray(oObject)) {\n\t\t\t\tconst oUI5Object = {\n\t\t\t\t\tui5object: true\n\t\t\t\t};\n\t\t\t\tObject.assign(oUI5Object, oObject);\n\t\t\t\treturn JSON.stringify(oUI5Object);\n\t\t\t} else {\n\t\t\t\tconst sType = Array.isArray(oObject) ? \"Array\" : typeof oObject;\n\t\t\t\tLog.error(`Unexpected object type in stringifyObject (${sType}) - only works with object`);\n\t\t\t\tthrow new Error(\"stringifyObject only works with objects!\");\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Create a string representation of the given data, taking care that it is not treated as a binding expression.\n\t * @param vData The data to stringify\n\t * @returns The string representation of the data.\n\t */\n\tstringifyCustomData: function (vData: object | string | undefined): string {\n\t\tconst oObject: { ui5object: true; customData?: unknown } = {\n\t\t\tui5object: true\n\t\t};\n\t\toObject[\"customData\"] = vData instanceof Context ? vData.getObject() : vData;\n\t\treturn JSON.stringify(oObject);\n\t},\n\n\t/**\n\t * Parses the given data, potentially unwraps the data.\n\t * @param vData The data to parse\n\t * @param vData.ui5object\n\t * @param vData.customData\n\t * @returns The result of the data parsing\n\t */\n\tparseCustomData: function (vData?: string | { ui5object: true; customData?: unknown }): unknown {\n\t\tvData = typeof vData === \"string\" ? JSON.parse(vData) : vData;\n\t\tif (vData && vData.hasOwnProperty(\"customData\")) {\n\t\t\treturn (vData as { ui5object: true; customData?: unknown })[\"customData\"];\n\t\t}\n\t\treturn vData;\n\t},\n\tgetContextPath: function (oValue: unknown, oInterface: ComputedAnnotationInterface): string {\n\t\tconst sPath = oInterface && oInterface.context && oInterface.context.getPath();\n\t\treturn sPath[sPath.length - 1] === \"/\" ? sPath.slice(0, -1) : sPath;\n\t},\n\t/**\n\t * Returns a stringified JSON object containing  Presentation Variant sort conditions.\n\t * @param oContext\n\t * @param oContext.getPath\n\t * @param oContext.getModel\n\t * @param oPresentationVariant Presentation variant Annotation\n\t * @param sPresentationVariantPath\n\t * @returns Stringified JSON object\n\t */\n\tgetSortConditions: function (\n\t\toContext: { getPath(num: number): string; getModel(num: number): ODataMetaModel },\n\t\toPresentationVariant: MetaModelType<PresentationVariant>,\n\t\tsPresentationVariantPath: string\n\t): string | undefined {\n\t\tif (\n\t\t\toPresentationVariant &&\n\t\t\tCommonHelper._isPresentationVariantAnnotation(sPresentationVariantPath) &&\n\t\t\toPresentationVariant.SortOrder\n\t\t) {\n\t\t\tconst aSortConditions: { sorters: { name?: string; descending?: boolean }[] } = {\n\t\t\t\tsorters: []\n\t\t\t};\n\n\t\t\tconst sEntityPath = oContext.getPath(0).split(\"@\")[0];\n\t\t\toPresentationVariant.SortOrder.forEach(function (oCondition = {}) {\n\t\t\t\tlet oSortProperty: string | undefined;\n\t\t\t\tconst oSorter: { name?: string; descending?: boolean } = {};\n\t\t\t\tif (oCondition.DynamicProperty) {\n\t\t\t\t\toSortProperty = oContext.getModel(0).getObject(sEntityPath + oCondition.DynamicProperty.$AnnotationPath)?.Name;\n\t\t\t\t} else if (oCondition.Property) {\n\t\t\t\t\toSortProperty = oCondition.Property.$PropertyPath;\n\t\t\t\t}\n\t\t\t\tif (oSortProperty) {\n\t\t\t\t\toSorter.name = oSortProperty;\n\t\t\t\t\toSorter.descending = !!oCondition.Descending;\n\t\t\t\t\taSortConditions.sorters.push(oSorter);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Please define the right path to the sort property\");\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn JSON.stringify(aSortConditions);\n\t\t}\n\t\treturn undefined;\n\t},\n\t_isPresentationVariantAnnotation: function (annotationPath: string): boolean {\n\t\treturn (\n\t\t\tannotationPath.includes(`@${UIAnnotationTerms.PresentationVariant}`) ||\n\t\t\tannotationPath.includes(`@${UIAnnotationTerms.SelectionPresentationVariant}`)\n\t\t);\n\t},\n\tcreatePresentationPathContext: function (oPresentationContext: Context): Context {\n\t\tconst aPaths = oPresentationContext.getPath().split(\"@\") || [];\n\t\tconst oModel = oPresentationContext.getModel();\n\t\tif (aPaths.length && aPaths[aPaths.length - 1].includes(\"com.sap.vocabularies.UI.v1.SelectionPresentationVariant\")) {\n\t\t\tconst sPath = oPresentationContext.getPath().split(\"/PresentationVariant\")[0];\n\t\t\treturn oModel.createBindingContext(`${sPath}@sapui.name`);\n\t\t}\n\t\treturn oModel.createBindingContext(`${oPresentationContext.getPath()}@sapui.name`);\n\t},\n\tgetPressHandlerForDataFieldForIBN: function (\n\t\toDataField: DataFieldForIntentBasedNavigation,\n\t\tsContext?: string,\n\t\tbNavigateWithConfirmationDialog?: boolean,\n\t\tforContextMenu = false\n\t): string | undefined {\n\t\tif (!oDataField) return undefined;\n\t\tconst mNavigationParameters: {\n\t\t\tnavigationContexts?: string;\n\t\t\tlabel?: string;\n\t\t\tapplicableContexts?: string;\n\t\t\tnotApplicableContexts?: string;\n\t\t\tsemanticObjectMapping?: string;\n\t\t} = {\n\t\t\tnavigationContexts: sContext ? sContext : \"${$source>/}.getBindingContext()\"\n\t\t};\n\t\tif (oDataField.RequiresContext && !oDataField.Inline && bNavigateWithConfirmationDialog) {\n\t\t\tconst applicableProperty = !forContextMenu ? \"aApplicable\" : \"aApplicableForContextMenu\";\n\t\t\tconst notApplicableProperty = !forContextMenu ? \"aNotApplicable\" : \"aNotApplicableForContextMenu\";\n\t\t\tmNavigationParameters.applicableContexts = `\\${internal>ibn/${oDataField.SemanticObject}-${oDataField.Action}/${applicableProperty}/}`;\n\t\t\tmNavigationParameters.notApplicableContexts = `\\${internal>ibn/${oDataField.SemanticObject}-${oDataField.Action}/${notApplicableProperty}/}`;\n\t\t\tmNavigationParameters.label = this.addSingleQuotes(oDataField.Label as string, true);\n\t\t}\n\t\tif (oDataField.Mapping) {\n\t\t\tmNavigationParameters.semanticObjectMapping = this.addSingleQuotes(JSON.stringify(oDataField.Mapping));\n\t\t}\n\t\treturn this.generateFunction(\n\t\t\tbNavigateWithConfirmationDialog ? \"._intentBasedNavigation.navigateWithConfirmationDialog\" : \"._intentBasedNavigation.navigate\",\n\t\t\tthis.addSingleQuotes(oDataField.SemanticObject as unknown as string),\n\t\t\tthis.addSingleQuotes(oDataField.Action as unknown as string),\n\t\t\tthis.objectToString(mNavigationParameters),\n\t\t\t\"${$source>/}\"\n\t\t);\n\t},\n\tgetEntitySet: function (oContext: Context): string {\n\t\tconst sPath = oContext.getPath();\n\t\treturn ModelHelper.getEntitySetPath(sPath);\n\t},\n\n\t/**\n\t * Method to do the calculation of criticality in case CriticalityCalculation present in the annotation\n\t *\n\t * The calculation is done by comparing a value to the threshold values relevant for the specified improvement direction.\n\t * For improvement direction Target, the criticality is calculated using both low and high threshold values. It will be\n\t *\n\t * - Positive if the value is greater than or equal to AcceptanceRangeLowValue and lower than or equal to AcceptanceRangeHighValue\n\t * - Neutral if the value is greater than or equal to ToleranceRangeLowValue and lower than AcceptanceRangeLowValue OR greater than AcceptanceRangeHighValue and lower than or equal to ToleranceRangeHighValue\n\t * - Critical if the value is greater than or equal to DeviationRangeLowValue and lower than ToleranceRangeLowValue OR greater than ToleranceRangeHighValue and lower than or equal to DeviationRangeHighValue\n\t * - Negative if the value is lower than DeviationRangeLowValue or greater than DeviationRangeHighValue\n\t *\n\t * For improvement direction Minimize, the criticality is calculated using the high threshold values. It is\n\t * - Positive if the value is lower than or equal to AcceptanceRangeHighValue\n\t * - Neutral if the value is greater than AcceptanceRangeHighValue and lower than or equal to ToleranceRangeHighValue\n\t * - Critical if the value is greater than ToleranceRangeHighValue and lower than or equal to DeviationRangeHighValue\n\t * - Negative if the value is greater than DeviationRangeHighValue\n\t *\n\t * For improvement direction Maximize, the criticality is calculated using the low threshold values. It is\n\t *\n\t * - Positive if the value is greater than or equal to AcceptanceRangeLowValue\n\t * - Neutral if the value is less than AcceptanceRangeLowValue and greater than or equal to ToleranceRangeLowValue\n\t * - Critical if the value is lower than ToleranceRangeLowValue and greater than or equal to DeviationRangeLowValue\n\t * - Negative if the value is lower than DeviationRangeLowValue\n\t *\n\t * Thresholds are optional. For unassigned values, defaults are determined in this order:\n\t *\n\t * - For DeviationRange, an omitted LowValue translates into the smallest possible number (-INF), an omitted HighValue translates into the largest possible number (+INF)\n\t * - For ToleranceRange, an omitted LowValue will be initialized with DeviationRangeLowValue, an omitted HighValue will be initialized with DeviationRangeHighValue\n\t * - For AcceptanceRange, an omitted LowValue will be initialized with ToleranceRangeLowValue, an omitted HighValue will be initialized with ToleranceRangeHighValue.\n\t * @param sImprovementDirection ImprovementDirection to be used for creating the criticality binding\n\t * @param sValue Value from Datapoint to be measured\n\t * @param sDeviationLow ExpressionBinding for Lower Deviation level\n\t * @param sToleranceLow ExpressionBinding for Lower Tolerance level\n\t * @param sAcceptanceLow ExpressionBinding for Lower Acceptance level\n\t * @param sAcceptanceHigh ExpressionBinding for Higher Acceptance level\n\t * @param sToleranceHigh ExpressionBinding for Higher Tolerance level\n\t * @param sDeviationHigh ExpressionBinding for Higher Deviation level\n\t * @returns Returns criticality calculation as expression binding\n\t */\n\tgetCriticalityCalculationBinding: function (\n\t\tsImprovementDirection: string,\n\t\tsValue: string,\n\t\tsDeviationLow: string | number,\n\t\tsToleranceLow: string | number,\n\t\tsAcceptanceLow: string | number,\n\t\tsAcceptanceHigh: string | number,\n\t\tsToleranceHigh: string | number,\n\t\tsDeviationHigh: string | number\n\t): string {\n\t\tlet sCriticalityExpression: typeof ValueColor | string = ValueColor.Neutral; // Default Criticality State\n\n\t\tsValue = `%${sValue}`;\n\n\t\t// Setting Unassigned Values\n\t\tsDeviationLow = sDeviationLow || -Infinity;\n\t\tsToleranceLow = sToleranceLow || sDeviationLow;\n\t\tsAcceptanceLow = sAcceptanceLow || sToleranceLow;\n\t\tsDeviationHigh = sDeviationHigh || Infinity;\n\t\tsToleranceHigh = sToleranceHigh || sDeviationHigh;\n\t\tsAcceptanceHigh = sAcceptanceHigh || sToleranceHigh;\n\n\t\t// Dealing with Decimal and Path based bingdings\n\t\tsDeviationLow = sDeviationLow && (+sDeviationLow ? +sDeviationLow : `%${sDeviationLow}`);\n\t\tsToleranceLow = sToleranceLow && (+sToleranceLow ? +sToleranceLow : `%${sToleranceLow}`);\n\t\tsAcceptanceLow = sAcceptanceLow && (+sAcceptanceLow ? +sAcceptanceLow : `%${sAcceptanceLow}`);\n\t\tsAcceptanceHigh = sAcceptanceHigh && (+sAcceptanceHigh ? +sAcceptanceHigh : `%${sAcceptanceHigh}`);\n\t\tsToleranceHigh = sToleranceHigh && (+sToleranceHigh ? +sToleranceHigh : `%${sToleranceHigh}`);\n\t\tsDeviationHigh = sDeviationHigh && (+sDeviationHigh ? +sDeviationHigh : `%${sDeviationHigh}`);\n\n\t\t// Creating runtime expression binding from criticality calculation for Criticality State\n\t\tif (sImprovementDirection.includes(\"Minimize\")) {\n\t\t\tsCriticalityExpression =\n\t\t\t\t\"{= \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsAcceptanceHigh +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Good +\n\t\t\t\t\"' : \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsToleranceHigh +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Neutral +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"(\" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\") ? '\" +\n\t\t\t\tValueColor.Critical +\n\t\t\t\t\"' : '\" +\n\t\t\t\tValueColor.Error +\n\t\t\t\t\"' }\";\n\t\t} else if (sImprovementDirection.includes(\"Maximize\")) {\n\t\t\tsCriticalityExpression =\n\t\t\t\t\"{= \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsAcceptanceLow +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Good +\n\t\t\t\t\"' : \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsToleranceLow +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Neutral +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"(\" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\") ? '\" +\n\t\t\t\tValueColor.Critical +\n\t\t\t\t\"' : '\" +\n\t\t\t\tValueColor.Error +\n\t\t\t\t\"' }\";\n\t\t} else if (sImprovementDirection.includes(\"Target\")) {\n\t\t\tsCriticalityExpression =\n\t\t\t\t\"{= (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsAcceptanceHigh +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsAcceptanceLow +\n\t\t\t\t\") ? '\" +\n\t\t\t\tValueColor.Good +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"((\" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsToleranceLow +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" < \" +\n\t\t\t\tsAcceptanceLow +\n\t\t\t\t\") || (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" > \" +\n\t\t\t\tsAcceptanceHigh +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsToleranceHigh +\n\t\t\t\t\")) ? '\" +\n\t\t\t\tValueColor.Neutral +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"((\" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\" && (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\") && (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" < \" +\n\t\t\t\tsToleranceLow +\n\t\t\t\t\")) || ((\" +\n\t\t\t\tsValue +\n\t\t\t\t\" > \" +\n\t\t\t\tsToleranceHigh +\n\t\t\t\t\") && \" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\" && (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\"))) ? '\" +\n\t\t\t\tValueColor.Critical +\n\t\t\t\t\"' : '\" +\n\t\t\t\tValueColor.Error +\n\t\t\t\t\"' }\";\n\t\t} else {\n\t\t\tLog.warning(\"Case not supported, returning the default Value Neutral\");\n\t\t}\n\n\t\treturn sCriticalityExpression;\n\t},\n\t/**\n\t * To fetch measure attribute index.\n\t * @param iMeasure Chart Annotations\n\t * @param oChartAnnotations Chart Annotations\n\t * @returns MeasureAttribute index.\n\t * @private\n\t */\n\tgetMeasureAttributeIndex: function (iMeasure: number, oChartAnnotations: MetaModelType<Chart> | Chart, isMicroChart?: boolean): number {\n\t\tlet aMeasures, sMeasurePropertyPath;\n\t\tif (oChartAnnotations?.Measures?.length && oChartAnnotations?.Measures?.length > 0) {\n\t\t\taMeasures = oChartAnnotations.Measures;\n\t\t\tsMeasurePropertyPath = isMicroChart\n\t\t\t\t? (aMeasures[iMeasure] as PropertyPath).value\n\t\t\t\t: (aMeasures[iMeasure] as MetaModelMeasure).$PropertyPath;\n\t\t} else if (oChartAnnotations?.DynamicMeasures?.length && oChartAnnotations?.DynamicMeasures?.length > 0) {\n\t\t\taMeasures = (oChartAnnotations as MetaModelType<Chart>).DynamicMeasures;\n\t\t\tsMeasurePropertyPath = aMeasures?.[iMeasure].$AnnotationPath;\n\t\t}\n\t\tlet bMeasureAttributeExists;\n\t\tconst aMeasureAttributes = oChartAnnotations.MeasureAttributes;\n\t\tlet iMeasureAttribute = -1;\n\t\tconst fnCheckMeasure = function (\n\t\t\tsMeasurePath: string | undefined,\n\t\t\toMeasureAttribute: MetaModelType<ChartMeasureAttributeType> | ChartMeasureAttributeType,\n\t\t\tindex: number\n\t\t): boolean {\n\t\t\tif (oMeasureAttribute) {\n\t\t\t\tconst path = isMicroChart\n\t\t\t\t\t? (oMeasureAttribute as ChartMeasureAttributeType).Measure?.value\n\t\t\t\t\t: (oMeasureAttribute as MetaModelType<ChartMeasureAttributeType>).Measure?.$PropertyPath;\n\t\t\t\tif (oMeasureAttribute.Measure && path === sMeasurePath) {\n\t\t\t\t\tiMeasureAttribute = index;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (\n\t\t\t\t\toMeasureAttribute.DynamicMeasure &&\n\t\t\t\t\t(oMeasureAttribute as MetaModelType<ChartMeasureAttributeType>)?.DynamicMeasure?.$AnnotationPath === sMeasurePath\n\t\t\t\t) {\n\t\t\t\t\tiMeasureAttribute = index;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (aMeasureAttributes) {\n\t\t\tbMeasureAttributeExists = aMeasureAttributes.some(fnCheckMeasure.bind(null, sMeasurePropertyPath));\n\t\t}\n\t\treturn bMeasureAttributeExists && iMeasureAttribute > -1 ? iMeasureAttribute : -1;\n\t},\n\n\tgetMeasureAttribute: async function (oContext: Context): Promise<string | undefined> {\n\t\tconst oMetaModel = oContext.getModel() as ODataMetaModel,\n\t\t\tsChartAnnotationPath = oContext.getPath();\n\t\treturn oMetaModel.requestObject(sChartAnnotationPath).then(function (oChartAnnotations: MetaModelType<Chart>) {\n\t\t\tconst aMeasureAttributes = oChartAnnotations.MeasureAttributes,\n\t\t\t\tiMeasureAttribute = CommonHelper.getMeasureAttributeIndex(0, oChartAnnotations);\n\t\t\tconst sMeasureAttributePath =\n\t\t\t\tiMeasureAttribute > -1 && aMeasureAttributes?.[iMeasureAttribute] && aMeasureAttributes[iMeasureAttribute].DataPoint\n\t\t\t\t\t? `${sChartAnnotationPath}/MeasureAttributes/${iMeasureAttribute}/`\n\t\t\t\t\t: undefined;\n\t\t\tif (sMeasureAttributePath === undefined) {\n\t\t\t\tLog.warning(\"DataPoint missing for the measure\");\n\t\t\t}\n\t\t\treturn sMeasureAttributePath ? `${sMeasureAttributePath}DataPoint/$AnnotationPath/` : sMeasureAttributePath;\n\t\t});\n\t},\n\t/**\n\t * This function returns the measureAttribute for the measure.\n\t * @param oContext Context to the measure annotation\n\t * @returns Path to the measureAttribute of the measure\n\t */\n\tgetMeasureAttributeForMeasure: function (oContext: Context): string | undefined {\n\t\tconst oMetaModel = oContext.getModel() as ODataMetaModel,\n\t\t\tsMeasurePath = oContext.getPath(),\n\t\t\tsChartAnnotationPath = sMeasurePath.substring(0, sMeasurePath.lastIndexOf(\"Measure\")),\n\t\t\tiMeasure = sMeasurePath.replace(/.*\\//, \"\");\n\n\t\tconst oChartAnnotations = oMetaModel.getObject(sChartAnnotationPath);\n\t\tconst aMeasureAttributes = oChartAnnotations.MeasureAttributes,\n\t\t\tiMeasureAttribute = CommonHelper.getMeasureAttributeIndex(iMeasure as unknown as number, oChartAnnotations);\n\t\tconst sMeasureAttributePath =\n\t\t\tiMeasureAttribute > -1 && aMeasureAttributes[iMeasureAttribute] && aMeasureAttributes[iMeasureAttribute].DataPoint\n\t\t\t\t? `${sChartAnnotationPath}MeasureAttributes/${iMeasureAttribute}/`\n\t\t\t\t: undefined;\n\t\tif (sMeasureAttributePath === undefined) {\n\t\t\tLog.warning(\"DataPoint missing for the measure\");\n\t\t}\n\t\treturn sMeasureAttributePath ? `${sMeasureAttributePath}DataPoint/$AnnotationPath/` : sMeasureAttributePath;\n\t},\n\t/**\n\t * Method to determine if the contained navigation property has a draft root/node parent entitySet.\n\t * @param oTargetCollectionContainsTarget Target collection has ContainsTarget property\n\t * @param oTableMetadata Table metadata for which draft support shall be checked\n\t * @param oTableMetadata.parentEntitySet\n\t * @param oTableMetadata.parentEntitySet.oModel\n\t * @param oTableMetadata.parentEntitySet.sPath\n\t * @returns Returns true if draft\n\t */\n\tisDraftParentEntityForContainment: function (\n\t\toTargetCollectionContainsTarget: object,\n\t\toTableMetadata: {\n\t\t\tparentEntitySet?: {\n\t\t\t\toModel: ODataMetaModel;\n\t\t\t\tsPath?: string;\n\t\t\t};\n\t\t}\n\t): boolean {\n\t\tif (oTargetCollectionContainsTarget) {\n\t\t\tif (oTableMetadata && oTableMetadata.parentEntitySet && oTableMetadata.parentEntitySet.sPath) {\n\t\t\t\tconst sParentEntitySetPath = oTableMetadata.parentEntitySet.sPath;\n\t\t\t\tconst oDraftRoot = oTableMetadata.parentEntitySet.oModel.getObject(\n\t\t\t\t\t`${sParentEntitySetPath}@com.sap.vocabularies.Common.v1.DraftRoot`\n\t\t\t\t);\n\t\t\t\tconst oDraftNode = oTableMetadata.parentEntitySet.oModel.getObject(\n\t\t\t\t\t`${sParentEntitySetPath}@com.sap.vocabularies.Common.v1.DraftNode`\n\t\t\t\t);\n\t\t\t\tif (oDraftRoot || oDraftNode) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Ensures the data is processed as defined in the template.\n\t * Since the property Data is of the type 'object', it may not be in the same order as required by the template.\n\t * @param dataElement The data that is currently being processed.\n\t * @returns The correct path according to the template.\n\t */\n\tgetDataFromTemplate: function (dataElement: Context): string {\n\t\tconst splitPath = dataElement.getPath().split(\"/\");\n\t\tconst dataKey = splitPath[splitPath.length - 1];\n\t\tconst connectedDataPath = `/${splitPath.slice(1, -2).join(\"/\")}/@`;\n\t\tconst connectedObject = dataElement.getObject(connectedDataPath);\n\t\tconst template = connectedObject.Template;\n\t\tconst splitTemp = template.split(\"}\");\n\t\tconst tempArray = [];\n\t\tfor (let i = 0; i < splitTemp.length - 1; i++) {\n\t\t\tconst key = splitTemp[i].split(\"{\")[1].trim();\n\t\t\ttempArray.push(key);\n\t\t}\n\t\tObject.keys(connectedObject.Data).forEach(function (sKey: string) {\n\t\t\tif (sKey.startsWith(\"$\")) {\n\t\t\t\tdelete connectedObject.Data[sKey];\n\t\t\t}\n\t\t});\n\t\tconst index = Object.keys(connectedObject.Data).indexOf(dataKey);\n\t\treturn `/${splitPath.slice(1, -2).join(\"/\")}/Data/${tempArray[index]}`;\n\t},\n\n\t/**\n\t * Checks if the end of the template has been reached.\n\t * @param target The target of the connected fields.\n\t * @param target.Template\n\t * @param target.Data\n\t * @param element The element that is currently being processed.\n\t * @returns True or False (depending on the template index).\n\t */\n\tnotLastIndex: function (target: { Template: string; Data: Record<string, unknown> }, element: object): boolean {\n\t\tconst template = target.Template;\n\t\tconst splitTemp = template.split(\"}\");\n\t\tconst tempArray: string[] = [];\n\t\tlet isLastIndex = false;\n\t\tfor (let i = 0; i < splitTemp.length - 1; i++) {\n\t\t\tconst dataKey = splitTemp[i].split(\"{\")[1].trim();\n\t\t\ttempArray.push(dataKey);\n\t\t}\n\n\t\ttempArray.forEach(function (templateInfo: string) {\n\t\t\tconst lastIndex = tempArray.length - 1;\n\t\t\tif (target.Data[templateInfo] === element && tempArray.indexOf(templateInfo) < lastIndex) {\n\t\t\t\tisLastIndex = true;\n\t\t\t}\n\t\t});\n\t\treturn isLastIndex;\n\t},\n\n\t/**\n\t * Determines the delimiter from the template.\n\t * @param template The template string.\n\t * @returns The delimiter in the template string.\n\t */\n\tgetDelimiter: function (template: string): string {\n\t\treturn template.split(\"}\")[1].split(\"{\")[0].trim();\n\t},\n\n\toMetaModel: undefined as ODataMetaModel | undefined,\n\tsetMetaModel: function (oMetaModel: ODataMetaModel): void {\n\t\tthis.oMetaModel = oMetaModel;\n\t},\n\n\tgetMetaModel: function (): ODataMetaModel {\n\t\treturn this.oMetaModel!;\n\t},\n\n\tgetParameters: function (sPath: string, metaModel?: ODataMetaModel): string[] {\n\t\tif (metaModel) {\n\t\t\tconst oParameterInfo = CommonUtils.getParameterInfo(metaModel, sPath);\n\t\t\tif (oParameterInfo.parameterProperties) {\n\t\t\t\treturn Object.keys(oParameterInfo.parameterProperties);\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t},\n\n\t/**\n\t * Build an expression calling an action handler via the FPM helper's actionWrapper function\n\t *\n\t * This function assumes that the 'FPM.actionWrapper()' function is available at runtime.\n\t * @param oAction Action metadata\n\t * @param oAction.handlerModule Module containing the action handler method\n\t * @param oAction.handlerMethod Action handler method name\n\t * @param [oThis] `this` (if the function is called from a macro)\n\t * @param oThis.id The table's ID\n\t * @param forContextMenu Indicates if the action appears in the context menu. If false, the action appears in the table toolbar\n\t * @returns The action wrapper binding\texpression\n\t */\n\tbuildActionWrapper: function (\n\t\toAction: CustomAction,\n\t\toThis: { id?: string } | undefined,\n\t\tforContextMenu = false\n\t): CompiledBindingToolkitExpression {\n\t\tconst aParams: unknown[] = [ref(\"$event\"), oAction.handlerModule, oAction.handlerMethod];\n\n\t\tif (oThis && oThis.id) {\n\t\t\tconst internalModelPath = !forContextMenu ? \"${internal>selectedContexts}\" : \"${internal>contextmenu/selectedContexts}\";\n\t\t\tconst oAdditionalParams = { contexts: ref(internalModelPath) };\n\t\t\taParams.push(oAdditionalParams);\n\t\t}\n\t\treturn compileExpression(fn(\"FPM.actionWrapper\", aParams));\n\t},\n\t/**\n\t * Returns the value whether or not the element should be visible depending on the Hidden annotation.\n\t * It is inverted as the UI elements have a visible property instead of a hidden one.\n\t * @param dataFieldAnnotations The dataField object\n\t * @returns A path or a Boolean\n\t */\n\tgetHiddenPathExpression: function (dataFieldAnnotations: Record<string, { $Path?: string }>): string | boolean {\n\t\tif (dataFieldAnnotations[\"@com.sap.vocabularies.UI.v1.Hidden\"] !== null) {\n\t\t\tconst hidden = dataFieldAnnotations[\"@com.sap.vocabularies.UI.v1.Hidden\"];\n\t\t\treturn typeof hidden === \"object\" ? \"{= !${\" + hidden.$Path + \"} }\" : !hidden;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Method to fetch the correct operators based on the filter restrictions that can be annotated on an entity set or a navigation property.\n\t * We return the correct operators based on the specified restriction and also check for the operators defined in the manifest to include or exclude them.\n\t * @param sProperty String name of the property\n\t * @param sEntitySetPath String path to the entity set\n\t * @param oContext Context used during templating\n\t * @param sType String data type od the property, for example edm.Date\n\t * @param bUseSemanticDateRange Boolean passed from the manifest for semantic date range\n\t * @param settings Stringified object of the property settings or property settings as a whole\n\t * @returns An array of strings representing operators for filtering\n\t */\n\tgetOperatorsForProperty: function (\n\t\tsProperty: string,\n\t\tsEntitySetPath: string,\n\t\toContext: ODataMetaModel,\n\t\tsType?: string,\n\t\tbUseSemanticDateRange?: boolean | string,\n\t\tsettings?: FilterSettings | string\n\t): string[] {\n\t\tconst oFilterRestrictions = CommonUtils.getFilterRestrictionsByPath(sEntitySetPath, oContext);\n\t\tconst aEqualsOps = [\"EQ\"];\n\t\tconst aSingleRangeOps = [\"EQ\", \"GE\", \"LE\", \"LT\", \"GT\", \"BT\", \"NOTLE\", \"NOTLT\", \"NOTGE\", \"NOTGT\"];\n\t\tconst aSingleRangeDTBasicOps = [\"EQ\", \"BT\"];\n\t\tconst aMultiRangeOps = [\"EQ\", \"GE\", \"LE\", \"LT\", \"GT\", \"BT\", \"NE\", \"NOTBT\", \"NOTLE\", \"NOTLT\", \"NOTGE\", \"NOTGT\"];\n\t\tconst aSearchExpressionOps = [\"Contains\", \"NotContains\", \"StartsWith\", \"NotStartsWith\", \"EndsWith\", \"NotEndsWith\"];\n\t\tconst aBasicSemanticDateOps = SemanticDateOperators.getBasicSemanticDateOperations();\n\t\tconst bSemanticDateRange = bUseSemanticDateRange === \"true\" || bUseSemanticDateRange === true;\n\t\tlet aSemanticDateOps: string[] = [];\n\t\tconst oSettings = settings && typeof settings === \"string\" ? JSON.parse(settings).customData : settings;\n\n\t\tif ((oContext.getObject(`${sEntitySetPath}/@com.sap.vocabularies.Common.v1.ResultContext`) as unknown) === true) {\n\t\t\treturn aEqualsOps;\n\t\t}\n\n\t\tif (oSettings && oSettings.operatorConfiguration && oSettings.operatorConfiguration.length > 0) {\n\t\t\taSemanticDateOps = SemanticDateOperators.getFilterOperations(oSettings.operatorConfiguration, sType);\n\t\t} else {\n\t\t\taSemanticDateOps = DefaultSemanticDateOperators.getSemanticDateOperations(sType);\n\t\t}\n\t\t// Get the default Operators for this Property Type\n\t\tconst aDefaultOperators = _getDefaultOperators(sType);\n\t\tlet supportedOperators = aDefaultOperators;\n\t\tif (bSemanticDateRange) {\n\t\t\tconst extendedSemanticDateOperators = ExtendedSemanticDateOperators.getSemanticDateOperations();\n\t\t\tsupportedOperators = [...aBasicSemanticDateOps, ...aDefaultOperators, ...extendedSemanticDateOperators];\n\t\t}\n\n\t\tlet restrictions: string[] = [];\n\n\t\t// Is there a Filter Restriction defined for this property?\n\t\tif (\n\t\t\toFilterRestrictions &&\n\t\t\toFilterRestrictions.FilterAllowedExpressions &&\n\t\t\toFilterRestrictions.FilterAllowedExpressions[sProperty]\n\t\t) {\n\t\t\t// Extending the default operators list with Semantic Date options DATERANGE, DATE, FROM and TO\n\t\t\tconst sAllowedExpression = CommonUtils.getSpecificAllowedExpression(oFilterRestrictions.FilterAllowedExpressions[sProperty]);\n\t\t\t// In case more than one Allowed Expressions has been defined for a property\n\t\t\t// choose the most restrictive Allowed Expression\n\n\t\t\t// MultiValue has same Operator as SingleValue, but there can be more than one (maxConditions)\n\t\t\tswitch (sAllowedExpression) {\n\t\t\t\tcase \"SingleValue\":\n\t\t\t\t\tconst singleValueDateOps = DefaultSemanticDateOperators.getSingleValueDateOperations();\n\t\t\t\t\tconst aSingleValueOps = sType === \"Edm.Date\" && bSemanticDateRange ? singleValueDateOps : aEqualsOps;\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aSingleValueOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"MultiValue\":\n\t\t\t\t\tconst multiValueOperators = [...aEqualsOps, \"Empty\", \"NotEmpty\"];\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, multiValueOperators);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SingleRange\":\n\t\t\t\t\tlet aExpressionOps: string[];\n\t\t\t\t\tif (bSemanticDateRange) {\n\t\t\t\t\t\tif (sType === \"Edm.Date\") {\n\t\t\t\t\t\t\taExpressionOps = aSemanticDateOps;\n\t\t\t\t\t\t} else if (sType === \"Edm.DateTimeOffset\") {\n\t\t\t\t\t\t\taExpressionOps = aSemanticDateOps;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taExpressionOps = aSingleRangeOps;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sType === \"Edm.DateTimeOffset\") {\n\t\t\t\t\t\taExpressionOps = aSingleRangeDTBasicOps;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taExpressionOps = aSingleRangeOps;\n\t\t\t\t\t}\n\t\t\t\t\tconst sOperators = _getRestrictions(supportedOperators, aExpressionOps);\n\t\t\t\t\trestrictions = sOperators;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"MultiRange\":\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aMultiRangeOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SearchExpression\":\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aSearchExpressionOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"MultiRangeOrSearchExpression\":\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aSearchExpressionOps.concat(aMultiRangeOps));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// In case AllowedExpressions is not recognised, undefined in return results in the default set of\n\t\t\t// operators for the type.\n\t\t}\n\t\treturn restrictions;\n\t},\n\tgetOperatorsForDateProperty: function (propertyType: string): string[] {\n\t\t// In case AllowedExpressions is not provided for type Edm.Date then all the default\n\t\t// operators for the type should be returned excluding semantic operators from the list.\n\t\tconst aDefaultOperators = _getDefaultOperators(propertyType);\n\t\tconst aMultiRangeOps = [\"EQ\", \"GE\", \"LE\", \"LT\", \"GT\", \"BT\", \"NE\", \"NOTBT\", \"NOTLE\", \"NOTLT\", \"NOTGE\", \"NOTGT\"];\n\t\treturn _getRestrictions(aDefaultOperators, aMultiRangeOps);\n\t},\n\tgetAIIcon: function (): string {\n\t\treturn aiIcon;\n\t}\n};\n(CommonHelper.getSortConditions as { requiresIContext?: boolean }).requiresIContext = true;\n\nexport default CommonHelper;\n"],"mappings":";;;;k2BAsCA,SAASA,EAAiBC,EAAuBC,GAGhD,OAAOD,EAAYE,OAAO,SAAUC,GACnC,OAAOF,EAAeG,SAASD,EAChC,EACD,CAEA,SAASE,EAAqBC,GAG7B,MAAMC,EAAaC,EAAQC,qBAAqBH,GAEhD,MAAMI,EAAYF,EAAQG,YAAYJ,EAAY,CAAC,EAAG,CAAC,GACvD,OAAOK,EAAmBC,oBAAoBH,EAC/C,CAEA,MAAMI,EAAaC,EAASD,WAC5B,MAAME,EAAe,CACpBC,aAAc,SAAUC,GACvB,OAAOA,EAAKC,WACb,EAQAC,qBAAsB,SAAUC,EAAgBC,GAC/C,MAAMC,EAASD,EAAWE,QAAQC,WACjCC,EAAgBJ,EAAWE,QAAQG,UACnCC,EAAeL,EAAOJ,UAAU,GAAGO,MACnCG,EAAeD,EAAa,gDAC5BE,EAAYF,EAAa,gCACzBG,EAAWH,EAAa,+BAEzB,IAAII,EAAoCC,EAAcC,SAEtD,GAAIJ,GAAaC,EAAU,CAC1BC,EAAYC,EAAcE,QAC3B,MAAO,GAAIN,EAAc,CACxB,GAAIA,EAAaO,YAAa,CAC7B,GAAIP,EAAaO,cAAgB,2DAA4D,CAC5FJ,EAAYC,EAAcE,QAC3B,CACA,GACCN,EAAaO,cAAgB,gEAC7BP,EAAaO,cAAgB,yDAC5B,CACDJ,EAAYC,EAAcI,QAC3B,CACD,CACA,GAAIR,EAAaS,MAAO,CACvBN,EACC,QACAH,EAAaS,MACb,cACAT,EAAaS,MACb,cACAL,EAAcI,SACd,QACAJ,EAAcE,SACd,SACAF,EAAcC,SACd,IACF,CACD,CAEA,OAAOF,CACR,EAOAO,YAAa,SAAUlB,EAAiBC,GACvC,OAAQA,GAAcA,EAAWE,SAAWF,EAAWE,QAAQG,WAAca,SAC9E,EACAC,eAAgB,SAAUpB,EAAiBC,GAC1CoB,EAAapB,EAAWE,QAAQC,YAChC,OAAOH,EAAWE,QAAQC,WAAWkB,OACtC,EACAC,UAAW,WACV,OAAOC,EAAOC,OAAOC,UAAY,IAClC,EACAC,wBAAyB,SAAUxB,EAAkByB,GACpD,IAAIC,EAAQ1B,EAAQG,UACpB,GACEH,EAAQL,UAAU,WAAmC,aACrDK,EAAQL,UAAU,qBAA8C,KAChE,CACD,OAAO+B,CACR,CAEA,MAAMC,EAAQ3B,EAAQC,WACtB,MAAM2B,EAAYD,EAAME,IAAoB,wCAA0CF,EAAQA,EAAMG,eACpGJ,EAAQE,EAAUb,YAAYW,GAG9B,MAAMK,EAASL,EAAMM,MAAM,KAAKtD,OAAO,SAAUuD,GAChD,QAASA,GAASA,GAAS,OAC5B,GACA,MAAMC,EAAY,IAAIH,EAAO,KAC7B,GAAIA,EAAOI,SAAW,EAAG,CACxB,OAAOD,CACR,CACA,MAAME,EAAuBX,IAAkBT,UAAYe,EAAOM,MAAM,GAAGC,KAAK,gCAAkCb,EAClH,MAAO,GAAGS,gCAAwCE,GACnD,EAEAG,qBAAsB,SACrBvC,EACAwC,EACAC,GAEA,MAAM1C,EAASC,EAAQC,WACtBC,EAAgBF,EAAQG,UAExBuC,EAAwBlD,EAAamD,2BAA2B5C,EAAQG,GACxE0C,EAAY1C,EAAc2C,QAAQ,GAAGH,KAA0B,IAEhE,GACCF,IACCA,EAAWM,QAAU,iDACrBN,EAAWM,QAAU,gEACrB,CACD,OAAO,KACR,CAEA,OAAOP,EAAqBxC,EAAQ2C,EAAuBE,EAAWH,EACvE,EAEAE,2BAA4B,SAAU5C,EAAwBG,GAC7D,IAAI6C,EACJ,IAAIC,EAAkB9C,EAAcmC,MAAM,EAAGnC,EAAc+C,YAAY,MACvE,GAAIlD,EAAOJ,UAAU,GAAGqD,aAA6B,kBAAmB,CACvED,EAAUC,EAAgBb,OAAS,EACnCa,EAAkB9C,EAAcmC,MAAMU,EAAS7C,EAAcgD,QAAQ,IAAKH,GAC3E,CACA,OAAOC,CACR,EACAG,oBAAqB,SAAUC,GAC9B,MAAM1B,EAAQ0B,EAASjD,UACtBkD,EAAgBD,EAASzD,UAAU,GAAG+B,WAEvC,OAAO4B,EAAYC,iBAAiB7B,EAAO2B,EAC5C,EAQAG,iBAAkB,SAAUC,EAA4BC,GACvD,MAAMC,EAAmBF,EAAW9D,UAAU,KAC9C,IAAK,MAAMiE,KAAOD,EAAkB,CACnC,UAAWA,EAAiBC,KAAS,UAAYD,EAAiBC,GAAKd,QAAUY,EAAa,CAC7F,OAAOE,CACR,CACD,CACA,OAAO5C,SACR,EAeA6C,cAAe,SACdC,EACAC,EACAC,EACAC,GAQA,IAAIC,EAAeJ,EAAQ3D,UAAU6B,MAAM,MAAM,GAEjDgC,GAAeA,EAAcF,EAAQnE,UAAUmE,EAAQ3D,WAAa6D,EAEpE,GAAIA,GAAeA,EAAYpF,SAAS,KAAM,CAE7CoF,EAAcA,EAAYhC,MAAM,KAAK,EACtC,MAAO,GAAI8B,EAAQnE,UAAUuE,GAAe,CAE3C,MAAMC,EAAkBL,EAAQnE,UAAUuE,GAAcpB,MACxD,MAAMsB,EAAcC,KAAKb,iBAAiBM,EAAQ7D,WAAYkE,GAC9D,GAAIC,EAAa,CAChBF,EAAe,IAAIE,GACpB,CACD,KAAO,CACN,OAAOF,CACR,CAEA,GAAID,EAAmB,CACtB,OAAOH,EAAQnE,UAAU,GAAGuE,KAAgBF,yCAC7C,CACA,GAAID,EAAiB,CACpB,MAAO,GAAGG,KAAgBF,GAC3B,KAAO,CACN,MAAO,CACNE,aAAcA,EACdtB,UAAWkB,EAAQnE,UAAU,GAAGuE,KAAgBF,gDAChDM,kBAAmBR,EAAQnE,UAAU,GAAGuE,KAAgBF,yCAE1D,CACD,EAEAO,qBAAsB,SAAUnB,GAC/B,OAAOoB,EAA2BC,kBAAkBrB,EAASjD,UAC9D,EAYAsE,kBAAmB,SAAUvE,EAAuBwE,GACnD,MAAMC,EAAwBzE,EAAc0E,WAAW,KACvD,MAAM7C,EAAS7B,EAAc8B,MAAM,KAAKtD,OAAO,SAAUmG,GACxD,QAASA,CACV,GACA,GAAIF,EAAuB,CAC1B5C,EAAO+C,OACR,CACA,IAAKJ,EAAe,CACnB3C,EAAOgD,KACR,CACA,OAAOhD,EAAOO,KAAK,IACpB,EAcA0C,iBAAkB,SAAUlB,GAC3B,OAAOtE,EAAaqE,cAAcC,EAAS,KAC5C,EAUAmB,6BAA8B,SAAUnB,GACvC,MAAMpC,EAAQlC,EAAaqE,cAAcC,EAAS,MAClD,MAAO,GAAGpC,oBACX,EAQAwD,gBAAiB,SAAUC,EAAgBC,GAC1C,GAAIA,GAAWD,EAAQ,CACtBA,EAASd,KAAKgB,mBAAmBF,EAClC,CACA,MAAO,IAAIA,IACZ,EAOAE,mBAAoB,SAAUF,GAC7B,OAAOA,EAAOtC,QAAQ,OAAQ,MAC/B,EAUAyC,iBAAkB,SAAUC,GAC3B,IAAIC,EAAU,GACd,IAAK,IAAIC,EAAI,EAAGA,GAACC,UAAAvD,QAAA,IAAAuD,UAAAvD,OAAA,GAAgBsD,IAAK,CACrCD,GAAgBC,EAAC,KAAAC,UAAAvD,QAADsD,EAAC,EAAAzE,UAAA0E,UAADD,EAAC,GACjB,GAAIA,GAAIC,UAAAvD,QAAA,IAAAuD,UAAAvD,OAAA,GAAc,EAAG,CACxBqD,GAAW,IACZ,CACD,CAEA,IAAIG,EAAY,GAAGJ,MACnB,GAAIC,EAAS,CACZG,EAAY,GAAGJ,KAAaC,IAC7B,CACA,OAAOG,CACR,EAWAC,iCAAkC,SAAUC,EAAcC,GACzD,OAAOC,EACNC,EACCC,EAASH,GACTI,EAAMC,EAAY,yBAAyBN,IAAQ,YAAa,MAChEO,EAASD,EAAY,yBAAyBN,IAAQ,YAAa,OAGtE,EAOAQ,eAAgB,SAAUC,GACzB,IAAIC,EAAgBC,OAAOC,KAAKH,GAASnE,OACxCqD,EAAU,GAEX,IAAK,MAAMkB,KAAQJ,EAAS,CAC3B,IAAInB,EAASmB,EAAQI,GACrB,GAAIvB,UAAiBA,IAAW,SAAU,CACzCA,EAASd,KAAKgC,eAAelB,EAC9B,CACAK,GAAW,GAAGkB,MAASvB,IACvB,GAAIoB,EAAgB,EAAG,GACpBA,EACFf,GAAW,IACZ,CACD,CAEA,MAAO,KAAKA,IACb,EAOAmB,uBAAwB,SAAUC,GACjC,OAAOA,EAAcA,EAAY/D,QAAQ,eAAgB,MAAQ7B,SAClE,EAOA6F,gBAAiB,SAAUC,GAC1B,IAAKA,GAAgBA,IAAiB,KAAM,CAC3C,OAAO9F,SACR,KAAO,CACN,MAAM+F,EAAUC,KAAKC,MAAMH,GAC3B,UAAWC,IAAY,WAAaG,MAAMC,QAAQJ,GAAU,CAC3D,MAAMK,EAAa,CAClBC,UAAW,MAEZb,OAAOc,OAAOF,EAAYL,GAC1B,OAAOC,KAAKO,UAAUH,EACvB,KAAO,CACN,MAAMI,EAAQN,MAAMC,QAAQJ,GAAW,eAAiBA,EACxDU,EAAIC,MAAM,8CAA8CF,+BACxD,MAAM,IAAIG,MAAM,2CACjB,CACD,CACD,EAOAC,oBAAqB,SAAUC,GAC9B,MAAMd,EAAqD,CAC1DM,UAAW,MAEZN,EAAQ,cAAgBc,aAAiBC,EAAUD,EAAMlI,YAAckI,EACvE,OAAOb,KAAKO,UAAUR,EACvB,EASAgB,gBAAiB,SAAUF,GAC1BA,SAAeA,IAAU,SAAWb,KAAKC,MAAMY,GAASA,EACxD,GAAIA,GAASA,EAAMG,eAAe,cAAe,CAChD,OAAQH,EAAoD,aAC7D,CACA,OAAOA,CACR,EACAI,eAAgB,SAAUC,EAAiBpI,GAC1C,MAAM4B,EAAQ5B,GAAcA,EAAWE,SAAWF,EAAWE,QAAQG,UACrE,OAAOuB,EAAMA,EAAMS,OAAS,KAAO,IAAMT,EAAMW,MAAM,GAAI,GAAKX,CAC/D,EAUAyG,kBAAmB,SAClB/E,EACAgF,EACAC,GAEA,GACCD,GACA5I,EAAa8I,iCAAiCD,IAC9CD,EAAqBG,UACpB,CACD,MAAMC,EAA0E,CAC/EC,QAAS,IAGV,MAAMC,EAActF,EAASjD,QAAQ,GAAG6B,MAAM,KAAK,GACnDoG,EAAqBG,UAAUI,QAAQ,WAA2B,IAAjBC,EAAUlD,UAAAvD,OAAA,GAAAuD,UAAA,KAAA1E,UAAA0E,UAAA,GAAG,CAAC,EAC9D,IAAImD,EACJ,MAAMC,EAAmD,CAAC,EAC1D,GAAIF,EAAWG,gBAAiB,CAC/BF,EAAgBzF,EAASnD,SAAS,GAAGN,UAAU+I,EAAcE,EAAWG,gBAAgBC,kBAAkBC,IAC3G,MAAO,GAAIL,EAAWM,SAAU,CAC/BL,EAAgBD,EAAWM,SAASC,aACrC,CACA,GAAIN,EAAe,CAClBC,EAAQM,KAAOP,EACfC,EAAQO,aAAeT,EAAWU,WAClCd,EAAgBC,QAAQc,KAAKT,EAC9B,KAAO,CACN,MAAM,IAAInB,MAAM,oDACjB,CACD,GACA,OAAOX,KAAKO,UAAUiB,EACvB,CACA,OAAOxH,SACR,EACAsH,iCAAkC,SAAUkB,GAC3C,OACCA,EAAe5K,SAAS,yDACxB4K,EAAe5K,SAAS,gEAE1B,EACA6K,8BAA+B,SAAUC,GACxC,MAAMC,EAASD,EAAqBvJ,UAAU6B,MAAM,MAAQ,GAC5D,MAAMjC,EAAS2J,EAAqBzJ,WACpC,GAAI0J,EAAOxH,QAAUwH,EAAOA,EAAOxH,OAAS,GAAGvD,SAAS,2DAA4D,CACnH,MAAM8C,EAAQgI,EAAqBvJ,UAAU6B,MAAM,wBAAwB,GAC3E,OAAOjC,EAAO6J,qBAAqB,GAAGlI,eACvC,CACA,OAAO3B,EAAO6J,qBAAqB,GAAGF,EAAqBvJ,uBAC5D,EACA0J,kCAAmC,SAClCrH,EACAsH,EACAC,GAEqB,IADrBC,EAActE,UAAAvD,OAAA,GAAAuD,UAAA,KAAA1E,UAAA0E,UAAA,GAAG,MAEjB,IAAKlD,EAAY,OAAOxB,UACxB,MAAMiJ,EAMF,CACHC,mBAAoBJ,EAAWA,EAAW,oCAE3C,GAAItH,EAAW2H,kBAAoB3H,EAAW4H,QAAUL,EAAiC,CACxF,MAAMM,GAAsBL,EAAiB,cAAgB,4BAC7D,MAAMM,GAAyBN,EAAiB,iBAAmB,+BACnEC,EAAsBM,mBAAqB,mBAAmB/H,EAAWgI,kBAAkBhI,EAAWiI,UAAUJ,MAChHJ,EAAsBS,sBAAwB,mBAAmBlI,EAAWgI,kBAAkBhI,EAAWiI,UAAUH,MACnHL,EAAsBU,MAAQtG,KAAKa,gBAAgB1C,EAAWoI,MAAiB,KAChF,CACA,GAAIpI,EAAWqI,QAAS,CACvBZ,EAAsBa,sBAAwBzG,KAAKa,gBAAgB8B,KAAKO,UAAU/E,EAAWqI,SAC9F,CACA,OAAOxG,KAAKiB,iBACXyE,EAAkC,yDAA2D,mCAC7F1F,KAAKa,gBAAgB1C,EAAWgI,gBAChCnG,KAAKa,gBAAgB1C,EAAWiI,QAChCpG,KAAKgC,eAAe4D,GACpB,eAEF,EACAc,aAAc,SAAU3H,GACvB,MAAM1B,EAAQ0B,EAASjD,UACvB,OAAO6K,EAAYC,iBAAiBvJ,EACrC,EAyCAwJ,iCAAkC,SACjCC,EACAhG,EACAiG,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAqDpM,EAAWqM,QAEpExG,EAAS,IAAIA,IAGbiG,EAAgBA,IAAkBQ,SAClCP,EAAgBA,GAAiBD,EACjCE,EAAiBA,GAAkBD,EACnCI,EAAiBA,GAAkBG,SACnCJ,EAAiBA,GAAkBC,EACnCF,EAAkBA,GAAmBC,EAGrCJ,EAAgBA,KAAmBA,GAAiBA,EAAgB,IAAIA,KACxEC,EAAgBA,KAAmBA,GAAiBA,EAAgB,IAAIA,KACxEC,EAAiBA,KAAoBA,GAAkBA,EAAiB,IAAIA,KAC5EC,EAAkBA,KAAqBA,GAAmBA,EAAkB,IAAIA,KAChFC,EAAiBA,KAAoBA,GAAkBA,EAAiB,IAAIA,KAC5EC,EAAiBA,KAAoBA,GAAkBA,EAAiB,IAAIA,KAG5E,GAAIN,EAAsBvM,SAAS,YAAa,CAC/C8M,EACC,MACAvG,EACA,OACAoG,EACA,OACAjM,EAAWuM,KACX,OACA1G,EACA,OACAqG,EACA,OACAlM,EAAWqM,QACX,OACA,IACAF,EACA,OACAtG,EACA,OACAsG,EACA,QACAnM,EAAWwM,SACX,QACAxM,EAAWqI,MACX,KACF,MAAO,GAAIwD,EAAsBvM,SAAS,YAAa,CACtD8M,EACC,MACAvG,EACA,OACAmG,EACA,OACAhM,EAAWuM,KACX,OACA1G,EACA,OACAkG,EACA,OACA/L,EAAWqM,QACX,OACA,IACAP,EACA,OACAjG,EACA,OACAiG,EACA,QACA9L,EAAWwM,SACX,QACAxM,EAAWqI,MACX,KACF,MAAO,GAAIwD,EAAsBvM,SAAS,UAAW,CACpD8M,EACC,OACAvG,EACA,OACAoG,EACA,OACApG,EACA,OACAmG,EACA,QACAhM,EAAWuM,KACX,OACA,KACA1G,EACA,OACAkG,EACA,OACAlG,EACA,MACAmG,EACA,SACAnG,EACA,MACAoG,EACA,OACApG,EACA,OACAqG,EACA,SACAlM,EAAWqM,QACX,OACA,KACAP,EACA,QACAjG,EACA,OACAiG,EACA,SACAjG,EACA,MACAkG,EACA,WACAlG,EACA,MACAqG,EACA,QACAC,EACA,QACAtG,EACA,OACAsG,EACA,UACAnM,EAAWwM,SACX,QACAxM,EAAWqI,MACX,KACF,KAAO,CACNF,EAAIsE,QAAQ,0DACb,CAEA,OAAOL,CACR,EAQAM,yBAA0B,SAAUC,EAAkBC,EAAiDC,GACtG,IAAIC,EAAWC,EACf,GAAIH,GAAmBI,UAAUnK,QAAU+J,GAAmBI,UAAUnK,OAAS,EAAG,CACnFiK,EAAYF,EAAkBI,SAC9BD,EAAuBF,EACnBC,EAAUH,GAA2BM,MAC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","ignoreList":[]}