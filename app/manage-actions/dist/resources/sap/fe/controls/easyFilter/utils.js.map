{"version":3,"file":"utils.js","names":["resourceBundle","Lib","getResourceBundleFor","dateTimeOffset","DateTimeOffset","areItemsSame","arr1","arr2","length","i","operator","selectedValues","every","value","index","deepEqual","description","areArraySame","async","areCodeListsSame","arrNew1","getCodeListArray","arrNew2","descriptionNew1","map","data","descriptionNew2","value1","value2","arr","convertDateToString","tokenType","isDateTimeOffset","formattedDateTime","formatValue","DateFormat","getDateInstance","format","getTimeInstance","mapOperator","newValue","convertBoolToString","Date","FilterOperator","GT","LT","GE","LE","EQ","Contains","EndsWith","StartsWith","NE","NotContains","NotEndsWith","NotStartsWith","toString","mapOperatorForValueHelp","mapOperatorForBetweenOperator","values","newValue1","newValue2","BT","isBetweenSelectedValues","NB","getText","formatData","tokens","filterValues","filterBarMetadata","visitedMapForMandatoryTokens","filterValue","filterCriteria","find","field","name","type","tokenIndex","findIndex","token","key","keySpecificSelectedValues","EasyFilterUtils","newToken","label","busy","push","currentToken","isRequired"],"sources":["./utils.ts"],"sourcesContent":["import type { PrimitiveType } from \"@sap-ux/vocabularies-types/Edm\";\nimport deepEqual from \"sap/base/util/deepEqual\";\nimport Lib from \"sap/ui/core/Lib\";\nimport DateFormat from \"sap/ui/core/format/DateFormat\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport DateTimeOffset from \"sap/ui/model/odata/type/DateTimeOffset\";\nimport type { EasyFilterResult, PropertyMetadata } from \"ux/eng/fioriai/reuse/easyfilter/EasyFilter\";\nimport type {\n\tBetweenSelectedValues,\n\tCodeListType,\n\tEasyFilterPropertyMetadata,\n\tTokenDefinition,\n\tTokenSelectedValuesDefinition,\n\tTokenType,\n\tValueHelpBetweenSelectedValues,\n\tValueHelpSelectedValuesDefinition\n} from \"./EasyFilterBarContainer\";\n\ntype codeListType = PropertyMetadata[\"codeList\"];\ntype finalCodeListType = { value: PrimitiveType; description?: string }[];\nconst resourceBundle = Lib.getResourceBundleFor(\"sap.fe.controls\")!;\nconst dateTimeOffset = new DateTimeOffset();\n\nfunction areItemsSame(\n\tarr1: readonly TokenSelectedValuesDefinition[] | ValueHelpSelectedValuesDefinition[],\n\tarr2: readonly TokenSelectedValuesDefinition[] | ValueHelpSelectedValuesDefinition[]\n): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\t// Compare elements of both arrays\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (\n\t\t\tarr1[i].operator !== arr2[i].operator ||\n\t\t\t!arr1[i].selectedValues.every(\n\t\t\t\t(value, index) =>\n\t\t\t\t\tvalue === arr2[i].selectedValues[index] ||\n\t\t\t\t\t(typeof value === \"object\" &&\n\t\t\t\t\t\tdeepEqual((value as CodeListType).value, (arr2[i].selectedValues[index] as CodeListType).value) &&\n\t\t\t\t\t\t(value as CodeListType).description === (arr2[i].selectedValues[index] as CodeListType).description)\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true; // Arrays are the same\n}\n\nfunction areArraySame(arr1: readonly unknown[], arr2: readonly unknown[]): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\t// Compare elements of both arrays\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true; // Arrays are the same\n}\n\nasync function areCodeListsSame(arr1: codeListType, arr2: codeListType): Promise<boolean> {\n\tconst arrNew1: finalCodeListType | undefined = await getCodeListArray(arr1);\n\tconst arrNew2: finalCodeListType | undefined = await getCodeListArray(arr2);\n\tconst descriptionNew1 = arrNew1?.map((data) => data.description);\n\tconst descriptionNew2 = arrNew2?.map((data) => data.description);\n\n\tconst value1 = arrNew1?.map((data) => data.value);\n\tconst value2 = arrNew2?.map((data) => data.value);\n\tif (!descriptionNew1 || !descriptionNew2) {\n\t\treturn false;\n\t}\n\treturn areArraySame(descriptionNew1, descriptionNew2) && areArraySame(value1 as PrimitiveType, value2 as PrimitiveType);\n}\n\nasync function getCodeListArray(arr: codeListType): Promise<finalCodeListType | undefined> {\n\tif (typeof arr === \"function\") {\n\t\treturn arr();\n\t}\n\treturn arr;\n}\n\nfunction convertDateToString(value: Date, tokenType: TokenType, isDateTimeOffset: boolean): string {\n\tlet formattedDateTime = \"\";\n\tif (isDateTimeOffset) {\n\t\treturn dateTimeOffset.formatValue(value, \"string\") as string;\n\t}\n\tswitch (tokenType) {\n\t\tcase \"Calendar\":\n\t\t\tformattedDateTime = DateFormat.getDateInstance().format(value);\n\t\t\tbreak;\n\t\tcase \"Time\":\n\t\t\tformattedDateTime = DateFormat.getTimeInstance().format(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn formattedDateTime;\n}\n\n/**\n * Create a string representation of the operator and value.\n * @param operator The operator to represent\n * @param value The value to represent\n * @param tokenType The token's type\n * @param isDateTimeOffset Checks if the data type is of DateTimeOffset\n * @returns The string representation of the operator and value\n */\nfunction mapOperator(\n\toperator: FilterOperator,\n\tvalue: string | number | boolean | Date,\n\ttokenType: TokenType,\n\tisDateTimeOffset: boolean\n): string {\n\tlet newValue: number | string = \"\";\n\tif (typeof value === \"boolean\") {\n\t\tnewValue = convertBoolToString(value);\n\t} else if (value instanceof Date) {\n\t\tnewValue = convertDateToString(value, tokenType, isDateTimeOffset);\n\t} else {\n\t\tnewValue = value;\n\t}\n\n\tswitch (operator) {\n\t\tcase FilterOperator.GT:\n\t\t\treturn `> ${newValue}`;\n\t\tcase FilterOperator.LT:\n\t\t\treturn `< ${newValue}`;\n\t\tcase FilterOperator.GE:\n\t\t\treturn `>= ${newValue}`;\n\t\tcase FilterOperator.LE:\n\t\t\treturn `<= ${newValue}`;\n\t\tcase FilterOperator.EQ:\n\t\t\treturn `${newValue}`;\n\t\tcase FilterOperator.Contains:\n\t\t\treturn `*${newValue}*`;\n\t\tcase FilterOperator.EndsWith:\n\t\t\treturn `*${newValue}`;\n\t\tcase FilterOperator.StartsWith:\n\t\t\treturn `${newValue}*`;\n\t\tcase FilterOperator.NE:\n\t\t\treturn `!=(${newValue})`;\n\t\tcase FilterOperator.NotContains:\n\t\t\treturn `!(*${newValue}*)`;\n\t\tcase FilterOperator.NotEndsWith:\n\t\t\treturn `!(*${newValue})`;\n\t\tcase FilterOperator.NotStartsWith:\n\t\t\treturn `!(${newValue}*)`;\n\t\tdefault:\n\t\t\treturn newValue?.toString();\n\t}\n}\n\nfunction mapOperatorForValueHelp(operator: FilterOperator, value: CodeListType, tokenType: TokenType, isDateTimeOffset: boolean): string {\n\treturn mapOperator(operator, value.description, tokenType, isDateTimeOffset);\n}\n\nfunction mapOperatorForBetweenOperator(\n\toperator: FilterOperator,\n\tvalues: BetweenSelectedValues | ValueHelpBetweenSelectedValues,\n\ttokenType: TokenType,\n\tisDateTimeOffset: boolean\n): string {\n\tlet newValue1: string | number | Date = \"\";\n\tlet newValue2: string | number | Date = \"\";\n\tif (typeof values[0] === \"boolean\") {\n\t\tnewValue1 = convertBoolToString(values[0]);\n\t} else if (values[0] instanceof Date) {\n\t\tnewValue1 = convertDateToString(values[0], tokenType, isDateTimeOffset);\n\t} else if (typeof values[0] === \"object\") {\n\t\tnewValue1 = values[0].description as string;\n\t} else {\n\t\tnewValue1 = values[0];\n\t}\n\n\tif (typeof values[1] === \"boolean\") {\n\t\tnewValue2 = convertBoolToString(values[1]);\n\t} else if (values[1] instanceof Date) {\n\t\tnewValue2 = convertDateToString(values[1], tokenType, isDateTimeOffset);\n\t} else if (typeof values[0] === \"object\") {\n\t\tnewValue2 = values[1].description as string;\n\t} else {\n\t\tnewValue2 = values[1];\n\t}\n\tif (operator === FilterOperator.BT) {\n\t\treturn `${newValue1}...${newValue2}`;\n\t} else {\n\t\treturn `!(${newValue1}...${newValue2})`;\n\t}\n}\n\nfunction isBetweenSelectedValues(operator: FilterOperator): boolean {\n\treturn operator === FilterOperator.BT || operator === FilterOperator.NB;\n}\n\nfunction convertBoolToString(value: boolean): string {\n\treturn value\n\t\t? resourceBundle.getText(\"M_EASY_FILTER_SELECTED_VALUES_TRUE\")\n\t\t: resourceBundle.getText(\"M_EASY_FILTER_SELECTED_VALUES_FALSE\");\n}\n\nfunction formatData(\n\ttokens: TokenDefinition[],\n\tfilterValues: EasyFilterResult[\"filter\"],\n\tfilterBarMetadata: EasyFilterPropertyMetadata[]\n): void {\n\tif (filterValues) {\n\t\tconst visitedMapForMandatoryTokens: Record<string, boolean> = {};\n\t\tfor (const filterValue of filterValues) {\n\t\t\tconst filterCriteria = filterBarMetadata.find((field) => field.name === filterValue.name);\n\t\t\tif (filterCriteria) {\n\t\t\t\tconst { type } = filterCriteria;\n\t\t\t\tconst tokenIndex = tokens.findIndex((token) => token.key === filterValue.name);\n\t\t\t\tconst { operator, values } = filterValue;\n\t\t\t\tlet keySpecificSelectedValues: TokenSelectedValuesDefinition;\n\t\t\t\tif (EasyFilterUtils.isBetweenSelectedValues(operator)) {\n\t\t\t\t\tkeySpecificSelectedValues = {\n\t\t\t\t\t\toperator,\n\t\t\t\t\t\tselectedValues: values as BetweenSelectedValues\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tkeySpecificSelectedValues = {\n\t\t\t\t\t\toperator: operator as Exclude<FilterOperator, FilterOperator.BT | FilterOperator.NB>,\n\t\t\t\t\t\tselectedValues: values as string[] | Date[] | number[] | boolean[]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (tokenIndex === -1) {\n\t\t\t\t\t// Add new token if it doesn't exist\n\t\t\t\t\tconst newToken: TokenDefinition = {\n\t\t\t\t\t\tkey: filterValue.name,\n\t\t\t\t\t\tlabel: filterCriteria.label as string,\n\t\t\t\t\t\tkeySpecificSelectedValues: [keySpecificSelectedValues],\n\t\t\t\t\t\ttype: type as Exclude<TokenType, \"ValueHelp\">,\n\t\t\t\t\t\tbusy: type === \"ValueHelp\" ? true : false\n\t\t\t\t\t};\n\t\t\t\t\ttokens.push(newToken);\n\t\t\t\t} else {\n\t\t\t\t\t// Update existing token\n\t\t\t\t\tconst currentToken = tokens[tokenIndex];\n\t\t\t\t\t//If its default value , override it\n\t\t\t\t\tif ((currentToken.isRequired ?? false) && !visitedMapForMandatoryTokens[currentToken.key]) {\n\t\t\t\t\t\tcurrentToken.keySpecificSelectedValues = [keySpecificSelectedValues];\n\t\t\t\t\t\tvisitedMapForMandatoryTokens[currentToken.key] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(currentToken.keySpecificSelectedValues as TokenSelectedValuesDefinition[]).push(keySpecificSelectedValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst EasyFilterUtils = {\n\tareItemsSame,\n\tareCodeListsSame,\n\tgetCodeListArray,\n\tareArraySame,\n\tmapOperator,\n\tmapOperatorForBetweenOperator,\n\tisBetweenSelectedValues,\n\tformatData,\n\tmapOperatorForValueHelp\n};\n\nexport default EasyFilterUtils;\n"],"mappings":"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","ignoreList":[]}