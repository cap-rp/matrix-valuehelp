{"version":3,"file":"library-preload.js","sections":[{"offset":{"line":1,"column":0},"map":{"version":3,"names":["ENUM_VALUES","Mandatory","Optional","ReadOnly","Inapplicable","Disabled","resolveEnumValue","enumName","termName","value","split","hasOwnProperty","_exports"],"sources":["./AnnotationEnum.ts"],"sourcesContent":["// This list needs to come from AVT\nconst ENUM_VALUES: Record<string, Record<string, unknown>> = {\n\t\"com.sap.vocabularies.Common.v1.FieldControlType\": {\n\t\tMandatory: 7,\n\t\tOptional: 3,\n\t\tReadOnly: 0,\n\t\tInapplicable: 0,\n\t\tDisabled: 1\n\t}\n};\nexport const resolveEnumValue = function (enumName: string | undefined): unknown {\n\tif (!enumName) {\n\t\treturn false;\n\t}\n\tconst [termName, value] = enumName.split(\"/\");\n\tif (ENUM_VALUES.hasOwnProperty(termName)) {\n\t\treturn ENUM_VALUES[termName][value];\n\t} else {\n\t\treturn false;\n\t}\n};\n"],"mappings":"AAAA;;;;mFACA,MAAMA,EAAuD,CAC5D,kDAAmD,CAClDC,UAAW,EACXC,SAAU,EACVC,SAAU,EACVC,aAAc,EACdC,SAAU,IAGL,MAAMC,EAAmB,SAAUC,GACzC,IAAKA,EAAU,CACd,OAAO,KACR,CACA,MAAOC,EAAUC,GAASF,EAASG,MAAM,KACzC,GAAIV,EAAYW,eAAeH,GAAW,CACzC,OAAOR,EAAYQ,GAAUC,EAC9B,KAAO,CACN,OAAO,KACR,CACD,EAAEG,EAAAN,mBAAA,OAAAM,CAAA","ignoreList":[],"sourceRoot":""}},{"offset":{"line":6,"column":0},"map":{"version":3,"names":["isProperty","serviceObject","_type","_exports","EDM_TYPE_MAPPING","type","constraints","$Precision","$V4","$Scale","$MaxLength","$Nullable","unresolvableExpression","escapeXmlAttribute","inputString","replace","hasUnresolvableExpression","_len","arguments","length","expressions","Array","_key","find","expr","undefined","_checkExpressionsAreEqual","a","b","value","operand","operator","operands","every","expression","some","otherExpression","condition","onTrue","onFalse","operand1","operand2","aExpressions","bExpressions","index","pathInModel","modelName","path","targetEntitySet","fn","parameters","bindingParameters","otherFunction","obj","ref","flattenSetExpression","reduce","result","candidatesForFlattening","forEach","candidate","e","push","hasOppositeExpressions","negatedExpressions","map","not","i","and","_len2","_key2","wrapPrimitive","isStaticFalse","nonTrivialExpression","filter","isFalse","isConstant","constant","isValid","isTrue","or","_len3","_key3","isStaticTrue","isComparison","isTruthy","bindingExpression","visitedNavigationPaths","pathVisitor","targetPath","localPath","concat","join","constantValue","isArray","isPrimitiveObject","valueOf","Object","entries","plainExpression","_ref","key","val","wrappedValue","resolveBindingString","targetType","startsWith","pathInModelRegex","pathInModelRegexMatch","exec","isNaN","Number","reference","bindState","stateObjectProp","__bindingInfo","toString","model","something","isBindingToolkitExpression","maybeConstant","isPathInModelExpression","maybeBinding","isComplexTypeExpression","isConcatExpression","isIfElseExpression","isUndefinedExpression","expressionAsExpression","objectType","constructor","name","isComplexAnnotationExpression","annotationValue","getExpressionFromAnnotation","defaultValue","annotationIfExpression","$If","parseAnnotationCondition","$Not","equal","$Eq","notEqual","$Ne","greaterThan","$Gt","greaterOrEqual","$Ge","lessThan","$Lt","lessOrEqual","$Le","$Or","orCondition","$And","andCondition","annotationApplyExpression","hasOwnProperty","$Path","$Function","$Apply","resolveEnumValue","$EnumMember","ifElse","convertSubApplyParameters","applyParam","applyParamConverted","applyExpression","parameter","template","templateParams","slice","targetObject","$Name","$LabeledElement","comparison","leftOperand","rightOperand","leftExpression","rightExpression","checkUndefined","left","right","reduced","conditionExpression","onTrueExpression","onFalseExpression","pathIdx","myIfElseExpression","formatResult","allParts","transformRecursively","constantPath","unshift","JSON","stringify","hasReferenceToDefaultContext","formatterFunction","contextEntityType","ignoreComplexType","parameterExpressions","keys","functionName","__functionName","formatterClass","formatterName","split","myFormatExpression","setUpConstraints","targetMapping","property","scale","precision","maxLength","nullable","annotations","Validation","Minimum","minimum","Maximum","maximum","Common","IsDigitSequence","isDigitSequence","V4","formatWithTypeInformation","propertyBindingExpression","ignoreConstraints","outExpression","formatOptions","indexOf","assign","parseAsString","parseKeepsEmptyString","fiscalType","getFiscalType","typesSupportingParseEmptyValueToZero","includes","parseEmptyValueToZero","emptyString","IsFiscalYear","IsFiscalPeriod","IsFiscalYearPeriod","IsFiscalQuarter","IsFiscalYearQuarter","IsFiscalWeek","IsFiscalYearWeek","IsDayOfFiscalYear","addTypeInformation","oFormatOptions","oConstraintOptions","_getComplexTypeFormatOptionsFromFirstParam","uomPath","mode","preserveDecimals","skipDecimalsValidation","currencyPath","param","showNumber","showMeasure","decimalPadding","func","on","isFormattingFn","isEmpty","aBindings","finalExpression","alwaysKeepTargetType","_len4","inExpressions","_key4","concatenated","myConcatExpression","inExpression","expressionType","transformFunction","includeAllExpression","subExpression","bindingParameter","needParenthesis","compileConstantObject","isNullable","objects","properties","childResult","compileExpression","compileConstant","embeddedInBinding","doNotStringify","compilePathInModelExpression","expressionForBinding","embeddedSeparator","complexBindingDefinition","compilePathInModel","outBinding","separator","compileComplexTypeExpression","compilePathParameter","outputEnd","hasElements","wrapBindingExpression","parenthesisRequired","keepTargetType","hasEmbeddedFunctionCallOrBinding","subFn","subSubFn","argumentString","arg","fnCall","substring","comparisonExpression","compileComparisonExpression","ifElseExpression","setExpression","concatExpression","nestedExpression","lengthExpression","notExpression","truthyExpression","formatterExpression","compileFormatterExpression","complexTypeExpression","compileOperand","compiledOperand","parts","singlePath","outValue"],"sources":["./BindingToolkit.ts"],"sourcesContent":["import type {\n\tActionParameter,\n\tAndAnnotationExpression,\n\tAndConditionalExpression,\n\tApplyAnnotationExpression,\n\tBoolean,\n\tConditionalCheckOrValue,\n\tEntitySet,\n\tEntityType,\n\tEqAnnotationExpression,\n\tEqConditionalExpression,\n\tGeAnnotationExpression,\n\tGeConditionalExpression,\n\tGtAnnotationExpression,\n\tGtConditionalExpression,\n\tIfAnnotationExpression,\n\tIfAnnotationExpressionValue,\n\tLeAnnotationExpression,\n\tLeConditionalExpression,\n\tLtAnnotationExpression,\n\tLtConditionalExpression,\n\tNeAnnotationExpression,\n\tNeConditionalExpression,\n\tNotAnnotationExpression,\n\tNotConditionalExpression,\n\tOrAnnotationExpression,\n\tOrConditionalExpression,\n\tPathAnnotationExpression,\n\tPathConditionExpression,\n\tProperty,\n\tPropertyAnnotationValue,\n\tConstantExpression as VocabConstantExpression\n} from \"@sap-ux/vocabularies-types\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { resolveEnumValue } from \"sap/fe/base/AnnotationEnum\";\nimport type { BindingInfoHolder } from \"sap/fe/base/ClassSupport\";\n\nexport type PrimitiveType = string | number | bigint | boolean | object | null | undefined;\ntype DefinedPrimitiveType = string | number | bigint | boolean | object;\ntype PrimitiveTypeCast<P> = P extends String ? string : P extends Boolean ? boolean : P extends Number ? number : P;\ntype BaseExpression<_T> = {\n\t_type: string;\n};\n\nexport type FormatOptions = Partial<{\n\tcustomUnits: Record<string, object>;\n\tcustomCurrencies: Record<string, object>;\n\tdecimals: number;\n\temptyString: null | number | string;\n\tfiscalType: string;\n\tgroupingEnabled: boolean;\n\tmaxFractionDigits: number;\n\tmaxIntegerDigits: number;\n\tminFractionDigits: number;\n\tminIntegerDigits: number;\n\tparseAsString: boolean;\n\tparseKeepsEmptyString: boolean;\n\tpattern: string;\n\tprecision: number;\n\tpreserveDecimals: boolean;\n\tshortDecimals: number;\n\tshortRefNumber: number;\n\tshowMeasure: boolean;\n\tshowNumber: boolean;\n\tshowScale: boolean;\n\tstyle: string;\n}>;\n\nexport type ConstantExpression<T> = BaseExpression<T> & {\n\t_type: \"Constant\";\n\tvalue: T;\n};\n\ntype SetOperator = \"&&\" | \"||\";\nexport type SetExpression = BaseExpression<boolean> & {\n\t_type: \"Set\";\n\toperator: SetOperator;\n\toperands: BindingToolkitExpression<boolean>[];\n};\n\nexport type NotExpression = BaseExpression<boolean> & {\n\t_type: \"Not\";\n\toperand: BindingToolkitExpression<boolean>;\n};\n\nexport type TruthyExpression = BaseExpression<boolean> & {\n\t_type: \"Truthy\";\n\toperand: BindingToolkitExpression<string>;\n};\n\nexport type ReferenceExpression = BaseExpression<object> & {\n\t_type: \"Ref\";\n\tref: string | null;\n};\n\nexport type FormatterExpression<T> = BaseExpression<T> & {\n\t_type: \"Formatter\";\n\tfn: string;\n\tparameters: BindingToolkitExpression<unknown>[];\n};\n\ntype ComplexTypeExpression<T> = BaseExpression<T> & {\n\t_type: \"ComplexType\";\n\ttype: string;\n\tformatOptions: FormatOptions;\n\tconstraints: object;\n\tparameters: object;\n\tbindingParameters: BindingToolkitExpression<unknown>[];\n};\n\nexport type FunctionExpression<T> = BaseExpression<T> & {\n\t_type: \"Function\";\n\tobj?: BindingToolkitExpression<object>;\n\tfn: string;\n\tisFormattingFn: boolean;\n\tparameters: BindingToolkitExpression<unknown>[];\n};\n\nexport type ConcatExpression = BaseExpression<string> & {\n\t_type: \"Concat\";\n\texpressions: BindingToolkitExpression<string>[];\n};\n\nexport type LengthExpression = BaseExpression<string> & {\n\t_type: \"Length\";\n\tpathInModel: PathInModelExpression<unknown>;\n};\n\ntype UnresolvablePathExpression = BaseExpression<string> & {\n\t_type: \"Unresolvable\";\n};\n\n/**\n * @typedef PathInModelExpression\n */\nexport type PathInModelExpression<T> = BaseExpression<T> & {\n\t_type: \"PathInModel\";\n\tmodelName?: string;\n\tpath: string;\n\ttargetEntitySet?: EntitySet;\n\ttype?: string;\n\tconstraints?: BindingConstraints;\n\tparameters?: object;\n\ttargetType?: string;\n\tmode?: string;\n\tformatOptions?: FormatOptions;\n\talwaysKeepTargetType?: boolean;\n};\n\nexport type EmbeddedUI5BindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedBinding\";\n\tvalue: string;\n};\n\nexport type EmbeddedUI5ExpressionBindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedExpressionBinding\";\n\tvalue: string;\n};\n\nexport type ComparisonOperator = \"===\" | \"!==\" | \">=\" | \">\" | \"<=\" | \"<\";\nexport type ComparisonExpression = BaseExpression<boolean> & {\n\t_type: \"Comparison\";\n\toperator: ComparisonOperator;\n\toperand1: BindingToolkitExpression<unknown>;\n\toperand2: BindingToolkitExpression<unknown>;\n};\n\nexport type IfElseExpression<T> = BaseExpression<T> & {\n\t_type: \"IfElse\";\n\tcondition: BindingToolkitExpression<boolean>;\n\tonTrue: BindingToolkitExpression<T>;\n\tonFalse: BindingToolkitExpression<T>;\n};\nexport function isProperty(serviceObject: unknown): serviceObject is Property {\n\treturn (serviceObject as Property)?._type === \"Property\";\n}\n\n/**\n * An expression that evaluates to type T.\n * @typedef BindingToolkitExpression\n */\nexport type BindingToolkitExpression<T> =\n\t| UnresolvablePathExpression\n\t| ConstantExpression<T>\n\t| SetExpression\n\t| NotExpression\n\t| TruthyExpression\n\t| ConcatExpression\n\t| LengthExpression\n\t| PathInModelExpression<T>\n\t| EmbeddedUI5BindingExpression<T>\n\t| EmbeddedUI5ExpressionBindingExpression<T>\n\t| ComparisonExpression\n\t| IfElseExpression<T>\n\t| FormatterExpression<T>\n\t| ComplexTypeExpression<T>\n\t| ReferenceExpression\n\t| FunctionExpression<T>;\n\ntype TypeMappingDefinition = {\n\ttype: string;\n\tconstraints?: {\n\t\t$Precision?: string;\n\t\t$V4?: string;\n\t\t$Scale?: string;\n\t\t$MaxLength?: string;\n\t\t$Nullable?: string;\n\t\t\"@Org.OData.Validation.V1.Minimum/$Decimal\"?: string;\n\t\t\"@Org.OData.Validation.V1.Minimum@Org.OData.Validation.V1.Exclusive\"?: string;\n\t\t\"@Org.OData.Validation.V1.Maximum/$Decimal\"?: string;\n\t\t\"@Org.OData.Validation.V1.Maximum@Org.OData.Validation.V1.Exclusive\"?: string;\n\t\t\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"?: string;\n\t};\n};\nexport const EDM_TYPE_MAPPING: Record<string, TypeMappingDefinition> = {\n\t\"Edm.Boolean\": { type: \"sap.ui.model.odata.type.Boolean\" },\n\t\"Edm.Byte\": { type: \"sap.ui.model.odata.type.Byte\" },\n\t\"Edm.Date\": { type: \"sap.ui.model.odata.type.Date\" },\n\t\"Edm.DateTimeOffset\": {\n\t\tconstraints: {\n\t\t\t$Precision: \"precision\",\n\t\t\t$V4: \"V4\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.DateTimeOffset\"\n\t},\n\t\"Edm.Decimal\": {\n\t\tconstraints: {\n\t\t\t\"@Org.OData.Validation.V1.Minimum/$Decimal\": \"minimum\",\n\t\t\t\"@Org.OData.Validation.V1.Minimum@Org.OData.Validation.V1.Exclusive\": \"minimumExclusive\",\n\t\t\t\"@Org.OData.Validation.V1.Maximum/$Decimal\": \"maximum\",\n\t\t\t\"@Org.OData.Validation.V1.Maximum@Org.OData.Validation.V1.Exclusive\": \"maximumExclusive\",\n\t\t\t$Precision: \"precision\",\n\t\t\t$Scale: \"scale\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.Decimal\"\n\t},\n\t\"Edm.Double\": { type: \"sap.ui.model.odata.type.Double\" },\n\t\"Edm.Guid\": { type: \"sap.ui.model.odata.type.Guid\" },\n\t\"Edm.Int16\": { type: \"sap.ui.model.odata.type.Int16\" },\n\t\"Edm.Int32\": { type: \"sap.ui.model.odata.type.Int32\" },\n\t\"Edm.Int64\": { type: \"sap.ui.model.odata.type.Int64\" },\n\t\"Edm.SByte\": { type: \"sap.ui.model.odata.type.SByte\" },\n\t\"Edm.Single\": { type: \"sap.ui.model.odata.type.Single\" },\n\t\"Edm.Stream\": { type: \"sap.ui.model.odata.type.Stream\" },\n\t\"Edm.Binary\": { type: \"sap.ui.model.odata.type.Stream\" },\n\t\"Edm.String\": {\n\t\tconstraints: {\n\t\t\t\"@com.sap.vocabularies.Common.v1.IsDigitSequence\": \"isDigitSequence\",\n\t\t\t$MaxLength: \"maxLength\",\n\t\t\t$Nullable: \"nullable\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.String\"\n\t},\n\t\"Edm.TimeOfDay\": {\n\t\tconstraints: {\n\t\t\t$Precision: \"precision\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.TimeOfDay\"\n\t}\n};\n\n/**\n * An expression that evaluates to type T, or a constant value of type T\n */\nexport type ExpressionOrPrimitive<T extends PrimitiveType> = BindingToolkitExpression<T> | T;\n\nexport const unresolvableExpression: UnresolvablePathExpression = {\n\t_type: \"Unresolvable\"\n};\n\nexport function escapeXmlAttribute(inputString: string): string {\n\treturn inputString.replace(/'/g, \"\\\\'\");\n}\n\nexport function hasUnresolvableExpression(...expressions: BindingToolkitExpression<unknown>[]): boolean {\n\treturn expressions.find((expr) => expr._type === \"Unresolvable\") !== undefined;\n}\n/**\n * Check two expressions for (deep) equality.\n * @param a\n * @param b\n * @returns `true` if the two expressions are equal\n */\nexport function _checkExpressionsAreEqual<T>(a: BindingToolkitExpression<T>, b: BindingToolkitExpression<T>): boolean {\n\tif (a._type !== b._type) {\n\t\treturn false;\n\t}\n\n\tswitch (a._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn false; // Unresolvable is never equal to anything even itself\n\t\tcase \"Constant\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn a.value === (b as ConstantExpression<T>).value;\n\n\t\tcase \"Not\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as NotExpression).operand);\n\t\tcase \"Truthy\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as TruthyExpression).operand);\n\t\tcase \"Set\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as SetExpression).operator &&\n\t\t\t\ta.operands.length === (b as SetExpression).operands.length &&\n\t\t\t\ta.operands.every((expression) =>\n\t\t\t\t\t(b as SetExpression).operands.some((otherExpression) => _checkExpressionsAreEqual(expression, otherExpression))\n\t\t\t\t)\n\t\t\t);\n\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\t_checkExpressionsAreEqual(a.condition, (b as IfElseExpression<T>).condition) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onTrue, (b as IfElseExpression<T>).onTrue) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onFalse, (b as IfElseExpression<T>).onFalse)\n\t\t\t);\n\n\t\tcase \"Comparison\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as ComparisonExpression).operator &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand1, (b as ComparisonExpression).operand1) &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand2, (b as ComparisonExpression).operand2)\n\t\t\t);\n\n\t\tcase \"Concat\":\n\t\t\tconst aExpressions = a.expressions;\n\t\t\tconst bExpressions = (b as ConcatExpression).expressions;\n\t\t\tif (aExpressions.length !== bExpressions.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn aExpressions.every((expression, index) => {\n\t\t\t\treturn _checkExpressionsAreEqual(expression, bExpressions[index]);\n\t\t\t});\n\n\t\tcase \"Length\":\n\t\t\treturn _checkExpressionsAreEqual(a.pathInModel, (b as LengthExpression).pathInModel);\n\n\t\tcase \"PathInModel\":\n\t\t\treturn (\n\t\t\t\ta.modelName === (b as PathInModelExpression<T>).modelName &&\n\t\t\t\ta.path === (b as PathInModelExpression<T>).path &&\n\t\t\t\ta.targetEntitySet === (b as PathInModelExpression<T>).targetEntitySet\n\t\t\t);\n\n\t\tcase \"Formatter\":\n\t\t\treturn (\n\t\t\t\ta.fn === (b as FormatterExpression<T>).fn &&\n\t\t\t\ta.parameters.length === (b as FormatterExpression<T>).parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual((b as FormatterExpression<T>).parameters[index], value))\n\t\t\t);\n\t\tcase \"ComplexType\":\n\t\t\treturn (\n\t\t\t\ta.type === (b as ComplexTypeExpression<T>).type &&\n\t\t\t\ta.bindingParameters.length === (b as ComplexTypeExpression<T>).bindingParameters.length &&\n\t\t\t\ta.bindingParameters.every((value, index) =>\n\t\t\t\t\t_checkExpressionsAreEqual((b as ComplexTypeExpression<T>).bindingParameters[index], value)\n\t\t\t\t)\n\t\t\t);\n\t\tcase \"Function\":\n\t\t\tconst otherFunction = b as FunctionExpression<T>;\n\t\t\tif (a.obj === undefined || otherFunction.obj === undefined) {\n\t\t\t\treturn a.obj === otherFunction;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\ta.fn === otherFunction.fn &&\n\t\t\t\t_checkExpressionsAreEqual(a.obj, otherFunction.obj) &&\n\t\t\t\ta.parameters.length === otherFunction.parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual(otherFunction.parameters[index], value))\n\t\t\t);\n\n\t\tcase \"Ref\":\n\t\t\treturn a.ref === (b as ReferenceExpression).ref;\n\t}\n\treturn false;\n}\n\n/**\n * Converts a nested SetExpression by inlining operands of type SetExpression with the same operator.\n * @param expression The expression to flatten\n * @returns A new SetExpression with the same operator\n */\nfunction flattenSetExpression(expression: SetExpression): SetExpression {\n\treturn expression.operands.reduce(\n\t\t(result: SetExpression, operand) => {\n\t\t\tconst candidatesForFlattening =\n\t\t\t\toperand._type === \"Set\" && operand.operator === expression.operator ? operand.operands : [operand];\n\t\t\tcandidatesForFlattening.forEach((candidate) => {\n\t\t\t\tif (result.operands.every((e) => !_checkExpressionsAreEqual(e, candidate))) {\n\t\t\t\t\tresult.operands.push(candidate);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t{ _type: \"Set\", operator: expression.operator, operands: [] }\n\t);\n}\n\n/**\n * Detects whether an array of boolean expressions contains an expression and its negation.\n * @param expressions Array of expressions\n * @returns `true` if the set of expressions contains an expression and its negation\n */\nfunction hasOppositeExpressions(expressions: BindingToolkitExpression<boolean>[]): boolean {\n\tconst negatedExpressions = expressions.map(not);\n\treturn expressions.some((expression, index) => {\n\t\tfor (let i = index + 1; i < negatedExpressions.length; i++) {\n\t\t\tif (_checkExpressionsAreEqual(expression, negatedExpressions[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n}\n\n/**\n * Logical `and` expression.\n *\n * The expression is simplified to false if this can be decided statically (that is, if one operand is a constant\n * false or if the expression contains an operand and its negation).\n * @param operands Expressions to connect by `and`\n * @returns Expression evaluating to boolean\n */\nexport function and(...operands: ExpressionOrPrimitive<boolean>[]): BindingToolkitExpression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"&&\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticFalse = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isFalse(expression)) {\n\t\t\tisStaticFalse = true;\n\t\t}\n\t\treturn !isConstant(expression);\n\t});\n\tif (isStaticFalse) {\n\t\treturn constant(false);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0];\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(false);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"&&\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `or` expression.\n *\n * The expression is simplified to true if this can be decided statically (that is, if one operand is a constant\n * true or if the expression contains an operand and its negation).\n * @param operands Expressions to connect by `or`\n * @returns Expression evaluating to boolean\n */\nexport function or(...operands: ExpressionOrPrimitive<boolean>[]): BindingToolkitExpression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"||\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticTrue = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isTrue(expression)) {\n\t\t\tisStaticTrue = true;\n\t\t}\n\t\treturn !isConstant(expression) || expression.value;\n\t});\n\tif (isStaticTrue) {\n\t\treturn constant(true);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0];\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(true);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"||\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `not` operator.\n * @param operand The expression to reverse\n * @returns The resulting expression that evaluates to boolean\n */\nexport function not(operand: ExpressionOrPrimitive<boolean>): BindingToolkitExpression<boolean> {\n\toperand = wrapPrimitive(operand);\n\tif (hasUnresolvableExpression(operand)) {\n\t\treturn unresolvableExpression;\n\t} else if (isConstant(operand)) {\n\t\treturn constant(!operand.value);\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"||\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn and(...operand.operands.map((expression) => not(expression)));\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"&&\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn or(...operand.operands.map((expression) => not(expression)));\n\t} else if (isComparison(operand)) {\n\t\t// Create the reverse comparison\n\t\tswitch (operand.operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn { ...operand, operator: \"===\" };\n\t\t\tcase \"<\":\n\t\t\t\treturn { ...operand, operator: \">=\" };\n\t\t\tcase \"<=\":\n\t\t\t\treturn { ...operand, operator: \">\" };\n\t\t\tcase \"===\":\n\t\t\t\treturn { ...operand, operator: \"!==\" };\n\t\t\tcase \">\":\n\t\t\t\treturn { ...operand, operator: \"<=\" };\n\t\t\tcase \">=\":\n\t\t\t\treturn { ...operand, operator: \"<\" };\n\t\t}\n\t} else if (operand._type === \"Not\") {\n\t\treturn operand.operand;\n\t}\n\n\treturn {\n\t\t_type: \"Not\",\n\t\toperand: operand\n\t};\n}\n\n/**\n * Evaluates whether a binding expression is equal to true with a loose equality.\n * @param operand The expression to check\n * @returns The resulting expression that evaluates to boolean\n */\nexport function isTruthy(operand: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> {\n\tif (isConstant(operand)) {\n\t\treturn constant(!!operand.value);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Truthy\",\n\t\t\toperand: operand\n\t\t};\n\t}\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n * @param path\n * @param modelName\n * @param visitedNavigationPaths\n * @param pathVisitor\n * @returns An expression representating that path in the model\n * @deprecated use pathInModel instead\n */\nexport function bindingExpression<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): PathInModelExpression<TargetType> | UnresolvablePathExpression {\n\treturn pathInModel(path, modelName, visitedNavigationPaths, pathVisitor);\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n * @template TargetType\n * @param path The path on the model\n * @param [modelName] The name of the model\n * @param [visitedNavigationPaths] The paths from the root entitySet\n * @param [pathVisitor] A function to modify the resulting path\n * @returns An expression representating that path in the model\n */\nexport function pathInModel(\n\tpath: undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: undefined\n): PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType> {\n\tif (path === undefined) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet targetPath;\n\tif (pathVisitor) {\n\t\ttargetPath = pathVisitor(path);\n\t\tif (targetPath === undefined) {\n\t\t\treturn unresolvableExpression;\n\t\t}\n\t} else {\n\t\tconst localPath = visitedNavigationPaths.concat();\n\t\tlocalPath.push(path);\n\t\ttargetPath = localPath.join(\"/\");\n\t}\n\treturn {\n\t\t_type: \"PathInModel\",\n\t\tmodelName: modelName,\n\t\tpath: targetPath\n\t};\n}\n\ntype PlainExpressionObject = { [index: string]: BindingToolkitExpression<unknown> };\n\n/**\n * Creates a constant expression based on a primitive value.\n * @template T\n * @param value The constant to wrap in an expression\n * @returns The constant expression\n */\nexport function constant<T extends PrimitiveType>(value: T): ConstantExpression<T> {\n\tlet constantValue: T;\n\n\tif (typeof value === \"object\" && value !== null && value !== undefined) {\n\t\tif (Array.isArray(value)) {\n\t\t\tconstantValue = value.map(wrapPrimitive) as T;\n\t\t} else if (isPrimitiveObject(value)) {\n\t\t\tconstantValue = value.valueOf() as T;\n\t\t} else {\n\t\t\tconstantValue = Object.entries(value).reduce((plainExpression, [key, val]) => {\n\t\t\t\tconst wrappedValue = wrapPrimitive(val);\n\t\t\t\tif (wrappedValue._type !== \"Constant\" || wrappedValue.value !== undefined) {\n\t\t\t\t\tplainExpression[key] = wrappedValue;\n\t\t\t\t}\n\t\t\t\treturn plainExpression;\n\t\t\t}, {} as PlainExpressionObject) as T;\n\t\t}\n\t} else {\n\t\tconstantValue = value;\n\t}\n\n\treturn { _type: \"Constant\", value: constantValue };\n}\n\nexport function resolveBindingString<T extends PrimitiveType>(\n\tvalue: string | boolean | number,\n\ttargetType?: string\n): ConstantExpression<T> | PathInModelExpression<T> | EmbeddedUI5BindingExpression<T> | EmbeddedUI5ExpressionBindingExpression<T> {\n\tif (value !== undefined && typeof value === \"string\" && value.startsWith(\"{\")) {\n\t\tconst pathInModelRegex = /^{(.*)>(.+)}$/; // Matches model paths like \"model>path\" or \">path\" (default model)\n\t\tconst pathInModelRegexMatch = pathInModelRegex.exec(value);\n\n\t\tif (value.startsWith(\"{=\")) {\n\t\t\t// Expression binding, we can just remove the outer binding things\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedExpressionBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t} else if (pathInModelRegexMatch) {\n\t\t\treturn pathInModel(pathInModelRegexMatch[2] || \"\", pathInModelRegexMatch[1] || undefined);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\t} else if (targetType === \"boolean\" && typeof value === \"string\" && (value === \"true\" || value === \"false\")) {\n\t\treturn constant(value === \"true\") as ConstantExpression<T>;\n\t} else if (targetType === \"number\" && typeof value === \"string\" && (!isNaN(Number(value)) || value === \"NaN\")) {\n\t\treturn constant(Number(value)) as ConstantExpression<T>;\n\t} else {\n\t\treturn constant(value) as ConstantExpression<T>;\n\t}\n}\n\n/**\n * A named reference.\n * @see fn\n * @param reference Reference\n * @returns The object reference binding part\n */\nexport function ref(reference: string | null): ReferenceExpression {\n\treturn { _type: \"Ref\", ref: reference };\n}\n\n/**\n * Wrap a state object into a path in model expression.\n * @template T\n * @param stateObjectProp The object to evaluate, if it's a constant it will be wrapped in a constant expression, if it's a state property it will be bound\n * @param key The key of the state object to bind\n * @returns The correct binding toolkit expression\n */\nexport function bindState<T extends object, K extends PrimitiveType>(\n\tstateObjectProp: T,\n\tkey: keyof T\n): PathInModelExpression<K> | ConstantExpression<K> {\n\tif (typeof stateObjectProp === \"object\" && (stateObjectProp as BindingInfoHolder<T>).__bindingInfo) {\n\t\treturn pathInModel(\"/\" + key.toString(), (stateObjectProp as BindingInfoHolder<T>).__bindingInfo.model);\n\t} else {\n\t\treturn constant(stateObjectProp) as unknown as ConstantExpression<K>;\n\t}\n}\n/**\n * Wrap a primitive into a constant expression if it is not already an expression.\n * @template T\n * @param something The object to wrap in a Constant expression\n * @returns Either the original object or the wrapped one depending on the case\n */\nexport function wrapPrimitive<T extends PrimitiveType>(something: ExpressionOrPrimitive<T>): BindingToolkitExpression<T> {\n\tif (isBindingToolkitExpression(something)) {\n\t\treturn something as BindingToolkitExpression<T>;\n\t}\n\n\treturn constant(something);\n}\n\n/**\n * Checks if the expression or value provided is a binding tooling expression or not.\n *\n * Every object having a property named `_type` of some value is considered an expression, even if there is actually\n * no such expression type supported.\n * @param expression\n * @returns `true` if the expression is a binding toolkit expression\n */\nexport function isBindingToolkitExpression(\n\texpression: BindingToolkitExpression<unknown> | unknown\n): expression is BindingToolkitExpression<unknown> {\n\treturn (expression as BindingToolkitExpression<unknown>)?._type !== undefined;\n}\n\n/**\n * Checks if the expression or value provided is constant or not.\n * @template T The target type\n * @param  maybeConstant The expression or primitive value that is to be checked\n * @returns `true` if it is constant\n */\nexport function isConstant<T extends PrimitiveType>(maybeConstant: ExpressionOrPrimitive<T>): maybeConstant is ConstantExpression<T> {\n\treturn typeof maybeConstant !== \"object\" || (maybeConstant as BaseExpression<T>)._type === \"Constant\";\n}\n\nfunction isTrue(expression: BindingToolkitExpression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === true;\n}\n\nfunction isFalse(expression: BindingToolkitExpression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === false;\n}\n\n/**\n * Checks if the expression or value provided is a path in model expression or not.\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isPathInModelExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is PathInModelExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)?._type === \"PathInModel\";\n}\n\n/**\n * Checks if the expression or value provided is a complex type expression.\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isComplexTypeExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is ComplexTypeExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)?._type === \"ComplexType\";\n}\n\n/**\n * Checks if the expression or value provided is a concat expression or not.\n * @param expression\n * @returns `true` if the expression is a ConcatExpression\n */\nfunction isConcatExpression(expression: BindingToolkitExpression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)?._type === \"Concat\";\n}\n\n/**\n * Checks if the expression or value provided is a IfElse expression or not.\n * @param expression\n * @returns `true` if the expression is a IfElseExpression\n */\nfunction isIfElseExpression(expression: BindingToolkitExpression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)?._type === \"IfElse\";\n}\n\n/**\n * Checks if the expression provided is a comparison or not.\n * @template T The target type\n * @param expression The expression\n * @returns `true` if the expression is a ComparisonExpression\n */\nfunction isComparison<T extends PrimitiveType>(expression: BindingToolkitExpression<T>): expression is ComparisonExpression {\n\treturn expression._type === \"Comparison\";\n}\n\n/**\n * Checks whether the input parameter is a constant expression of type undefined.\n * @param expression The input expression or object in general\n * @returns `true` if the input is constant which has undefined for value\n */\nexport function isUndefinedExpression(expression: unknown): expression is ConstantExpression<undefined> {\n\tconst expressionAsExpression = expression as BindingToolkitExpression<unknown>;\n\treturn expressionAsExpression?._type === \"Constant\" && expressionAsExpression?.value === undefined;\n}\n\ntype ComplexAnnotationExpression<P> =\n\t| PathAnnotationExpression<P>\n\t| ApplyAnnotationExpression<P>\n\t| IfAnnotationExpression<P>\n\t| OrAnnotationExpression<P>\n\t| AndAnnotationExpression<P>\n\t| NeAnnotationExpression<P>\n\t| EqAnnotationExpression<P>\n\t| NotAnnotationExpression<P>\n\t| GtAnnotationExpression<P>\n\t| GeAnnotationExpression<P>\n\t| LeAnnotationExpression<P>\n\t| LtAnnotationExpression<P>\n\t| VocabConstantExpression<P>;\n\nfunction isPrimitiveObject(objectType: object): boolean {\n\tswitch (objectType.constructor.name) {\n\t\tcase \"String\":\n\t\tcase \"Number\":\n\t\tcase \"Boolean\":\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n/**\n * Check if the passed annotation annotationValue is a ComplexAnnotationExpression.\n * @template T The target type\n * @param  annotationValue The annotation annotationValue to evaluate\n * @returns `true` if the object is a {ComplexAnnotationExpression}\n */\nfunction isComplexAnnotationExpression<T>(annotationValue: PropertyAnnotationValue<T>): annotationValue is ComplexAnnotationExpression<T> {\n\treturn typeof annotationValue === \"object\" && !isPrimitiveObject(annotationValue as object);\n}\n\n/**\n * Generate the corresponding annotationValue for a given annotation annotationValue.\n * @template T The target type\n * @param annotationValue The source annotation annotationValue\n * @param visitedNavigationPaths The path from the root entity set\n * @param defaultValue Default value if the annotationValue is undefined\n * @param pathVisitor A function to modify the resulting path\n * @returns The annotationValue equivalent to that annotation annotationValue\n */\nexport function getExpressionFromAnnotation<T extends PrimitiveType>(\n\tannotationValue: PropertyAnnotationValue<T> | undefined,\n\tvisitedNavigationPaths: string[] = [],\n\tdefaultValue?: ExpressionOrPrimitive<T>,\n\tpathVisitor?: Function\n): BindingToolkitExpression<PrimitiveTypeCast<T>> {\n\tif (annotationValue === undefined) {\n\t\treturn wrapPrimitive(defaultValue as PrimitiveTypeCast<T>);\n\t}\n\tannotationValue = annotationValue?.valueOf() as PropertyAnnotationValue<T>;\n\tif (!isComplexAnnotationExpression(annotationValue)) {\n\t\treturn constant(annotationValue);\n\t}\n\n\tswitch (annotationValue.type) {\n\t\tcase \"Path\":\n\t\t\treturn pathInModel(annotationValue.path, undefined, visitedNavigationPaths, pathVisitor);\n\t\tcase \"If\":\n\t\t\treturn annotationIfExpression(annotationValue.$If, visitedNavigationPaths, pathVisitor) as BindingToolkitExpression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Not\":\n\t\t\treturn not(parseAnnotationCondition(annotationValue.$Not, visitedNavigationPaths, pathVisitor)) as BindingToolkitExpression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Eq\":\n\t\t\treturn equal(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ne\":\n\t\t\treturn notEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Gt\":\n\t\t\treturn greaterThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ge\":\n\t\t\treturn greaterOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Lt\":\n\t\t\treturn lessThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Le\":\n\t\t\treturn lessOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Or\":\n\t\t\treturn or(\n\t\t\t\t...annotationValue.$Or.map(function (orCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"And\":\n\t\t\treturn and(\n\t\t\t\t...annotationValue.$And.map(function (andCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Apply\":\n\t\t\treturn annotationApplyExpression(\n\t\t\t\tannotationValue as ApplyAnnotationExpression<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tpathVisitor\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Constant\":\n\t\t\t// Not a real case but the type system needs it\n\t\t\treturn constant(annotationValue.value as PrimitiveTypeCast<T>);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Parse the annotation condition into an expression.\n * @template T The target type\n * @param annotationValue The condition or value from the annotation\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns An equivalent expression\n */\nfunction parseAnnotationCondition<T extends PrimitiveType>(\n\tannotationValue: ConditionalCheckOrValue,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<T> {\n\tif (annotationValue === null || typeof annotationValue !== \"object\") {\n\t\treturn constant(annotationValue as T);\n\t} else if (annotationValue.hasOwnProperty(\"$Or\")) {\n\t\treturn or(\n\t\t\t...((annotationValue as OrConditionalExpression).$Or.map(function (orCondition) {\n\t\t\t\treturn parseAnnotationCondition(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as BindingToolkitExpression<boolean>[])\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$And\")) {\n\t\treturn and(\n\t\t\t...((annotationValue as AndConditionalExpression).$And.map(function (andCondition) {\n\t\t\t\treturn parseAnnotationCondition(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as BindingToolkitExpression<boolean>[])\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Not\")) {\n\t\treturn not(\n\t\t\tparseAnnotationCondition((annotationValue as NotConditionalExpression).$Not, visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Eq\")) {\n\t\treturn equal(\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ne\")) {\n\t\treturn notEqual(\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Gt\")) {\n\t\treturn greaterThan(\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ge\")) {\n\t\treturn greaterOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Lt\")) {\n\t\treturn lessThan(\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Le\")) {\n\t\treturn lessOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Path\")) {\n\t\treturn pathInModel((annotationValue as PathConditionExpression<T>).$Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"$Apply\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"Apply\",\n\t\t\t\t$Function: (annotationValue as { $Function?: string }).$Function,\n\t\t\t\t$Apply: (annotationValue as { $Apply?: unknown }).$Apply\n\t\t\t} as ApplyAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$If\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"If\",\n\t\t\t\t$If: (annotationValue as { $If?: unknown }).$If\n\t\t\t} as IfAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$EnumMember\")) {\n\t\treturn constant(resolveEnumValue((annotationValue as { $EnumMember?: string }).$EnumMember) as T);\n\t}\n\treturn constant(false as T);\n}\n\n/**\n * Process the {IfAnnotationExpressionValue} into an expression.\n * @template T The target type\n * @param annotationValue An If expression returning the type T\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns The equivalent ifElse expression\n */\nexport function annotationIfExpression<T extends PrimitiveType>(\n\tannotationValue: IfAnnotationExpressionValue<T>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<T> {\n\treturn ifElse(\n\t\tparseAnnotationCondition(annotationValue[0], visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[1] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[2] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor)\n\t);\n}\n// This type is not recursively transformed from the metamodel content, as such we have some ugly things there\ntype SubApplyExpressionFromMetamodel = Record<string, unknown>;\nfunction convertSubApplyParameters(applyParam: SubApplyExpressionFromMetamodel): SubApplyExpressionFromMetamodel | PrimitiveType {\n\tlet applyParamConverted = applyParam;\n\tif (applyParam.hasOwnProperty(\"$Path\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Path\",\n\t\t\tpath: applyParam.$Path\n\t\t} as PathAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$If\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"If\",\n\t\t\t$If: applyParam.$If\n\t\t} as IfAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$Apply\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Apply\",\n\t\t\t$Function: applyParam.$Function,\n\t\t\t$Apply: applyParam.$Apply\n\t\t} as ApplyAnnotationExpression<string>;\n\t}\n\treturn applyParamConverted;\n}\n\ntype ODataFunction = \"odata.concat\" | \"odata.fillUriTemplate\" | \"odata.uriEncode\";\nexport function annotationApplyExpression(\n\tapplyExpression: ApplyAnnotationExpression<string>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<string> {\n\tswitch (applyExpression.$Function as ODataFunction) {\n\t\tcase \"odata.concat\":\n\t\t\treturn concat(\n\t\t\t\t...applyExpression.$Apply.map((applyParam) => {\n\t\t\t\t\treturn getExpressionFromAnnotation(\n\t\t\t\t\t\tconvertSubApplyParameters(applyParam) as PropertyAnnotationValue<string>,\n\t\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpathVisitor\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\tcase \"odata.uriEncode\":\n\t\t\tconst parameter = getExpressionFromAnnotation(\n\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\tapplyExpression.$Apply[0] as unknown as SubApplyExpressionFromMetamodel\n\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tundefined,\n\t\t\t\tpathVisitor\n\t\t\t);\n\t\t\t// The second parameter for uriEncode is always a string since the target evaluation is against a formatValue call in ODataUtils which expect the target type as second parameter\n\t\t\treturn fn(\"odata.uriEncode\", [parameter, \"Edm.String\"], undefined, true);\n\t\tcase \"odata.fillUriTemplate\":\n\t\t\tconst template = applyExpression.$Apply[0];\n\t\t\tconst templateParams = applyExpression.$Apply.slice(1) as unknown as SubApplyExpressionFromMetamodel[];\n\t\t\tconst targetObject: Record<string, BindingToolkitExpression<unknown>> = {};\n\t\t\ttemplateParams.forEach((applyParam) => {\n\t\t\t\ttargetObject[applyParam.$Name as string] = getExpressionFromAnnotation(\n\t\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\t\tapplyParam.$LabeledElement as SubApplyExpressionFromMetamodel\n\t\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpathVisitor\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn fn(\"odata.fillUriTemplate\", [template, targetObject], undefined, true);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Generic helper for the comparison operations (equal, notEqual, ...).\n * @template T The target type\n * @param operator The operator to apply\n * @param leftOperand The operand on the left side of the operator\n * @param rightOperand The operand on the right side of the operator\n * @returns An expression representing the comparison\n */\nfunction comparison<T extends PrimitiveType>(\n\toperator: ComparisonOperator,\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isConstant(leftExpression) && isConstant(rightExpression)) {\n\t\tswitch (operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn constant(leftExpression.value !== rightExpression.value);\n\t\t\tcase \"===\":\n\t\t\t\treturn constant(leftExpression.value === rightExpression.value);\n\t\t\tcase \"<\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value < rightExpression.value);\n\t\t\tcase \"<=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value <= rightExpression.value);\n\t\t\tcase \">\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value > rightExpression.value);\n\t\t\tcase \">=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value >= rightExpression.value);\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Comparison\",\n\t\t\toperator: operator,\n\t\t\toperand1: leftExpression,\n\t\t\toperand2: rightExpression\n\t\t};\n\t}\n}\n\n/**\n * Generic helper for the length of an expression.\n * @param expression The input expression pointing to an array\n * @param checkUndefined Is the array potentially undefined\n * @returns An expression representing the length\n */\nexport function length(\n\texpression: PathInModelExpression<unknown> | UnresolvablePathExpression,\n\tcheckUndefined = false\n): BindingToolkitExpression<number> {\n\tif (expression._type === \"Unresolvable\") {\n\t\treturn expression;\n\t}\n\tif (!checkUndefined) {\n\t\treturn {\n\t\t\t_type: \"Length\",\n\t\t\tpathInModel: expression\n\t\t};\n\t}\n\treturn ifElse(equal(expression, undefined), -1, length(expression));\n}\n\n/**\n * Comparison: \"equal\" (===).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function equal<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (_checkExpressionsAreEqual(leftExpression, rightExpression)) {\n\t\treturn constant(true);\n\t}\n\n\tfunction reduce(left: BindingToolkitExpression<T>, right: BindingToolkitExpression<T>): BindingToolkitExpression<boolean> | undefined {\n\t\tif (left._type === \"Comparison\" && isTrue(right)) {\n\t\t\t// compare(a, b) === true ~~> compare(a, b)\n\t\t\treturn left;\n\t\t} else if (left._type === \"Comparison\" && isFalse(right)) {\n\t\t\t// compare(a, b) === false ~~> !compare(a, b)\n\t\t\treturn not(left);\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onTrue, right)) {\n\t\t\t// (if (x) { a } else { b }) === a ~~> x || (b === a)\n\t\t\treturn or(left.condition, equal(left.onFalse, right));\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onFalse, right)) {\n\t\t\t// (if (x) { a } else { b }) === b ~~> !x || (a === b)\n\t\t\treturn or(not(left.condition), equal(left.onTrue, right));\n\t\t} else if (\n\t\t\tleft._type === \"IfElse\" &&\n\t\t\tisConstant(left.onTrue) &&\n\t\t\tisConstant(left.onFalse) &&\n\t\t\tisConstant(right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onTrue, right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onFalse, right)\n\t\t) {\n\t\t\treturn constant(false);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t// exploit symmetry: a === b <~> b === a\n\tconst reduced = reduce(leftExpression, rightExpression) ?? reduce(rightExpression, leftExpression);\n\treturn reduced ?? comparison(\"===\", leftExpression, rightExpression);\n}\n\n/**\n * Comparison: \"not equal\" (!==).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function notEqual<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn not(equal(leftOperand, rightOperand));\n}\n\n/**\n * Comparison: \"greater or equal\" (>=).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\">=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"greater than\" (>).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\">\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less or equal\" (<=).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\"<=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less than\" (<).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\"<\", leftOperand, rightOperand);\n}\n\n/**\n * If-then-else expression.\n *\n * Evaluates to onTrue if the condition evaluates to true, else evaluates to onFalse.\n * @template T The target type\n * @param condition The condition to evaluate\n * @param onTrue Expression result if the condition evaluates to true\n * @param onFalse Expression result if the condition evaluates to false\n * @returns The expression that represents this conditional check\n */\nexport function ifElse<T extends PrimitiveType>(\n\tcondition: ExpressionOrPrimitive<boolean>,\n\tonTrue: ExpressionOrPrimitive<T>,\n\tonFalse: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<T> {\n\tlet conditionExpression = wrapPrimitive(condition);\n\tlet onTrueExpression = wrapPrimitive(onTrue);\n\tlet onFalseExpression = wrapPrimitive(onFalse);\n\n\t// swap branches if the condition is a negation\n\tif (conditionExpression._type === \"Not\") {\n\t\t// ifElse(not(X), a, b) --> ifElse(X, b, a)\n\t\t[onTrueExpression, onFalseExpression] = [onFalseExpression, onTrueExpression];\n\t\tconditionExpression = not(conditionExpression);\n\t}\n\n\t// inline nested if-else expressions: onTrue branch\n\t// ifElse(X, ifElse(X, a, b), c) ==> ifElse(X, a, c)\n\tif (onTrueExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onTrueExpression.condition)) {\n\t\tonTrueExpression = onTrueExpression.onTrue;\n\t}\n\n\t// inline nested if-else expressions: onFalse branch\n\t// ifElse(X, a, ifElse(X, b, c)) ==> ifElse(X, a, c)\n\tif (onFalseExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onFalseExpression.condition)) {\n\t\tonFalseExpression = onFalseExpression.onFalse;\n\t}\n\n\t// (if true then a else b)  ~~> a\n\t// (if false then a else b) ~~> b\n\tif (isConstant(conditionExpression)) {\n\t\treturn conditionExpression.value ? onTrueExpression : onFalseExpression;\n\t}\n\n\t// if (isConstantBoolean(onTrueExpression) || isConstantBoolean(onFalseExpression)) {\n\t// \treturn or(and(condition, onTrueExpression as Expression<boolean>), and(not(condition), onFalseExpression as Expression<boolean>)) as Expression<T>\n\t// }\n\n\t// (if X then a else a) ~~> a\n\tif (_checkExpressionsAreEqual(onTrueExpression, onFalseExpression)) {\n\t\treturn onTrueExpression;\n\t}\n\n\t// if X then a else false ~~> X && a\n\tif (isFalse(onFalseExpression)) {\n\t\treturn and(conditionExpression, onTrueExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then a else true ~~> !X || a\n\tif (isTrue(onFalseExpression)) {\n\t\treturn or(not(conditionExpression), onTrueExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then false else a ~~> !X && a\n\tif (isFalse(onTrueExpression)) {\n\t\treturn and(not(conditionExpression), onFalseExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then true else a ~~> X || a\n\tif (isTrue(onTrueExpression)) {\n\t\treturn or(conditionExpression, onFalseExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\tif (hasUnresolvableExpression(conditionExpression, onTrueExpression, onFalseExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isComplexTypeExpression(condition) || isComplexTypeExpression(onTrue) || isComplexTypeExpression(onFalse)) {\n\t\tlet pathIdx = 0;\n\t\tconst myIfElseExpression = formatResult([condition, onTrue, onFalse], \"sap.fe.core.formatters.StandardFormatter#ifElse\");\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyIfElseExpression,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myIfElseExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"IfElse\",\n\t\tcondition: conditionExpression,\n\t\tonTrue: onTrueExpression,\n\t\tonFalse: onFalseExpression\n\t};\n}\n\n/**\n * Checks whether the current expression has a reference to the default model (undefined).\n * @param expression The expression to evaluate\n * @returns `true` if there is a reference to the default context\n */\nfunction hasReferenceToDefaultContext(expression: BindingToolkitExpression<unknown>): boolean {\n\tswitch (expression._type) {\n\t\tcase \"Constant\":\n\t\tcase \"Formatter\":\n\t\tcase \"ComplexType\":\n\t\t\treturn false;\n\t\tcase \"Set\":\n\t\t\treturn expression.operands.some(hasReferenceToDefaultContext);\n\t\tcase \"PathInModel\":\n\t\t\treturn expression.modelName === undefined;\n\t\tcase \"Comparison\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand1) || hasReferenceToDefaultContext(expression.operand2);\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\thasReferenceToDefaultContext(expression.condition) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onTrue) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onFalse)\n\t\t\t);\n\t\tcase \"Not\":\n\t\tcase \"Truthy\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n// This is one case where any does make sense...\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn<T> = ((...params: any) => T | Promise<T>) & {\n\t__functionName: string;\n};\n\n/**\n * @typedef WrappedTuple\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype WrappedTuple<T> = { [K in keyof T]: WrappedTuple<T[K]> | ExpressionOrPrimitive<T[K]> | undefined };\n\n// So, this works but I cannot get it to compile :D, but it still does what is expected...\n\n/**\n * A function reference or a function name.\n */\ntype FunctionOrName<T> = Fn<T> | string;\n\n/**\n * Function parameters, either derived from the function or an untyped array.\n */\ntype FunctionParameters<T, F extends FunctionOrName<T>> = F extends Fn<T> ? Parameters<F> : unknown[];\n\n/**\n * Calls a formatter function to process the parameters.\n * If requireContext is set to true and no context is passed a default context will be added automatically.\n * @template T\n * @template U\n * @param parameters The list of parameter that should match the type and number of the formatter function\n * @param formatterFunction The function to call\n * @param [contextEntityType] If no parameter refers to the context then we use this information to add a reference to the keys from the entity type.\n * @param [ignoreComplexType] Whether to ignore the transgformation to the StandardFormatter or not\n * @returns The corresponding expression\n */\nexport function formatResult<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\tformatterFunction: U | string,\n\tcontextEntityType?: EntityType,\n\tignoreComplexType = false\n): BindingToolkitExpression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\tlet functionName = \"\";\n\tif (typeof formatterFunction === \"string\") {\n\t\tfunctionName = formatterFunction;\n\t} else {\n\t\tfunctionName = formatterFunction.__functionName;\n\t}\n\t// FormatterName can be of format sap.fe.core.xxx#methodName to have multiple formatter in one class\n\tconst [formatterClass, formatterName] = functionName.split(\"#\");\n\n\t// In some case we also cannot call directly a function because of too complex input, in that case we need to convert to a simpler function call\n\tif (\n\t\t!ignoreComplexType &&\n\t\t(parameterExpressions.some(isComplexTypeExpression) ||\n\t\t\tparameterExpressions.some(isConcatExpression) ||\n\t\t\tparameterExpressions.some(isIfElseExpression))\n\t) {\n\t\tlet pathIdx = 0;\n\t\tconst myFormatExpression = formatResult(parameterExpressions, functionName, undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyFormatExpression,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myFormatExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t} else if (!!formatterName && formatterName.length > 0) {\n\t\tparameterExpressions.unshift(constant(formatterName));\n\t}\n\n\treturn {\n\t\t_type: \"Formatter\",\n\t\tfn: formatterClass,\n\t\tparameters: parameterExpressions\n\t};\n}\n\ntype BindingConstraints = {\n\tscale?: number;\n\tprecision?: number;\n\tmaxLength?: number;\n\tnullable?: boolean;\n\tminimum?: string;\n\tmaximum?: string;\n\tisDigitSequence?: boolean;\n\tV4?: boolean;\n};\nexport function setUpConstraints(targetMapping: TypeMappingDefinition, property: Property | ActionParameter): BindingConstraints {\n\tconst constraints: BindingConstraints = {};\n\tif (targetMapping?.constraints?.$Scale && property.scale !== undefined) {\n\t\tconstraints.scale = property.scale;\n\t}\n\tif (targetMapping?.constraints?.$Precision && property.precision !== undefined) {\n\t\tconstraints.precision = property.precision;\n\t}\n\tif (targetMapping?.constraints?.$MaxLength && property.maxLength !== undefined) {\n\t\tconstraints.maxLength = property.maxLength;\n\t}\n\tif (property.nullable === false) {\n\t\tconstraints.nullable = false;\n\t}\n\tif (targetMapping?.constraints?.[\"@Org.OData.Validation.V1.Minimum/$Decimal\"] && !isNaN(property.annotations?.Validation?.Minimum)) {\n\t\tconstraints.minimum = `${property.annotations?.Validation?.Minimum}`;\n\t}\n\tif (targetMapping?.constraints?.[\"@Org.OData.Validation.V1.Maximum/$Decimal\"] && !isNaN(property.annotations?.Validation?.Maximum)) {\n\t\tconstraints.maximum = `${property.annotations?.Validation?.Maximum}`;\n\t}\n\tif (\n\t\tproperty.annotations?.Common?.IsDigitSequence &&\n\t\ttargetMapping.type === \"sap.ui.model.odata.type.String\" &&\n\t\ttargetMapping?.constraints?.[\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"]\n\t) {\n\t\tconstraints.isDigitSequence = true;\n\t}\n\tif (targetMapping?.constraints?.$V4) {\n\t\tconstraints.V4 = true;\n\t}\n\treturn constraints;\n}\n\n/**\n * Generates the binding expression for the property, and sets up the formatOptions and constraints.\n * @param property The Property for which we are setting up the binding\n * @param propertyBindingExpression The BindingExpression of the property above. Serves as the basis to which information can be added\n * @param ignoreConstraints Ignore constraints of the property\n * @returns The binding expression for the property with formatOptions and constraints\n */\nexport function formatWithTypeInformation<T>(\n\tproperty: Property | ActionParameter,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tignoreConstraints = false\n): PathInModelExpression<T> {\n\tconst outExpression: PathInModelExpression<unknown> = propertyBindingExpression as PathInModelExpression<unknown>;\n\tif (property._type !== \"Property\" && property._type !== \"ActionParameter\") {\n\t\treturn outExpression;\n\t}\n\tconst targetMapping = EDM_TYPE_MAPPING[property.type];\n\tif (!targetMapping) {\n\t\treturn outExpression;\n\t}\n\tif (!outExpression.formatOptions) {\n\t\toutExpression.formatOptions = {};\n\t}\n\toutExpression.constraints = {};\n\n\toutExpression.type = targetMapping.type;\n\tif (!ignoreConstraints) {\n\t\toutExpression.constraints = setUpConstraints(targetMapping, property);\n\t}\n\n\tif (\n\t\t(outExpression?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 && outExpression?.type !== \"sap.ui.model.odata.type.Int64\") ||\n\t\toutExpression?.type === \"sap.ui.model.odata.type.Double\"\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\tparseAsString: false\n\t\t});\n\t}\n\tif (outExpression.type === \"sap.ui.model.odata.type.String\" && isProperty(property)) {\n\t\tif (outExpression.constraints?.isDigitSequence || (outExpression.constraints?.nullable !== false && property.nullable === true)) {\n\t\t\toutExpression.formatOptions.parseKeepsEmptyString = false;\n\t\t} else {\n\t\t\toutExpression.formatOptions.parseKeepsEmptyString = true;\n\t\t}\n\t\tconst fiscalType = getFiscalType(property);\n\t\tif (fiscalType) {\n\t\t\toutExpression.formatOptions.fiscalType = fiscalType;\n\t\t\toutExpression.type = \"sap.fe.core.type.FiscalDate\";\n\t\t}\n\t}\n\tconst typesSupportingParseEmptyValueToZero = [\n\t\t\"sap.ui.model.odata.type.Int16\",\n\t\t\"sap.ui.model.odata.type.Int32\",\n\t\t\"sap.ui.model.odata.type.Int64\",\n\t\t\"sap.ui.model.odata.type.Single\",\n\t\t\"sap.ui.model.odata.type.Double\",\n\t\t\"sap.ui.model.odata.type.Decimal\",\n\t\t\"sap.ui.model.odata.type.Byte\",\n\t\t\"sap.ui.model.odata.type.SByte\"\n\t];\n\tif (\n\t\toutExpression.constraints?.nullable === false &&\n\t\toutExpression.type &&\n\t\ttypesSupportingParseEmptyValueToZero.includes(outExpression.type)\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\tparseEmptyValueToZero: true\n\t\t});\n\t}\n\tif (\n\t\toutExpression.constraints?.nullable !== false &&\n\t\t(outExpression.type === \"sap.ui.model.odata.type.Int64\" || outExpression.type === \"sap.ui.model.odata.type.Decimal\")\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\temptyString: \"\"\n\t\t});\n\t}\n\n\treturn outExpression;\n}\n\nexport const getFiscalType = function (property: Property): string | undefined {\n\tif (property.annotations?.Common?.IsFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsFiscalYear;\n\t}\n\tif (property.annotations?.Common?.IsFiscalPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalPeriod;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearPeriod;\n\t}\n\tif (property.annotations?.Common?.IsFiscalQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalQuarter;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearQuarter;\n\t}\n\tif (property.annotations?.Common?.IsFiscalWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalWeek;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearWeek;\n\t}\n\tif (property.annotations?.Common?.IsDayOfFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsDayOfFiscalYear;\n\t}\n};\n\n/**\n * Calls a complex type to process the parameters.\n * If requireContext is set to true and no context is passed, a default context will be added automatically.\n * @template T\n * @template U\n * @param parameters The list of parameters that should match the type for the complex type=\n * @param type The complex type to use\n * @param [contextEntityType] The context entity type to consider\n * @param oFormatOptions\n * @param oConstraintOptions\n * @returns The corresponding expression\n */\nexport function addTypeInformation<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\ttype: string,\n\tcontextEntityType?: EntityType,\n\toFormatOptions?: ComplexTypeFormatOptions,\n\toConstraintOptions?: ComplexTypeConstraintOptions\n): UnresolvablePathExpression | ComplexTypeExpression<T> | ConstantExpression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\t// If there is only one parameter and it is a constant and we don't expect the context then return the constant\n\tif (parameterExpressions.length === 1 && isConstant(parameterExpressions[0]) && !contextEntityType) {\n\t\treturn parameterExpressions[0] as ConstantExpression<T>;\n\t} else if (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\toFormatOptions = _getComplexTypeFormatOptionsFromFirstParam(parameters[0], oFormatOptions);\n\n\tif (type === \"sap.ui.model.odata.type.Unit\") {\n\t\tconst uomPath = pathInModel(\"/##@@requestUnitsOfMeasure\");\n\t\tuomPath.targetType = \"any\";\n\t\tuomPath.mode = \"OneTime\";\n\t\toFormatOptions ??= {};\n\t\toFormatOptions.preserveDecimals = oConstraintOptions?.skipDecimalsValidation ?? false;\n\t\tparameterExpressions.push(uomPath);\n\t} else if (type === \"sap.ui.model.odata.type.Currency\") {\n\t\tconst currencyPath = pathInModel(\"/##@@requestCurrencyCodes\");\n\t\tcurrencyPath.targetType = \"any\";\n\t\tcurrencyPath.mode = \"OneTime\";\n\t\toFormatOptions ??= {};\n\t\toFormatOptions.preserveDecimals = false; // default value since we don't have a CLDR\n\t\tparameterExpressions.push(currencyPath);\n\t}\n\n\treturn {\n\t\t_type: \"ComplexType\",\n\t\ttype: type,\n\t\tformatOptions: oFormatOptions || {},\n\t\tconstraints: oConstraintOptions || {},\n\t\tparameters: {},\n\t\tbindingParameters: parameterExpressions\n\t};\n}\n\ntype ComplexTypeFormatOptions = {\n\tshowNumber?: boolean;\n\tshowMeasure?: boolean;\n\tparseAsString?: boolean;\n\tparseKeepsEmptyString?: boolean;\n\temptyString?: string | number | null;\n\tshowTime?: boolean;\n\tshowDate?: boolean;\n\tshowTimezone?: boolean;\n\tpreserveDecimals?: boolean;\n\tdecimalPadding?: number;\n};\n\nexport type ComplexTypeConstraintOptions = {\n\tskipDecimalsValidation?: boolean;\n};\n\n/**\n * Process the formatOptions for a complexType based on the first parameter.\n * @param param The first parameter of the complex type\n * @param formatOptions Initial formatOptions\n * @returns The modified formatOptions\n */\nfunction _getComplexTypeFormatOptionsFromFirstParam<T, U extends Fn<T>>(\n\tparam: Parameters<U>,\n\tformatOptions: undefined | ComplexTypeFormatOptions\n): ComplexTypeFormatOptions | undefined {\n\t// if showMeasure is set to false we want to not parse as string to see the 0\n\t// we do that also for all bindings because otherwise the mdc Field isn't editable\n\tif (\n\t\t!(formatOptions && formatOptions.showNumber === false) &&\n\t\t(param?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tparam?.type === \"sap.ui.model.odata.type.Decimal\" ||\n\t\t\tparam?.type === \"sap.ui.model.odata.type.Double\")\n\t) {\n\t\tif (param?.type === \"sap.ui.model.odata.type.Int64\" || param?.type === \"sap.ui.model.odata.type.Decimal\") {\n\t\t\t//sap.ui.model.odata.type.Int64 do not support parseAsString false\n\t\t\tformatOptions =\n\t\t\t\tformatOptions?.showMeasure === false\n\t\t\t\t\t? { showMeasure: false, decimalPadding: formatOptions.decimalPadding }\n\t\t\t\t\t: { decimalPadding: formatOptions?.decimalPadding };\n\t\t} else {\n\t\t\tformatOptions =\n\t\t\t\tformatOptions?.showMeasure === false\n\t\t\t\t\t? { parseAsString: false, showMeasure: false, decimalPadding: formatOptions.decimalPadding }\n\t\t\t\t\t: { parseAsString: false, decimalPadding: formatOptions?.decimalPadding };\n\t\t}\n\t\tif (param?.constraints?.nullable !== false) {\n\t\t\tformatOptions.emptyString = null;\n\t\t} else {\n\t\t\tformatOptions.emptyString = \"\";\n\t\t}\n\t}\n\treturn formatOptions;\n}\n/**\n * Function call, optionally with arguments.\n * @param func Function name or reference to function\n * @param parameters Arguments\n * @param on Object to call the function on\n * @param isFormattingFn\n * @returns Expression representing the function call (not the result of the function call!)\n */\nexport function fn<T, U extends FunctionOrName<T>>(\n\tfunc: U,\n\tparameters: WrappedTuple<FunctionParameters<T, U>>,\n\ton?: ExpressionOrPrimitive<object>,\n\tisFormattingFn = false\n): FunctionExpression<T> {\n\tconst functionName = typeof func === \"string\" ? func : func.__functionName;\n\treturn {\n\t\t_type: \"Function\",\n\t\tobj: on !== undefined ? wrapPrimitive(on) : undefined,\n\t\tfn: functionName,\n\t\tisFormattingFn: isFormattingFn,\n\t\tparameters: (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive)\n\t};\n}\n\n/**\n * Shortcut function to determine if a binding value is null, undefined or empty.\n * @param expression\n * @returns A Boolean expression evaluating the fact that the current element is empty\n */\nexport function isEmpty(expression: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> {\n\tconst aBindings: ExpressionOrPrimitive<boolean>[] = [];\n\ttransformRecursively(expression, \"PathInModel\", (expr) => {\n\t\tconst finalExpression = { ...expr, alwaysKeepTargetType: true } as PathInModelExpression<string>;\n\t\taBindings.push(or(equal(finalExpression, \"\"), equal(expr, undefined), equal(expr, null)));\n\t\treturn expr;\n\t});\n\treturn and(...aBindings);\n}\n\nexport function concat(...inExpressions: ExpressionOrPrimitive<string>[]): BindingToolkitExpression<string> {\n\tconst expressions = inExpressions.map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (expressions.every(isConstant)) {\n\t\treturn constant(\n\t\t\texpressions.reduce((concatenated: string, value) => {\n\t\t\t\tif (value.value !== undefined && value.value !== null) {\n\t\t\t\t\treturn concatenated + value.value.toString();\n\t\t\t\t}\n\t\t\t\treturn concatenated;\n\t\t\t}, \"\")\n\t\t);\n\t} else if (expressions.some(isComplexTypeExpression)) {\n\t\tlet pathIdx = 0;\n\t\tconst myConcatExpression = formatResult(expressions, \"sap.fe.core.formatters.StandardFormatter#concat\", undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(myConcatExpression, \"PathInModel\", (constantPath: PathInModelExpression<unknown>) => {\n\t\t\tallParts.push(constantPath);\n\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t});\n\t\tallParts.unshift(constant(JSON.stringify(myConcatExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"Concat\",\n\t\texpressions: expressions\n\t};\n}\n\ntype ExpressionTypeToExpression<T extends ExpressionType, V> = T extends \"Constant\"\n\t? ConstantExpression<V>\n\t: T extends \"PathInModel\"\n\t? PathInModelExpression<V>\n\t: T extends \"Function\"\n\t? FunctionExpression<V>\n\t: T extends \"Unresolvable\"\n\t? UnresolvablePathExpression\n\t: BindingToolkitExpression<V>;\n\nexport type TransformFunction<T, V> = (expressionPart: T) => BindingToolkitExpression<V>;\nexport type ExpressionType = Pick<BindingToolkitExpression<unknown>, \"_type\">[\"_type\"];\nexport function transformRecursively<T extends PrimitiveType | unknown, ET extends ExpressionType>(\n\tinExpression: BindingToolkitExpression<T>,\n\texpressionType: ET,\n\ttransformFunction: TransformFunction<ExpressionTypeToExpression<ET, T>, T>,\n\tincludeAllExpression = false\n): BindingToolkitExpression<T> {\n\tlet expression: BindingToolkitExpression<T> = inExpression;\n\tswitch (expression._type) {\n\t\tcase \"Function\":\n\t\tcase \"Formatter\":\n\t\t\texpression.parameters = expression.parameters.map((parameter) =>\n\t\t\t\ttransformRecursively(parameter as BindingToolkitExpression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"Concat\":\n\t\t\texpression.expressions = expression.expressions.map((subExpression) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tsubExpression,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, string>, string>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\texpression = concat(...expression.expressions) as BindingToolkitExpression<T>;\n\t\t\tbreak;\n\t\tcase \"ComplexType\":\n\t\t\texpression.bindingParameters = expression.bindingParameters.map((bindingParameter) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tbindingParameter as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"IfElse\":\n\t\t\tconst onTrue = transformRecursively(\n\t\t\t\texpression.onTrue,\n\t\t\t\texpressionType,\n\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\tincludeAllExpression\n\t\t\t);\n\t\t\tconst onFalse = transformRecursively(\n\t\t\t\texpression.onFalse,\n\t\t\t\texpressionType,\n\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\tincludeAllExpression\n\t\t\t);\n\t\t\tlet condition = expression.condition;\n\t\t\tif (includeAllExpression) {\n\t\t\t\tcondition = transformRecursively(\n\t\t\t\t\texpression.condition,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t}\n\t\t\texpression = ifElse(condition, onTrue, onFalse) as BindingToolkitExpression<T>;\n\t\t\tbreak;\n\t\tcase \"Not\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand = transformRecursively(\n\t\t\t\t\texpression.operand,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = not(operand) as BindingToolkitExpression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Truthy\":\n\t\t\tbreak;\n\t\tcase \"Set\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operands = expression.operands.map((operand) =>\n\t\t\t\t\ttransformRecursively(\n\t\t\t\t\t\toperand,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\texpression =\n\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t? (or(...operands) as BindingToolkitExpression<T>)\n\t\t\t\t\t\t: (and(...operands) as BindingToolkitExpression<T>);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Comparison\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand1 = transformRecursively(\n\t\t\t\t\texpression.operand1 as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\tconst operand2 = transformRecursively(\n\t\t\t\t\texpression.operand2 as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = comparison(expression.operator, operand1, operand2) as BindingToolkitExpression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Constant\":\n\t\t\tconst constantValue: Record<string, BindingToolkitExpression<unknown>> = expression.value as Record<\n\t\t\t\tstring,\n\t\t\t\tBindingToolkitExpression<unknown>\n\t\t\t>;\n\t\t\tif (typeof constantValue === \"object\" && constantValue) {\n\t\t\t\tObject.keys(constantValue).forEach((key) => {\n\t\t\t\t\tconstantValue[key] = transformRecursively(\n\t\t\t\t\t\tconstantValue[key],\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Ref\":\n\t\tcase \"Length\":\n\t\tcase \"PathInModel\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\tcase \"Unresolvable\":\n\t\t\t// Do nothing\n\t\t\tbreak;\n\t}\n\tif (expressionType === expression._type) {\n\t\texpression = transformFunction(inExpression as ExpressionTypeToExpression<ET, T>);\n\t}\n\treturn expression;\n}\n\nexport type CompiledBindingToolkitExpression = string | undefined;\n\nconst needParenthesis = function <T extends PrimitiveType>(expr: ExpressionOrPrimitive<T>): boolean {\n\treturn (\n\t\t!isConstant(expr) &&\n\t\t!isPathInModelExpression(expr) &&\n\t\tisBindingToolkitExpression(expr) &&\n\t\texpr._type !== \"IfElse\" &&\n\t\texpr._type !== \"Function\"\n\t);\n};\n\n/**\n * Compiles a constant object to a string.\n * @param expr\n * @param isNullable\n * @returns The compiled string\n */\nfunction compileConstantObject(expr: ConstantExpression<object>, isNullable = false): string {\n\tif (isNullable && Object.keys(expr.value).length === 0) {\n\t\treturn \"\";\n\t}\n\tconst objects = expr.value as PlainExpressionObject;\n\tconst properties: string[] = [];\n\tObject.keys(objects).forEach((key) => {\n\t\tconst value = objects[key];\n\t\tconst childResult = compileExpression(value, true, false, isNullable);\n\t\tif (childResult && childResult.length > 0) {\n\t\t\tproperties.push(`${key}: ${childResult}`);\n\t\t}\n\t});\n\treturn `{${properties.join(\", \")}}`;\n}\n\n/**\n * Compiles a Constant Binding Expression.\n * @param expr\n * @param embeddedInBinding\n * @param isNullable\n * @param doNotStringify\n * @returns The compiled string\n */\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable?: boolean,\n\tdoNotStringify?: false\n): CompiledBindingToolkitExpression;\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable?: boolean,\n\tdoNotStringify?: true\n): PrimitiveType;\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable = false,\n\tdoNotStringify = false\n): CompiledBindingToolkitExpression | PrimitiveType {\n\tif (expr.value === null) {\n\t\treturn doNotStringify ? null : \"null\";\n\t}\n\tif (expr.value === undefined) {\n\t\treturn doNotStringify ? undefined : \"undefined\";\n\t}\n\tif (typeof expr.value === \"object\") {\n\t\tif (Array.isArray(expr.value)) {\n\t\t\tconst entries = expr.value.map((expression) => compileExpression(expression, true));\n\t\t\treturn `[${entries.join(\", \")}]`;\n\t\t} else {\n\t\t\treturn compileConstantObject(expr as ConstantExpression<object>, isNullable);\n\t\t}\n\t}\n\n\tif (embeddedInBinding) {\n\t\tswitch (typeof expr.value) {\n\t\t\tcase \"number\":\n\t\t\tcase \"bigint\":\n\t\t\tcase \"boolean\":\n\t\t\t\treturn expr.value.toString();\n\t\t\tcase \"string\":\n\t\t\t\treturn `'${escapeXmlAttribute(expr.value.toString())}'`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t} else {\n\t\treturn doNotStringify ? expr.value : expr.value.toString();\n\t}\n}\n\n/**\n * Generates the binding string for a Binding expression.\n * @param expressionForBinding The expression to compile\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @param embeddedSeparator The binding value evaluator ($ or % depending on whether we want to force the type or not)\n * @returns The corresponding expression binding\n */\nfunction compilePathInModelExpression<T extends PrimitiveType>(\n\texpressionForBinding: PathInModelExpression<T>,\n\tembeddedInBinding: boolean,\n\tembeddedSeparator: string\n): CompiledBindingToolkitExpression {\n\tif (\n\t\texpressionForBinding.type ||\n\t\texpressionForBinding.parameters ||\n\t\texpressionForBinding.targetType ||\n\t\texpressionForBinding.formatOptions ||\n\t\texpressionForBinding.constraints\n\t) {\n\t\t// This is now a complex binding definition, let's prepare for it\n\t\tconst complexBindingDefinition = {\n\t\t\tpath: compilePathInModel(expressionForBinding),\n\t\t\ttype: expressionForBinding.type,\n\t\t\ttargetType: expressionForBinding.targetType,\n\t\t\tparameters: expressionForBinding.parameters,\n\t\t\tformatOptions: expressionForBinding.formatOptions,\n\t\t\tconstraints: expressionForBinding.constraints\n\t\t};\n\t\tconst outBinding = compileExpression(complexBindingDefinition, false, false, true);\n\t\tif (embeddedInBinding) {\n\t\t\tconst separator = expressionForBinding.alwaysKeepTargetType ? \"$\" : embeddedSeparator;\n\t\t\treturn `${separator}${outBinding}`;\n\t\t}\n\t\treturn outBinding;\n\t} else if (embeddedInBinding) {\n\t\treturn `${embeddedSeparator}{${compilePathInModel(expressionForBinding)}}`;\n\t} else {\n\t\treturn `{${compilePathInModel(expressionForBinding)}}`;\n\t}\n}\n\nfunction compileComplexTypeExpression<T extends PrimitiveType>(expression: ComplexTypeExpression<T>): string {\n\tif (expression.bindingParameters.length === 1) {\n\t\treturn `{${compilePathParameter(expression.bindingParameters[0] as BindingToolkitExpression<PrimitiveType>, true)}, type: '${\n\t\t\texpression.type\n\t\t}'}`;\n\t}\n\n\tlet outputEnd = `], type: '${expression.type}'`;\n\tif (hasElements(expression.formatOptions)) {\n\t\toutputEnd += `, formatOptions: ${compileExpression(expression.formatOptions)}`;\n\t}\n\tif (hasElements(expression.constraints)) {\n\t\toutputEnd += `, constraints: ${compileExpression(expression.constraints)}`;\n\t}\n\tif (hasElements(expression.parameters)) {\n\t\toutputEnd += `, parameters: ${compileExpression(expression.parameters)}`;\n\t}\n\toutputEnd += \"}\";\n\n\treturn `{mode:'TwoWay', parts:[${expression.bindingParameters\n\t\t.map((param) => compilePathParameter(param as BindingToolkitExpression<PrimitiveType>))\n\t\t.join(\",\")}${outputEnd}`;\n}\n\n/**\n * Wrap the compiled binding string as required depending on its context.\n * @param expression The compiled expression\n * @param embeddedInBinding True if the compiled expression is to be embedded in a binding\n * @param parenthesisRequired True if the embedded binding needs to be wrapped in parethesis so that it is evaluated as one\n * @returns Finalized compiled expression\n */\nexport function wrapBindingExpression(\n\texpression: string,\n\tembeddedInBinding: boolean,\n\tparenthesisRequired = false\n): CompiledBindingToolkitExpression {\n\tif (embeddedInBinding) {\n\t\tif (parenthesisRequired) {\n\t\t\treturn `(${expression})`;\n\t\t} else {\n\t\t\treturn expression;\n\t\t}\n\t} else {\n\t\treturn `{= ${expression}}`;\n\t}\n}\n\n/**\n * Compile an expression into an expression binding.\n * @template T The target type\n * @param expression The expression to compile\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @param keepTargetType Keep the target type of the embedded bindings instead of casting them to any\n * @param isNullable Whether binding expression can resolve to empty string or not\n * @returns The corresponding expression binding\n */\nexport function compileExpression<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tembeddedInBinding = false,\n\tkeepTargetType = false,\n\tisNullable = false\n): CompiledBindingToolkitExpression {\n\tconst expr = wrapPrimitive(expression);\n\tconst embeddedSeparator = keepTargetType ? \"$\" : \"%\";\n\n\tswitch (expr._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn undefined;\n\n\t\tcase \"Constant\":\n\t\t\treturn compileConstant(expr, embeddedInBinding, isNullable);\n\n\t\tcase \"Ref\":\n\t\t\treturn expr.ref || \"null\";\n\n\t\tcase \"Function\":\n\t\t\tlet hasEmbeddedFunctionCallOrBinding = false;\n\t\t\tif (expr.isFormattingFn) {\n\t\t\t\ttransformRecursively(\n\t\t\t\t\texpr,\n\t\t\t\t\t\"Function\",\n\t\t\t\t\t(subFn) => {\n\t\t\t\t\t\tif (subFn !== expr && subFn.obj === undefined) {\n\t\t\t\t\t\t\thasEmbeddedFunctionCallOrBinding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn subFn;\n\t\t\t\t\t},\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t\ttransformRecursively(\n\t\t\t\t\texpr,\n\t\t\t\t\t\"Constant\",\n\t\t\t\t\t(subFn: ConstantExpression<T>) => {\n\t\t\t\t\t\tif ((subFn as unknown) !== expr && typeof subFn.value === \"object\") {\n\t\t\t\t\t\t\ttransformRecursively(subFn, \"PathInModel\", (subSubFn) => {\n\t\t\t\t\t\t\t\thasEmbeddedFunctionCallOrBinding = true;\n\t\t\t\t\t\t\t\treturn subSubFn;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn subFn;\n\t\t\t\t\t},\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst argumentString = `${expr.parameters.map((arg) => compileExpression(arg, true)).join(\", \")}`;\n\t\t\tlet fnCall =\n\t\t\t\texpr.obj === undefined\n\t\t\t\t\t? `${expr.fn}(${argumentString})`\n\t\t\t\t\t: `${compileExpression(expr.obj, true)}.${expr.fn}(${argumentString})`;\n\t\t\tif (!embeddedInBinding && hasEmbeddedFunctionCallOrBinding) {\n\t\t\t\tfnCall = `{= ${fnCall}}`;\n\t\t\t}\n\t\t\treturn fnCall;\n\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn embeddedInBinding ? `(${expr.value.substring(2, expr.value.length - 1)})` : `${expr.value}`;\n\n\t\tcase \"EmbeddedBinding\":\n\t\t\treturn embeddedInBinding ? `${embeddedSeparator}${expr.value}` : `${expr.value}`;\n\n\t\tcase \"PathInModel\":\n\t\t\treturn compilePathInModelExpression(expr, embeddedInBinding, embeddedSeparator);\n\n\t\tcase \"Comparison\":\n\t\t\tconst comparisonExpression = compileComparisonExpression(expr);\n\t\t\treturn wrapBindingExpression(comparisonExpression, embeddedInBinding);\n\n\t\tcase \"IfElse\":\n\t\t\tconst ifElseExpression = `${compileExpression(expr.condition, true)} ? ${compileExpression(\n\t\t\t\texpr.onTrue,\n\t\t\t\ttrue,\n\t\t\t\tkeepTargetType\n\t\t\t)} : ${compileExpression(expr.onFalse, true, keepTargetType)}`;\n\t\t\treturn wrapBindingExpression(ifElseExpression, embeddedInBinding, true);\n\n\t\tcase \"Set\":\n\t\t\tconst setExpression = expr.operands.map((operand) => compileExpression(operand, true)).join(` ${expr.operator} `);\n\t\t\treturn wrapBindingExpression(setExpression, embeddedInBinding, true);\n\n\t\tcase \"Concat\":\n\t\t\tconst concatExpression = expr.expressions\n\t\t\t\t.map((nestedExpression) => compileExpression(nestedExpression, true, true))\n\t\t\t\t.join(\" + \");\n\t\t\treturn wrapBindingExpression(concatExpression, embeddedInBinding);\n\n\t\tcase \"Length\":\n\t\t\tconst lengthExpression = `${compileExpression(expr.pathInModel, true)}.length`;\n\t\t\treturn wrapBindingExpression(lengthExpression, embeddedInBinding);\n\n\t\tcase \"Not\":\n\t\t\tconst notExpression = `!${compileExpression(expr.operand, true)}`;\n\t\t\treturn wrapBindingExpression(notExpression, embeddedInBinding);\n\n\t\tcase \"Truthy\":\n\t\t\tconst truthyExpression = `!!${compileExpression(expr.operand, true)}`;\n\t\t\treturn wrapBindingExpression(truthyExpression, embeddedInBinding);\n\n\t\tcase \"Formatter\":\n\t\t\tconst formatterExpression = compileFormatterExpression(expr);\n\t\t\treturn embeddedInBinding ? `$${formatterExpression}` : formatterExpression;\n\n\t\tcase \"ComplexType\":\n\t\t\tconst complexTypeExpression = compileComplexTypeExpression(expr);\n\t\t\treturn embeddedInBinding ? `$${complexTypeExpression}` : complexTypeExpression;\n\n\t\tdefault:\n\t\t\treturn \"\";\n\t}\n}\n\n/**\n * Compile a comparison expression.\n * @param expression The comparison expression.\n * @returns The compiled expression. Needs wrapping before it can be used as an expression binding.\n */\nfunction compileComparisonExpression(expression: ComparisonExpression): string {\n\tfunction compileOperand(operand: BindingToolkitExpression<unknown>): CompiledBindingToolkitExpression {\n\t\tconst compiledOperand = compileExpression(operand, true) ?? \"undefined\";\n\t\treturn wrapBindingExpression(compiledOperand, true, needParenthesis(operand));\n\t}\n\n\treturn `${compileOperand(expression.operand1)} ${expression.operator} ${compileOperand(expression.operand2)}`;\n}\n\n/**\n * Compile a formatter expression.\n * @param expression The formatter expression.\n * @returns The compiled expression.\n */\nfunction compileFormatterExpression<T extends PrimitiveType>(expression: FormatterExpression<T>): string {\n\tif (expression.parameters.length === 1) {\n\t\treturn `{${compilePathParameter(expression.parameters[0] as BindingToolkitExpression<PrimitiveType>, true)}, formatter: '${\n\t\t\texpression.fn\n\t\t}'}`;\n\t} else {\n\t\tconst parts = expression.parameters.map((param) => {\n\t\t\tif (param._type === \"ComplexType\") {\n\t\t\t\treturn compileComplexTypeExpression(param);\n\t\t\t} else {\n\t\t\t\treturn compilePathParameter(param as BindingToolkitExpression<PrimitiveType>);\n\t\t\t}\n\t\t});\n\t\treturn `{parts: [${parts.join(\", \")}], formatter: '${expression.fn}'}`;\n\t}\n}\n\n/**\n * Compile the path parameter of a formatter call.\n * @param expression The binding part to evaluate\n * @param singlePath Whether there is one or multiple path to consider\n * @returns The string snippet to include in the overall binding definition\n */\nfunction compilePathParameter(expression: BindingToolkitExpression<PrimitiveType>, singlePath = false): string {\n\tlet outValue = \"\";\n\tif (expression._type === \"Constant\") {\n\t\tif (expression.value === undefined) {\n\t\t\t// Special case otherwise the JSTokenizer complains about incorrect content\n\t\t\toutValue = `value: 'undefined'`;\n\t\t} else {\n\t\t\toutValue = `value: ${compileConstant(expression, true)}`;\n\t\t}\n\t} else if (expression._type === \"PathInModel\") {\n\t\toutValue = `path: '${compilePathInModel(expression)}'`;\n\n\t\toutValue += expression.type ? `, type: '${expression.type}'` : `, targetType: 'any'`;\n\t\tif (expression.mode) {\n\t\t\toutValue += `, mode: '${compileExpression(expression.mode)}'`;\n\t\t}\n\t\tif (hasElements(expression.constraints)) {\n\t\t\toutValue += `, constraints: ${compileExpression(expression.constraints)}`;\n\t\t}\n\t\tif (hasElements(expression.formatOptions)) {\n\t\t\toutValue += `, formatOptions: ${compileExpression(expression.formatOptions)}`;\n\t\t}\n\t\tif (hasElements(expression.parameters)) {\n\t\t\toutValue += `, parameters: ${compileExpression(expression.parameters)}`;\n\t\t}\n\t} else {\n\t\treturn \"\";\n\t}\n\treturn singlePath ? outValue : `{${outValue}}`;\n}\n\nfunction hasElements(obj: object | undefined): boolean {\n\treturn !!obj && Object.keys(obj).length > 0;\n}\n\n/**\n * Compile a binding expression path.\n * @param expression The expression to compile.\n * @returns The compiled path.\n */\nfunction compilePathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>): string {\n\treturn `${expression.modelName ? expression.modelName + \">\" : \"\"}${expression.path}`;\n}\n"],"mappings":"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","ignoreList":[],"sourceRoot":""}},{"offset":{"line":11,"column":0},"map":{"version":3,"names":["BuildingBlockBase","_dec","defineUI5Class","_dec2","aggregation","type","multiple","isDefault","_dec3","association","singularName","_dec4","defineState","_class","_class2","_Control","settings","others","_this","id","call","this","_initializerDefineProperty","_descriptor","_descriptor2","_descriptor3","_oldDomRef","_inheritsLoose","render","oRm","oControl","content","getVisible","InvisibleRenderer","renderControl","_proto","prototype","bindProperty","name","bindingInfo","propertyMetadata","getMetadata","getProperty","bindable","group","onAfterRendering","event","domRef","getDomRef","WeakRef","suffix","oContent","deref","document","getElementById","getFocusDomRef","enhanceAccessibilityState","_oElement","mAriaProps","oParent","getParent","getAccessibilityInfo","accessibilityInfo","isA","getIdForLabel","addStyleClass","styleClass","removeStyleClass","bindState","path","BindingToolkit","state","Control","_applyDecoratedDescriptor","configurable","enumerable","writable","initializer"],"sources":["./BuildingBlockBase.ts"],"sourcesContent":["import type { ConstantExpression, PathInModelExpression, PrimitiveType } from \"sap/fe/base/BindingToolkit\";\nimport * as BindingToolkit from \"sap/fe/base/BindingToolkit\";\nimport type { PropertiesOf, StateOf } from \"sap/fe/base/ClassSupport\";\nimport { aggregation, association, defineState, defineUI5Class } from \"sap/fe/base/ClassSupport\";\nimport type ManagedObject from \"sap/ui/base/ManagedObject\";\nimport type { PropertyBindingInfo } from \"sap/ui/base/ManagedObject\";\nimport Control from \"sap/ui/core/Control\";\nimport type UI5Element from \"sap/ui/core/Element\";\nimport InvisibleRenderer from \"sap/ui/core/InvisibleRenderer\";\nimport type RenderManager from \"sap/ui/core/RenderManager\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface BuildingBlockBase<T extends UI5Element = Control, K extends object = {}> {\n\t// Force a state update\n\t_updateState(): Promise<void>;\n}\n\n/**\n * Base class for building blocks.\n * This contains the low level functionality of having a content aggregation and handling the rendering of the content without an actual DOM element.\n * The building block also defines a state object that can be used to store the state of the building block.\n * Accessibility and classes information are forwarded to the content control.\n * @experimental\n * @public\n */\n@defineUI5Class(\"sap.fe.base.BuildingBlockBase\")\nclass BuildingBlockBase<T extends UI5Element = Control, K extends object = {}> extends Control {\n\t@aggregation({ type: \"sap.ui.core.Element\", multiple: false, isDefault: true })\n\tcontent?: T;\n\n\t/**\n\t * Association to controls / IDs that label this control (see WAI-ARIA attribute aria-labelledby).\n\t */\n\t@association({ type: \"sap.ui.core.Control\", multiple: true, singularName: \"ariaLabelledBy\" })\n\tariaLabelledBy!: string[];\n\n\t@defineState()\n\tprotected state!: StateOf<K>;\n\n\tconstructor(settings?: string | PropertiesOf<BuildingBlockBase<T>>, others?: PropertiesOf<BuildingBlockBase<T>>) {\n\t\tif (typeof settings === \"string\") {\n\t\t\tothers ??= {};\n\t\t\tothers.id = settings;\n\t\t}\n\t\tsuper(settings as unknown as string, others);\n\t}\n\n\tprivate _oldDomRef: WeakRef<Element> | null = null;\n\n\tstatic render<T extends Control>(oRm: RenderManager, oControl: BuildingBlockBase<T>): void {\n\t\tif (!oControl.content || oControl.getVisible() === false) {\n\t\t\tInvisibleRenderer.render(oRm, oControl);\n\t\t} else {\n\t\t\toRm.renderControl(oControl.content);\n\t\t}\n\t}\n\n\t/**\n\t * Override the bindProperty to deal with the case where the property is a binding info.\n\t * @param name The name of te property\n\t * @param bindingInfo The binding info\n\t * @returns The instance of the building block for chaining\n\t */\n\toverride bindProperty(name: string, bindingInfo: PropertyBindingInfo): this {\n\t\tconst propertyMetadata = this.getMetadata().getProperty(name);\n\t\tif (propertyMetadata?.bindable === false && propertyMetadata.group === \"Data\") {\n\t\t\t(this as Record<string, unknown>)[name] = bindingInfo;\n\t\t} else {\n\t\t\tsuper.bindProperty(name, bindingInfo);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//set the old dom ref\n\toverride onAfterRendering(event: JQuery.Event): void {\n\t\tconst domRef = this.getDomRef();\n\t\tif (domRef) {\n\t\t\tthis._oldDomRef = new WeakRef(domRef);\n\t\t} else {\n\t\t\tthis._oldDomRef = null;\n\t\t}\n\t\tsuper.onAfterRendering(event);\n\t}\n\n\toverride getDomRef(suffix?: string): Element | null {\n\t\tconst oContent = this.content;\n\t\tlet domRef: Element | null = oContent?.getDomRef(suffix) ?? super.getDomRef(suffix);\n\t\tif (!domRef && !suffix) {\n\t\t\tdomRef = this._oldDomRef?.deref() ?? null;\n\t\t\tif (domRef) {\n\t\t\t\treturn document.getElementById(domRef.id);\n\t\t\t}\n\t\t}\n\t\treturn domRef;\n\t}\n\n\toverride getFocusDomRef(): Element | null {\n\t\tconst oContent = this.content;\n\t\treturn oContent ? oContent.getFocusDomRef() : super.getFocusDomRef();\n\t}\n\n\t/**\n\t * This function asks up the control tree to enhance the accessibility state of the control.\n\t * @param _oElement The element to enhance\n\t * @param mAriaProps The current aria properties\n\t * @returns The enhanced aria properties\n\t */\n\toverride enhanceAccessibilityState(_oElement: object, mAriaProps: object): object {\n\t\tconst oParent = this.getParent();\n\n\t\tif (oParent && (oParent as ManagedObject & { enhanceAccessibilityState?: Function }).enhanceAccessibilityState) {\n\t\t\t// forward  enhanceAccessibilityState call to the parent\n\t\t\t(oParent as ManagedObject & { enhanceAccessibilityState: Function }).enhanceAccessibilityState(_oElement, mAriaProps);\n\t\t}\n\n\t\treturn mAriaProps;\n\t}\n\n\t/**\n\t * This function (if available on the concrete control) provides the current accessibility state of the control.\n\t * @returns The accessibility information for the control.\n\t */\n\toverride getAccessibilityInfo(): Object {\n\t\tlet accessibilityInfo = {};\n\t\tif (this.content?.isA<Control>(\"sap.ui.core.Control\")) {\n\t\t\taccessibilityInfo = this.content.getAccessibilityInfo();\n\t\t}\n\t\treturn accessibilityInfo;\n\t}\n\n\t/**\n\t * Returns the DOMNode ID to be used for the \"labelFor\" attribute.\n\t *\n\t * We forward the call of this method to the content control.\n\t * @returns ID to be used for the <code>labelFor</code>\n\t */\n\toverride getIdForLabel(): string {\n\t\tif (this.content?.isA<Control>(\"sap.ui.core.Control\")) {\n\t\t\treturn this.content.getIdForLabel();\n\t\t}\n\t\treturn \"\";\n\t}\n\n\toverride addStyleClass(styleClass: string): this {\n\t\t(this.content as unknown as Control)?.addStyleClass(styleClass);\n\t\tsuper.addStyleClass(styleClass);\n\t\treturn this;\n\t}\n\n\toverride removeStyleClass(styleClass: string): this {\n\t\t(this.content as unknown as Control)?.removeStyleClass(styleClass);\n\t\tsuper.removeStyleClass(styleClass);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shorthand for the BindingToolkit.bindState function with the current state object.\n\t * @param path A property in the state object\n\t * @returns The binding toolkit expression for the state\n\t */\n\tprotected bindState<ST extends PrimitiveType>(path: keyof K): PathInModelExpression<ST> | ConstantExpression<ST> {\n\t\treturn BindingToolkit.bindState(this.state as K, path);\n\t}\n}\n\nexport default BuildingBlockBase;\n"],"mappings":"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","ignoreList":[],"sourceRoot":""}},{"offset":{"line":16,"column":0},"map":{"version":3,"names":["ensureMetadata","target","metadata","merge","controllerExtensions","properties","aggregations","references","associations","methods","events","interfaces","prepareGetAPIFunction","oEvent","apiFQN","arguments","length","undefined","getMetadata","getName","oSource","getSource","_getAPIExtension","isA","getParent","this","isDependentBound","oDependents","getDependents","hasCorrectDependent","find","oDependent","oSourceMap","instanceMap","get","targetControl","ensureGetAPI","__apiRegistered","WeakMap","registerInstance","_instance","constructor","set","push","getAPI","defineState","propertyKey","propertyDescriptor","stateProperty","Error","writable","statePropertyDefaultValue","initializer","_exports","methodOverride","extensionName","override","overrides","currentTarget","extension","toString","extensible","overrideExecution","descriptor","hookable","publicExtension","enumerable","public","privateExtension","finalExtension","final","usingExtension","extensionClass","event","eventKey","property","attributeDefinition","bindable","isBindingInfo","group","defaultValue","aggregation","aggregationDefinition","multiple","isDefault","defaultAggregation","association","ui5AssociationMetadata","implementInterface","interfaceName","xmlEventHandler","propertykey","currentConstructor","_len","args","Array","_key","defineUI5Class","sTarget","metadataDefinition","prototype","key","isArray","concat","registerUI5Metadata","mixin","interfaceClass","baseCtor","extend","interfaceProtoTypeToMix","_addInterfaceProtoTypesToBaseClass","Object","getPrototypeOf","propagateHookFromMixin","setupMixin","createReference","current","setCurrent","oControlInstance","defineReference","BaseObject","isObjectA","baseClassMetadata","interfaceClassPrototype","getInterfaceName","getOwnPropertyNames","forEach","name","defineProperty","getOwnPropertyDescriptor","create","_getHandlerForStateProperty","jsonModel","prop","pathInModel","oObj","deepClone","getObject","oTarget","model","Proxy","p","receiver","ref","Reflect","bind","isNaN","Number","__bindingInfo","path","boundProperties","Symbol","createStateProxy","statePropertyName","boundToStateProps","initialData","setModel","JSONModel","stateModel","getModel","attachPropertyChange","evt","getParameter","substring","includes","setProperty","__stateCreated","proxy","setStateModel","value","knownBoundProperties","_ignoreStatePropertyUpdate","setResult","_updateStateDebounced","configurable","_createStateProperty","obj","updatingState","propertyName","propertyDef","bindToState","_updateState","async","_updateStateTimer","onStateChange","_changedProps","changedProp","setTimeout","__stateName","fnApplySettings","applySettings","mSettings","models","$componentState","call","fnSetProperty","sPropertyName","oValue","bSuppressInvalidate","clazz","inObj","objName","baseType","getStereotype","rendererDefinition","renderer","render","apiVersion","keys","e","cExtName","output","fnInit","init","fnAfterInit","afterInit","_this","_len2","_key2","apply","aPropertyKeys","propertyDefault","_bindingProperties","v","mProperties","propertyValue","getProperty","bindingPropertyValue","propValue","_applyingSettings","aAggregationKeys","aggregationKey","aggregationDef","setAggregation","aggregationContent","getAggregation","aAssociationKeys","associationKey","setAssociation","getAssociation","referenceProperties","methodName","methodDefinition","methodHolder","methodArrays","reverse","result","_len3","methodArgs","_key3","arg","oExtension","pol","_len4","_key4","oClass","Metadata","createClass","uid","ControllerMetadata","_staticOverride","_override","ObjectPath"],"sources":["./ClassSupport.ts"],"sourcesContent":["import ObjectPath from \"sap/base/util/ObjectPath\";\nimport deepClone from \"sap/base/util/deepClone\";\nimport merge from \"sap/base/util/merge\";\nimport uid from \"sap/base/util/uid\";\nimport { hookable, propagateHookFromMixin } from \"sap/fe/base/HookSupport\";\nimport type { Ref } from \"sap/fe/base/jsx-runtime/jsx\";\nimport type UI5Event from \"sap/ui/base/Event\";\nimport type ManagedObject from \"sap/ui/base/ManagedObject\";\nimport Metadata from \"sap/ui/base/Metadata\";\nimport BaseObject from \"sap/ui/base/Object\";\nimport type Control from \"sap/ui/core/Control\";\nimport type { $ControlSettings } from \"sap/ui/core/Control\";\nimport type UI5Element from \"sap/ui/core/Element\";\nimport type ControllerExtension from \"sap/ui/core/mvc/ControllerExtension\";\nimport ControllerMetadata from \"sap/ui/core/mvc/ControllerMetadata\";\nimport type OverrideExecution from \"sap/ui/core/mvc/OverrideExecution\";\nimport type Context from \"sap/ui/model/Context\";\nimport type { Model$PropertyChangeEvent } from \"sap/ui/model/Model\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\n\ntype OverrideDefinition = Record<string, Function>;\ntype UI5ControllerMethodDefinition = {\n\toverrideExecution?: OverrideExecution;\n\tpublic?: boolean;\n\tfinal?: boolean;\n};\nexport type NonAbstractClass<T> = Pick<T, keyof T> & (new (...args: unknown[]) => T);\n\ntype UI5PropertyMetadata = {\n\ttype: string;\n\tbindable?: boolean;\n\trequired?: boolean;\n\tgroup?: string;\n\tdefaultValue?: unknown;\n\tbyValue?: boolean;\n\tisBindingInfo?: boolean;\n\tbindToState?: boolean;\n\texpectedAnnotations?: string[];\n\texpectedTypes?: string[];\n\tallowedValues?: string[];\n\tvisibility?: string;\n};\nexport type UI5AggregationMetadata = {\n\ttype: string;\n\taltTypes?: string[];\n\tmultiple?: boolean;\n\tisDefault?: boolean;\n\tdefaultValue?: unknown;\n\tdefaultClass?: unknown;\n\tsingularName?: string;\n\tvisibility?: string;\n\tforwarding?: object;\n};\nexport type UI5AssociationMetadata = {\n\ttype: string;\n\tmultiple?: boolean;\n\tsingularName?: string;\n};\nexport type UI5ControlMetadataDefinition = {\n\tdefaultAggregation?: string;\n\tcontrollerExtensions: Record<string, typeof ControllerExtension | Function>;\n\tproperties: Record<string, UI5PropertyMetadata>;\n\taggregations: Record<string, UI5AggregationMetadata>;\n\treferences: Record<string, boolean>;\n\tassociations: Record<string, UI5AssociationMetadata>;\n\tmethods: Record<string, UI5ControllerMethodDefinition>;\n\tevents: Record<string, {}>;\n\tinterfaces: string[];\n\tlibrary?: string;\n\tdesigntime?: string;\n\tconfig?: {\n\t\tfullWidth?: boolean;\n\t};\n\tstateProperty?: string;\n\tstatePropertyDefaultValue?: unknown;\n\tmanifest?: string | unknown;\n\treturnTypes?: string[];\n\tbuildingBlockMetadata?: unknown;\n};\nexport type AccessorDescriptor<T> = TypedPropertyDescriptor<T> & { initializer?: () => T };\ntype UI5ControllerDefinition = {\n\toverride?: { extension?: Record<string, OverrideDefinition> } & {\n\t\t[k: string]: Function;\n\t};\n\toverrides?: { extension?: Record<string, OverrideDefinition> } & {\n\t\t[k: string]: Function;\n\t};\n\tmetadata?: UI5ControlMetadataDefinition;\n\trenderer?: Function;\n};\n\ntype UI5ControlDefinition = {\n\tmetadata?: UI5ControlMetadataDefinition;\n\toverride?: unknown;\n\trenderer?: Function;\n};\n\ntype UI5APIControl = Control & {\n\tgetAPI(event: UI5Event, fqdn?: string): UI5APIControl | undefined;\n\tinstanceMap: WeakMap<object, object[]>;\n\t__apiRegistered: boolean;\n} & {\n\t[k: string]: Function;\n};\n\nexport type XMLEventHolder = {\n\tgetAPI(event: UI5Event, fqdn?: string): UI5APIControl | undefined;\n\tinstanceMap: WeakMap<object, object[]>;\n};\n\ntype ControlPropertyNames<T> = {\n\t// needed because of the TS compiler\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t[K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];\nexport type PropertiesOf<T, K extends keyof T | undefined = undefined> = Partial<Pick<T, ControlPropertyNames<T>>> &\n\t(K extends keyof T ? Partial<Pick<T, K>> : {}) &\n\t$ControlSettings;\nexport type ConvertContextToString<T> = {\n\t[K in keyof T]: K extends \"metaPath\" | \"contextPath\" ? string : T[K];\n};\ntype ContextToString<T> = {\n\t[K in keyof T]: T[K] extends Context | undefined ? string | undefined : T[K];\n};\n\nexport type PropertiesOfBuildingBlock<T> = ContextToString<PropertiesOf<T>>;\nexport type StrictPropertiesOf<T> = Pick<T, ControlPropertyNames<T>>;\nexport type UI5Accessors<T> = {\n\t// Add all the getXXX method, might add too much as I'm not filtering on actual properties...\n\t[P in keyof Required<T> as `get${Capitalize<string & P>}`]: () => T[P];\n};\nexport type UI5Setters<T> = {\n\t// Add all the setXXX method, might add too much as I'm not filtering on actual properties...\n\t[P in keyof Required<T> as `set${Capitalize<string & P>}`]: (value: T[P]) => T;\n};\nexport type EnhanceWithUI5<T> = {\n\tnew (props: PropertiesOf<T>): EnhanceWithUI5<T>;\n\tnew (sId: string, props: PropertiesOf<T>): EnhanceWithUI5<T>;\n} & T &\n\tUI5Accessors<T> &\n\tUI5Setters<T>;\n\nexport type ExtensionOverrideExecution = \"Instead\" | \"Before\" | \"After\" | \"AfterAsync\" | \"BeforeAsync\";\n\nconst ensureMetadata = function (target: UI5ControllerDefinition | UI5ControlDefinition): UI5ControlMetadataDefinition {\n\ttarget.metadata = merge(\n\t\t{\n\t\t\tcontrollerExtensions: {},\n\t\t\tproperties: {},\n\t\t\taggregations: {},\n\t\t\treferences: {},\n\t\t\tassociations: {},\n\t\t\tmethods: {},\n\t\t\tevents: {},\n\t\t\tinterfaces: []\n\t\t},\n\t\ttarget.metadata ?? {}\n\t) as UI5ControlMetadataDefinition;\n\treturn target.metadata;\n};\n\n/**\n * Method that will find the correct API object based on the current control hierarchy.\n * @param target\n * @returns The proper getAPI function for this constructor\n */\nfunction prepareGetAPIFunction(target: UI5APIControl) {\n\treturn function <T extends UI5APIControl>(\n\t\tthis: UI5APIControl,\n\t\toEvent: UI5Event,\n\t\tapiFQN: string = target.getMetadata().getName()\n\t): T | undefined {\n\t\tlet oSource = oEvent.getSource() as ManagedObject | null;\n\t\tif (target._getAPIExtension) {\n\t\t\toSource = target._getAPIExtension(oSource) ?? oSource;\n\t\t}\n\t\twhile (oSource && !oSource.isA<T>(apiFQN) && oSource.getParent) {\n\t\t\tif (this.isDependentBound) {\n\t\t\t\tconst oDependents = (oSource as Control).getDependents();\n\t\t\t\tconst hasCorrectDependent = oDependents.find((oDependent: UI5Element) => oDependent.isA(apiFQN));\n\t\t\t\tif (hasCorrectDependent) {\n\t\t\t\t\toSource = hasCorrectDependent as unknown as T;\n\t\t\t\t} else {\n\t\t\t\t\toSource = oSource.getParent() as unknown as T;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toSource = oSource.getParent();\n\t\t\t}\n\t\t}\n\n\t\tif (!oSource || !oSource.isA<T>(apiFQN)) {\n\t\t\tconst oSourceMap = this.instanceMap.get(this) as T[];\n\t\t\toSource = oSourceMap?.[oSourceMap.length - 1];\n\t\t}\n\t\tlet targetControl;\n\t\tif (oSource && oSource.isA<T>(apiFQN)) {\n\t\t\ttargetControl = oSource;\n\t\t}\n\t\treturn targetControl;\n\t};\n}\n\n/**\n * Ensures that when an xmlEventHandler is defined, the `getAPI` function is properly assigned.\n * @param target The class constructor that should hold the static functions\n */\nconst ensureGetAPI = function (target: UI5APIControl): void {\n\tif (!target.__apiRegistered) {\n\t\ttarget.__apiRegistered = true;\n\t\ttarget.instanceMap = new WeakMap<object, object[]>();\n\t\ttarget.registerInstance = function (_instance: Function): void {\n\t\t\tif (!this.instanceMap.get(_instance.constructor)) {\n\t\t\t\tthis.instanceMap.set(_instance.constructor, []);\n\t\t\t}\n\t\t\t(this.instanceMap.get(_instance.constructor) as object[]).push(_instance);\n\t\t};\n\t\ttarget.getAPI = prepareGetAPIFunction(target);\n\t}\n};\n\ntype ExtendWithObject<T, K> = T extends object ? K & { [TKey in keyof T]?: BindingInfoHolder<T[TKey]> } : K;\n\nexport type StateOf<T> = {\n\t[K in keyof T]: T[K] extends Array<infer U> | ReadonlyArray<infer U> ? ExtendWithObject<U, ReadonlyArray<U>> : T[K];\n};\nexport type BindingInfoHolder<T> = T & {\n\t__bindingInfo: {\n\t\tpath: string;\n\t\tmodel: string;\n\t\ttype: T;\n\t};\n};\n\n/**\n * Allows to define a property that will hold the control state.\n *\n * Properties defined with this decorator will be automatically bound to the control state when used in JSX.\n * Arrays need to be bound using the `bindState` function.\n * @experimental\n * @returns A property decorator\n */\nexport function defineState(): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tif (metadata.stateProperty !== undefined) {\n\t\t\tthrow new Error(\"Only one state property per control is allowed\");\n\t\t}\n\t\tmetadata.stateProperty = propertyKey;\n\t\tdelete propertyDescriptor.writable;\n\t\tmetadata.statePropertyDefaultValue ??= (propertyDescriptor as { initializer?: Function }).initializer?.();\n\t\tdelete (propertyDescriptor as { initializer?: Function }).initializer;\n\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if i declare it as such.;\n}\n\n/* #region CONTROLLER EXTENSIONS */\n\n/**\n * Defines that the following method is an override for the method name with the same name in the specific controller extension or base implementation.\n * @param extensionName The name of the extension that will be overridden\n * @returns The decorated method\n */\nexport function methodOverride(extensionName?: string): MethodDecorator {\n\treturn function (target: UI5ControllerDefinition, propertyKey) {\n\t\tif (!target.override) {\n\t\t\ttarget.override = {};\n\t\t}\n\t\tif (!target.overrides) {\n\t\t\ttarget.overrides = {};\n\t\t}\n\t\tlet currentTarget = target.overrides;\n\t\tif (extensionName) {\n\t\t\tif (!currentTarget.extension) {\n\t\t\t\tcurrentTarget.extension = {};\n\t\t\t}\n\t\t\tif (!currentTarget.extension[extensionName]) {\n\t\t\t\tcurrentTarget.extension[extensionName] = {};\n\t\t\t}\n\t\t\tcurrentTarget = currentTarget.extension[extensionName];\n\t\t}\n\t\tcurrentTarget[propertyKey.toString()] = (target as Record<string, Function>)[propertyKey.toString()];\n\t};\n}\n\n/**\n * Defines that the method can be extended by other controller extension based on the defined overrideExecutionType.\n * @param overrideExecution The OverrideExecution defining when the override should run (Before / After / Instead)\n * @returns The decorated method\n */\nexport function extensible(overrideExecution: ExtensionOverrideExecution): MethodDecorator {\n\treturn function (target: UI5ControllerDefinition, propertyKey, descriptor: PropertyDescriptor) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tif (!metadata.methods[propertyKey.toString()]) {\n\t\t\tmetadata.methods[propertyKey.toString()] = {};\n\t\t}\n\t\tmetadata.methods[propertyKey.toString()].overrideExecution = overrideExecution as unknown as OverrideExecution;\n\n\t\t// by default, every extensible method is also hookable (except those defined as Instead)\n\t\tif (overrideExecution !== \"Instead\") {\n\t\t\thookable(overrideExecution)(target, propertyKey, descriptor);\n\t\t}\n\t};\n}\n\n/**\n * Defines that the method will be publicly available for controller extension usage.\n * @returns The decorated method\n */\nexport function publicExtension(): MethodDecorator {\n\treturn function (target: UI5ControllerDefinition, propertyKey, descriptor): void {\n\t\tconst metadata = ensureMetadata(target);\n\t\tdescriptor.enumerable = true;\n\t\tif (!metadata.methods[propertyKey.toString()]) {\n\t\t\tmetadata.methods[propertyKey.toString()] = {};\n\t\t}\n\t\tmetadata.methods[propertyKey.toString()].public = true;\n\t};\n}\n/**\n * Defines that the method will be only available for internal usage of the controller extension.\n * @returns The decorated method\n */\nexport function privateExtension(): MethodDecorator {\n\treturn function (target: UI5ControllerDefinition, propertyKey, descriptor) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tdescriptor.enumerable = true;\n\t\tif (!metadata.methods[propertyKey.toString()]) {\n\t\t\tmetadata.methods[propertyKey.toString()] = {};\n\t\t}\n\t\tmetadata.methods[propertyKey.toString()].public = false;\n\t};\n}\n/**\n * Defines that the method cannot be further extended by other controller extension.\n * @returns The decorated method\n */\nexport function finalExtension(): MethodDecorator {\n\treturn function (target: UI5ControllerDefinition, propertyKey, descriptor) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tdescriptor.enumerable = true;\n\t\tif (!metadata.methods[propertyKey.toString()]) {\n\t\t\tmetadata.methods[propertyKey.toString()] = {};\n\t\t}\n\t\tmetadata.methods[propertyKey.toString()].final = true;\n\t};\n}\n\n/**\n * Defines that we are going to use instantiate a controller extension under the following variable name.\n * @param extensionClass The controller extension that will be instantiated\n * @returns The decorated property\n */\nexport function usingExtension(extensionClass: typeof ControllerExtension | Function): PropertyDecorator {\n\treturn function (target: UI5ControllerDefinition, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tdelete (propertyDescriptor as { initializer?: unknown }).initializer;\n\t\tmetadata.controllerExtensions[propertyKey.toString()] = extensionClass;\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if I declare it as such.\n}\n\n/* #endregion */\n\n/* #region CONTROL */\n/**\n * Indicates that the property shall be declared as an event on the control metadata.\n * @returns The decorated property\n */\nexport function event(): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition, eventKey: string | Symbol) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tif (!metadata.events[eventKey.toString()]) {\n\t\t\tmetadata.events[eventKey.toString()] = {};\n\t\t}\n\t};\n}\n\n/**\n * Defines the following property in the control metadata.\n * @param attributeDefinition The property definition\n * @returns The decorated property.\n */\nexport function property(attributeDefinition: UI5PropertyMetadata): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tif (attributeDefinition.bindable === undefined) {\n\t\t\tattributeDefinition.bindable = true;\n\t\t}\n\t\tif (attributeDefinition.isBindingInfo === true) {\n\t\t\tattributeDefinition.bindable = false;\n\t\t\tattributeDefinition.group = \"Data\";\n\t\t}\n\t\tif (!metadata.properties[propertyKey]) {\n\t\t\tmetadata.properties[propertyKey] = attributeDefinition;\n\t\t}\n\t\tdelete propertyDescriptor.writable;\n\t\tattributeDefinition.defaultValue ??= (propertyDescriptor as { initializer?: Function }).initializer?.();\n\t\tdelete (propertyDescriptor as { initializer?: unknown }).initializer;\n\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if i declare it as such.\n}\n\n/**\n * Defines and configures the following aggregation in the control metadata.\n * @param aggregationDefinition The aggregation definition\n * @returns The decorated property.\n */\nexport function aggregation(aggregationDefinition: UI5AggregationMetadata): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tif (aggregationDefinition.multiple === undefined) {\n\t\t\t// UI5 defaults this to true but this is just weird...\n\t\t\taggregationDefinition.multiple = false;\n\t\t}\n\t\tif (!metadata.aggregations[propertyKey]) {\n\t\t\tmetadata.aggregations[propertyKey] = aggregationDefinition;\n\t\t}\n\t\tif (aggregationDefinition.isDefault) {\n\t\t\tmetadata.defaultAggregation = propertyKey;\n\t\t}\n\t\tdelete propertyDescriptor.writable;\n\t\taggregationDefinition.defaultValue ??= (propertyDescriptor as { initializer?: Function }).initializer?.();\n\t\tdelete (propertyDescriptor as { initializer?: unknown }).initializer;\n\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if I declare it as such.\n}\n\n/**\n * Defines and configures the following association in the control metadata.\n * @param ui5AssociationMetadata The definition of the association.\n * @returns The decorated property\n */\nexport function association(ui5AssociationMetadata: UI5AssociationMetadata): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tif (!metadata.associations[propertyKey]) {\n\t\t\tmetadata.associations[propertyKey] = ui5AssociationMetadata;\n\t\t}\n\t\tdelete propertyDescriptor.writable;\n\t\tdelete (propertyDescriptor as { initializer?: unknown }).initializer;\n\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if i declare it as such.\n}\n\n/**\n * Defines in the metadata that this control implements a specific interface.\n * @param interfaceName The name of the implemented interface\n * @returns The decorated method\n */\nexport function implementInterface(interfaceName: string): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition) {\n\t\tconst metadata = ensureMetadata(target);\n\n\t\tmetadata.interfaces.push(interfaceName);\n\t};\n}\n\n/**\n * Indicates that the following method should also be exposed statically so we can call it from XML.\n * @returns The decorated method\n */\nexport function xmlEventHandler(): MethodDecorator {\n\treturn function (target: UI5ControlDefinition, propertykey) {\n\t\tconst currentConstructor: UI5APIControl = target.constructor as unknown as UI5APIControl;\n\t\tensureGetAPI(currentConstructor);\n\t\tcurrentConstructor[propertykey.toString()] = function (...args: unknown[]): void {\n\t\t\tif (args?.length) {\n\t\t\t\tconst currentTarget = currentConstructor.getAPI(args[0] as UI5Event);\n\t\t\t\tcurrentTarget?.[propertykey.toString()](...args);\n\t\t\t}\n\t\t};\n\t};\n}\n\ntype UI5ControlAndMore = typeof Control &\n\tFunction & {\n\t\tregisterInstance?: Function;\n\t\toverride?: Function;\n\t\trenderer?: unknown;\n\t\trender: Function;\n\t\tmetadata?: UI5ControlMetadataDefinition;\n\t};\n\n/**\n * Indicates that the following class should define a UI5 control of the specified name.\n * @param sTarget The fully qualified name of the UI5 class\n * @param metadataDefinition Inline metadata definition\n * @returns A class decorator that will create a ui5 class\n */\nexport function defineUI5Class(sTarget: string, metadataDefinition?: Partial<UI5ControlMetadataDefinition>): ClassDecorator {\n\treturn function (constructor: UI5ControlAndMore) {\n\t\tif (!constructor.prototype.metadata) {\n\t\t\tconstructor.prototype.metadata = {};\n\t\t}\n\t\tif (metadataDefinition) {\n\t\t\tfor (const key in metadataDefinition) {\n\t\t\t\tif (constructor.prototype.metadata[key]) {\n\t\t\t\t\tif (Array.isArray(constructor.prototype.metadata[key])) {\n\t\t\t\t\t\tconstructor.prototype.metadata[key] = constructor.prototype.metadata[key].concat(\n\t\t\t\t\t\t\tmetadataDefinition[key as keyof UI5ControlMetadataDefinition]\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconstructor.prototype.metadata[key] = {\n\t\t\t\t\t\t\t...constructor.prototype.metadata[key],\n\t\t\t\t\t\t\t...(metadataDefinition[key as keyof UI5ControlMetadataDefinition] as object)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconstructor.prototype.metadata[key] = metadataDefinition[key as keyof UI5ControlMetadataDefinition];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn registerUI5Metadata(constructor, sTarget, constructor.prototype);\n\t} as ClassDecorator;\n}\ntype Constructor<T = {}> = new (...a: unknown[]) => T;\n/**\n * Mixin a specific interface including all its methods and properties into the control.\n * @param interfaceClass Implementation class of the control\n * @returns The decorated class\n */\nexport function mixin<T extends IInterfaceWithMixin>(interfaceClass: Constructor<T>): ClassDecorator {\n\treturn function (baseCtor: UI5ControlAndMore) {\n\t\tif (baseCtor.prototype.extend) {\n\t\t\tthrow new Error(\"The mixinInterface decorator must be placed after `defineUi5Class`\");\n\t\t}\n\t\tconst metadata = ensureMetadata(baseCtor.prototype);\n\n\t\tlet interfaceProtoTypeToMix = interfaceClass.prototype;\n\t\twhile (interfaceProtoTypeToMix) {\n\t\t\tbaseCtor = _addInterfaceProtoTypesToBaseClass(baseCtor, metadata, interfaceProtoTypeToMix);\n\t\t\tinterfaceProtoTypeToMix = Object.getPrototypeOf(interfaceProtoTypeToMix);\n\t\t}\n\t\tpropagateHookFromMixin(baseCtor, interfaceClass);\n\n\t\t// Hook to add potentially more logic to the mixin\n\t\tinterfaceClass.prototype.setupMixin?.(baseCtor);\n\t\treturn baseCtor;\n\t} as ClassDecorator;\n}\n\nexport interface IInterfaceWithMixin {\n\t/**\n\t * Returns the name of the interface that should be added to the receiving control.\n\t * If not defined, the interface will not be added.\n\t * @returns The name of the interface\n\t */\n\tgetInterfaceName?(): string;\n\n\t/**\n\t * Hook to add more logic to the mixin.\n\t * This is called before the controls are created and can be used to add some additional logic to the base class.\n\t * @param baseClass The base class that will be extended\n\t */\n\tsetupMixin?(baseClass: Function): void;\n}\n\nexport function createReference<T extends UI5Element>(): Ref<T> {\n\treturn {\n\t\tcurrent: undefined as unknown as T,\n\t\tsetCurrent: function (oControlInstance: T): void {\n\t\t\tthis.current = oControlInstance;\n\t\t}\n\t};\n}\n/**\n * Defines that the following object will hold a reference to a control through jsx templating.\n * @returns The decorated property.\n */\nexport function defineReference(): PropertyDecorator {\n\treturn function (target: UI5ControlDefinition, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst metadata = ensureMetadata(target);\n\t\tdelete propertyDescriptor.writable;\n\t\tdelete (propertyDescriptor as { initializer?: unknown }).initializer;\n\t\tif (BaseObject.isObjectA(target, \"sap.ui.core.Control\")) {\n\t\t\tif (!metadata.references[propertyKey]) {\n\t\t\t\tmetadata.references[propertyKey] = true;\n\t\t\t}\n\t\t} else {\n\t\t\t(propertyDescriptor as { initializer?: unknown }).initializer = createReference;\n\t\t}\n\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if i declare it as such.;\n}\n\nfunction _addInterfaceProtoTypesToBaseClass(\n\tbaseCtor: UI5ControlAndMore,\n\tbaseClassMetadata: UI5ControlMetadataDefinition,\n\tinterfaceClassPrototype: Function[\"prototype\"]\n): UI5ControlAndMore {\n\tconst interfaceName = interfaceClassPrototype?.getInterfaceName?.();\n\tif (interfaceName) {\n\t\tbaseClassMetadata.interfaces.push(interfaceName);\n\t}\n\n\tObject.getOwnPropertyNames(interfaceClassPrototype).forEach((name) => {\n\t\tif (name !== \"constructor\" && name !== \"setupMixin\" && name !== \"metadata\") {\n\t\t\tif (!baseCtor.prototype[name]) {\n\t\t\t\t// The base class \"wins\" over the mixin\n\t\t\t\tObject.defineProperty(\n\t\t\t\t\tbaseCtor.prototype,\n\t\t\t\t\tname,\n\t\t\t\t\tObject.getOwnPropertyDescriptor(interfaceClassPrototype, name) || Object.create(null)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (name === \"metadata\") {\n\t\t\tbaseCtor.prototype.metadata = merge(baseCtor.prototype.metadata, interfaceClassPrototype.metadata);\n\t\t}\n\t});\n\treturn baseCtor;\n}\n\nfunction _getHandlerForStateProperty(jsonModel: JSONModel, prop: string): unknown {\n\tconst pathInModel = `/${prop.toString()}`;\n\tconst oObj = deepClone(jsonModel.getObject(pathInModel));\n\tlet oTarget;\n\tif (prop === \"__bindingInfo\") {\n\t\treturn { model: \"$componentState\" };\n\t}\n\tif (typeof oObj === \"string\") {\n\t\toTarget = oObj;\n\t} else if (typeof oObj === \"number\") {\n\t\toTarget = oObj;\n\t} else if (typeof oObj === \"boolean\") {\n\t\toTarget = oObj;\n\t} else if (Array.isArray(oObj)) {\n\t\toTarget = new Proxy(oObj, {\n\t\t\tget(target: unknown[], p: string | symbol, receiver: unknown[]): unknown {\n\t\t\t\tconst ref = Reflect.get(target, p, receiver);\n\t\t\t\tif (typeof ref === \"function\") {\n\t\t\t\t\treturn ref.bind(target);\n\t\t\t\t} else if (ref === undefined && isNaN(Number(p.toString()))) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t__bindingInfo: {\n\t\t\t\t\t\t\tmodel: \"$componentState\",\n\t\t\t\t\t\t\tpath: p\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t});\n\t} else {\n\t\toTarget = { ...oObj };\n\t}\n\tif (typeof oTarget === \"object\") {\n\t\toTarget.__bindingInfo = {\n\t\t\tmodel: \"$componentState\",\n\t\t\tpath: pathInModel\n\t\t};\n\t}\n\treturn oTarget;\n}\nconst boundProperties = Symbol(\"boundProperties\");\n\nfunction createStateProxy(\n\ttargetControl: Control & {\n\t\t[boundProperties]: string[];\n\t\t__stateCreated: boolean;\n\t\t_updateState: Function;\n\t\t_updateStateDebounced: Function;\n\t\t_ignoreStatePropertyUpdate: boolean;\n\t\t_updateStateTimer: unknown;\n\t\t_changedProps?: string[];\n\t},\n\tstatePropertyName: string,\n\tboundToStateProps: string[],\n\tinitialData?: object\n): JSONModel {\n\t// Lazy initialization of the state property\n\ttargetControl.setModel(new JSONModel(initialData), \"$componentState\");\n\tconst stateModel = targetControl.getModel(\"$componentState\") as JSONModel;\n\tstateModel.attachPropertyChange((evt: Model$PropertyChangeEvent) => {\n\t\tconst path = evt.getParameter(\"path\")?.substring(1); // to remove the first /\n\t\tif (path && boundToStateProps.includes(path)) {\n\t\t\ttargetControl.setProperty(path, evt.getParameter(\"value\"));\n\t\t}\n\t});\n\ttargetControl.__stateCreated = true;\n\tconst proxy = new Proxy(stateModel, {\n\t\tget: (target: JSONModel, prop: string): unknown => {\n\t\t\treturn _getHandlerForStateProperty(target, prop);\n\t\t},\n\t\tset: (setStateModel: JSONModel, prop, value): boolean => {\n\t\t\t// we need to check whether the property is a known bound property in any of the related classes\n\t\t\tconst knownBoundProperties = targetControl[boundProperties];\n\t\t\tif (knownBoundProperties.includes(prop.toString())) {\n\t\t\t\ttargetControl._ignoreStatePropertyUpdate = true;\n\t\t\t\ttargetControl.setProperty(prop.toString(), value);\n\t\t\t\ttargetControl._ignoreStatePropertyUpdate = false;\n\t\t\t}\n\t\t\tconst setResult = setStateModel.setProperty(`/${prop.toString()}`, value);\n\t\t\ttargetControl._updateStateDebounced(prop.toString());\n\t\t\treturn setResult;\n\t\t}\n\t});\n\tObject.defineProperty(targetControl, statePropertyName, {\n\t\tconfigurable: true,\n\t\tget: () => {\n\t\t\treturn proxy;\n\t\t},\n\t\tset(value) {\n\t\t\t// Replacing the complete state\n\t\t\tstateModel.setProperty(`/`, value);\n\t\t}\n\t});\n\treturn proxy;\n}\n\nfunction _createStateProperty(\n\tobj: UI5ControlDefinition,\n\ttargetControl: Control & {\n\t\t[boundProperties]: string[];\n\t\t__stateCreated: boolean;\n\t\t__stateName: string;\n\t\t_updateState: Function;\n\t\t_updateStateDebounced: Function;\n\t\t_ignoreStatePropertyUpdate: boolean;\n\t\t_updateStateTimer: unknown;\n\t\t_changedProps?: string[];\n\t}\n): void {\n\tif (obj.metadata?.stateProperty || targetControl[boundProperties]) {\n\t\tlet updatingState = false;\n\t\tconst boundToStateProps: string[] = [];\n\t\tfor (const propertyName in obj.metadata?.properties) {\n\t\t\tconst propertyDef = obj.metadata.properties[propertyName];\n\t\t\tif (propertyDef.bindToState) {\n\t\t\t\tboundToStateProps.push(propertyName);\n\t\t\t}\n\t\t}\n\t\t// as we may have bound properties in parent classes and subclasses, we keep track of those in the model itself\n\t\ttargetControl[boundProperties] ??= [];\n\t\ttargetControl[boundProperties] = [...targetControl[boundProperties], ...boundToStateProps];\n\n\t\tif (obj.metadata?.stateProperty) {\n\t\t\t// This method can be used to force the state to be applied and wait for it to be applied in tests\n\t\t\ttargetControl._updateState = async function (): Promise<void> {\n\t\t\t\tdelete this._updateStateTimer;\n\t\t\t\tif (!updatingState) {\n\t\t\t\t\tupdatingState = true;\n\t\t\t\t\tawait (this as { onStateChange?: Function }).onStateChange?.(this._changedProps);\n\t\t\t\t\tthis._changedProps = [];\n\t\t\t\t\tupdatingState = false;\n\t\t\t\t}\n\t\t\t};\n\t\t\ttargetControl._updateStateDebounced = function (changedProp: string): void {\n\t\t\t\tthis._changedProps ??= [];\n\t\t\t\tif (!this._changedProps.includes(changedProp)) {\n\t\t\t\t\tthis._changedProps.push(changedProp);\n\t\t\t\t}\n\t\t\t\tif (!this._updateStateTimer && !updatingState) {\n\t\t\t\t\tthis._updateStateTimer = setTimeout(() => {\n\t\t\t\t\t\tthis._updateState();\n\t\t\t\t\t}, 200);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst statePropertyName = obj.metadata.stateProperty;\n\t\t\ttargetControl.__stateCreated = false;\n\t\t\ttargetControl.__stateName = statePropertyName;\n\t\t\tObject.defineProperty(targetControl, statePropertyName, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: () => {\n\t\t\t\t\treturn createStateProxy(targetControl, statePropertyName, targetControl[boundProperties]);\n\t\t\t\t},\n\t\t\t\tset: (value) => {\n\t\t\t\t\tcreateStateProxy(targetControl, statePropertyName, targetControl[boundProperties], value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (obj.metadata.statePropertyDefaultValue) {\n\t\t\t\ttargetControl[obj.metadata.stateProperty as keyof Control] = { ...obj.metadata.statePropertyDefaultValue } as never;\n\t\t\t}\n\t\t\tconst fnApplySettings = targetControl.applySettings;\n\t\t\ttargetControl.applySettings = function (mSettings: { models?: Record<string, never> }): typeof targetControl {\n\t\t\t\tdelete mSettings?.models?.$componentState;\n\t\t\t\treturn fnApplySettings.call(this, mSettings);\n\t\t\t};\n\t\t}\n\t\tconst fnSetProperty = targetControl.setProperty;\n\t\tif (targetControl[boundProperties].length > 0) {\n\t\t\ttargetControl.setProperty = function (sPropertyName: string, oValue: unknown, bSuppressInvalidate): typeof targetControl {\n\t\t\t\tif (targetControl[boundProperties].includes(sPropertyName) && !this._ignoreStatePropertyUpdate) {\n\t\t\t\t\tif (!this.__stateCreated) {\n\t\t\t\t\t\tcreateStateProxy(targetControl, targetControl.__stateName, targetControl[boundProperties]);\n\t\t\t\t\t}\n\t\t\t\t\t(this.getModel(\"$componentState\") as JSONModel).setProperty(`/${sPropertyName}`, oValue);\n\t\t\t\t\ttargetControl._updateStateDebounced(sPropertyName);\n\t\t\t\t}\n\t\t\t\treturn fnSetProperty.call(this, sPropertyName, oValue, bSuppressInvalidate);\n\t\t\t};\n\t\t}\n\t}\n}\n\n/**\n * Internal heavy lifting that will take care of creating the class property for ui5 to use.\n * @param clazz The class prototype\n * @param name The name of the class to create\n * @param inObj The metadata object\n * @returns The metadata class\n */\nfunction registerUI5Metadata(clazz: UI5ControlAndMore, name: string, inObj: UI5ControllerDefinition | UI5ControlDefinition): Function {\n\tif (clazz.getMetadata?.().isA(\"sap.ui.core.mvc.ControllerExtension\")) {\n\t\tObject.getOwnPropertyNames(inObj).forEach((objName) => {\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(inObj, objName);\n\t\t\tif (descriptor && !descriptor.enumerable) {\n\t\t\t\tdescriptor.enumerable = true;\n\t\t\t}\n\t\t});\n\t}\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst obj: any = {};\n\tobj.metadata = inObj.metadata || {};\n\tobj.override = inObj.override;\n\tobj.constructor = clazz;\n\tobj.metadata.baseType = Object.getPrototypeOf(clazz.prototype).getMetadata().getName();\n\n\tif ((clazz?.getMetadata() as unknown as { getStereotype: Function })?.getStereotype() === \"control\") {\n\t\tconst rendererDefinition = inObj.renderer || clazz.renderer || clazz.render;\n\t\tobj.renderer = { apiVersion: 2 };\n\t\tif (typeof rendererDefinition === \"function\") {\n\t\t\tobj.renderer.render = rendererDefinition;\n\t\t} else if (rendererDefinition != undefined) {\n\t\t\tobj.renderer = rendererDefinition;\n\t\t}\n\t}\n\tobj.metadata.interfaces = inObj.metadata?.interfaces || clazz.metadata?.interfaces;\n\tObject.keys(clazz.prototype).forEach((key) => {\n\t\tif (key !== \"metadata\") {\n\t\t\ttry {\n\t\t\t\tobj[key] = clazz.prototype[key];\n\t\t\t} catch (e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}\n\t});\n\n\tif (obj.metadata?.controllerExtensions && Object.keys(obj.metadata.controllerExtensions).length > 0) {\n\t\tfor (const cExtName in obj.metadata.controllerExtensions) {\n\t\t\tobj[cExtName] = obj.metadata.controllerExtensions[cExtName];\n\t\t}\n\t}\n\tconst output = clazz.extend(name, obj) as typeof Control & Function;\n\tconst fnInit = output.prototype.init;\n\tconst fnAfterInit = output.prototype.afterInit;\n\toutput.prototype.init = function (...args: unknown[]): void {\n\t\tif (fnInit) {\n\t\t\tfnInit.apply(this, args);\n\t\t}\n\t\tif (clazz.registerInstance) {\n\t\t\tclazz.registerInstance(this);\n\t\t}\n\t\tthis.metadata = obj.metadata;\n\n\t\tif (obj.metadata.properties) {\n\t\t\tconst aPropertyKeys = Object.keys(obj.metadata.properties);\n\t\t\taPropertyKeys.forEach((propertyKey) => {\n\t\t\t\tconst propertyDef = obj.metadata.properties[propertyKey];\n\t\t\t\t// If a value was set in `init` we need to make sure it is set in the value in the end\n\t\t\t\tconst propertyDefault = this[propertyKey] ?? propertyDef.defaultValue;\n\t\t\t\tif (propertyDef.isBindingInfo === true) {\n\t\t\t\t\tthis._bindingProperties ??= {};\n\n\t\t\t\t\tObject.defineProperty(this, propertyKey, {\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tset: (v: unknown) => {\n\t\t\t\t\t\t\tthis._bindingProperties[propertyKey] = v;\n\t\t\t\t\t\t\tthis.mProperties[propertyKey] = v;\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget(): unknown {\n\t\t\t\t\t\t\t// Special case we need to consider the property first and not just the _bindingProperties\n\t\t\t\t\t\t\t// During the initialization, if the property is set with a non binding value, setProperty is called and not bindProperty\n\t\t\t\t\t\t\tconst propertyValue = this.getProperty(propertyKey);\n\t\t\t\t\t\t\tconst bindingPropertyValue = this._bindingProperties[propertyKey];\n\t\t\t\t\t\t\t// If the property is set to a different value we update the _bindingProperties\n\t\t\t\t\t\t\tif (propertyValue !== undefined && propertyValue !== bindingPropertyValue) {\n\t\t\t\t\t\t\t\tthis._bindingProperties[propertyKey] = propertyValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst propValue = this._bindingProperties[propertyKey];\n\t\t\t\t\t\t\tif (typeof propValue === \"object\") {\n\t\t\t\t\t\t\t\treturn { ...propValue }; // Create shallow copy\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn propValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty(this, propertyKey, {\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tset: (v: unknown) => {\n\t\t\t\t\t\t\treturn this.setProperty(propertyKey, v);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget: () => {\n\t\t\t\t\t\t\treturn this.getProperty(propertyKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (propertyDefault !== undefined && this[propertyKey] !== propertyDefault) {\n\t\t\t\t\t// don't overwrite the default value if it's already there\n\t\t\t\t\tthis._applyingSettings = true;\n\t\t\t\t\tthis[propertyKey] = propertyDefault;\n\t\t\t\t\tthis._applyingSettings = false;\n\t\t\t\t\tdelete this._applyingSettings;\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst aAggregationKeys = Object.keys(obj.metadata.aggregations);\n\t\t\taAggregationKeys.forEach((aggregationKey) => {\n\t\t\t\tconst aggregationDef = obj.metadata.aggregations[aggregationKey];\n\t\t\t\tconst defaultValue = this[aggregationKey] ?? aggregationDef.defaultValue;\n\t\t\t\tObject.defineProperty(this, aggregationKey, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tset: (v: unknown) => {\n\t\t\t\t\t\treturn this.setAggregation(aggregationKey, v);\n\t\t\t\t\t},\n\t\t\t\t\tget: () => {\n\t\t\t\t\t\tconst aggregationContent = this.getAggregation(aggregationKey);\n\t\t\t\t\t\tif (obj.metadata.aggregations[aggregationKey].multiple) {\n\t\t\t\t\t\t\treturn aggregationContent || [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn aggregationContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (defaultValue && (defaultValue as UI5Element)?.isA) {\n\t\t\t\t\tthis._applyingSettings = true;\n\t\t\t\t\tthis[aggregationKey] = defaultValue;\n\t\t\t\t\tthis._applyingSettings = false;\n\t\t\t\t\tdelete this._applyingSettings;\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst aAssociationKeys = Object.keys(obj.metadata.associations);\n\t\t\taAssociationKeys.forEach((associationKey) => {\n\t\t\t\tObject.defineProperty(this, associationKey, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tset: (v: unknown) => {\n\t\t\t\t\t\treturn this.setAssociation(associationKey, v);\n\t\t\t\t\t},\n\t\t\t\t\tget: () => {\n\t\t\t\t\t\tconst aggregationContent = this.getAssociation(associationKey);\n\t\t\t\t\t\tif (obj.metadata.associations[associationKey].multiple) {\n\t\t\t\t\t\t\treturn aggregationContent || [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn aggregationContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif (obj.metadata.references) {\n\t\t\tconst referenceProperties = Object.keys(obj.metadata.references);\n\t\t\treferenceProperties.forEach((propertyKey) => {\n\t\t\t\tObject.defineProperty(this, propertyKey, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tvalue: createReference()\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif (obj.metadata.methods) {\n\t\t\tfor (const methodName in obj.metadata.methods) {\n\t\t\t\tconst methodDefinition = obj.metadata.methods[methodName];\n\t\t\t\tif (methodDefinition.overrideExecution === \"AfterAsync\" || methodDefinition.overrideExecution === \"BeforeAsync\") {\n\t\t\t\t\tif (!this.methodHolder) {\n\t\t\t\t\t\tthis.methodHolder = [];\n\t\t\t\t\t}\n\t\t\t\t\tthis.methodHolder[methodName] = [this[methodName]];\n\t\t\t\t\tObject.defineProperty(this, methodName, {\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tset: (v: Function) => {\n\t\t\t\t\t\t\treturn this.methodHolder[methodName].push(v);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget: () => {\n\t\t\t\t\t\t\treturn async (...methodArgs: unknown[]) => {\n\t\t\t\t\t\t\t\tconst methodArrays = this.methodHolder[methodName];\n\t\t\t\t\t\t\t\tif (methodDefinition.overrideExecution === \"BeforeAsync\") {\n\t\t\t\t\t\t\t\t\tmethodArrays.reverse();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet result;\n\t\t\t\t\t\t\t\tfor (const arg of methodArrays) {\n\t\t\t\t\t\t\t\t\tresult = await arg.apply(this, methodArgs);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_createStateProperty(obj, this);\n\t\tif (fnAfterInit) {\n\t\t\tfnAfterInit.apply(this, args);\n\t\t}\n\t};\n\n\tclazz.override = function (oExtension: unknown): Function {\n\t\tconst pol = {};\n\t\t(pol as Function).constructor = function (...args: unknown[]): Function {\n\t\t\treturn clazz.apply(this, args);\n\t\t};\n\t\tconst oClass = (Metadata as unknown as { createClass: Function }).createClass(\n\t\t\tclazz,\n\t\t\t`anonymousExtension~${uid()}`,\n\t\t\tpol,\n\t\t\tControllerMetadata\n\t\t);\n\t\toClass.getMetadata()._staticOverride = oExtension;\n\t\toClass.getMetadata()._override = (clazz.getMetadata() as { _override?: unknown })._override;\n\t\treturn oClass;\n\t};\n\n\tObjectPath.set(name, output);\n\n\treturn output;\n}\n"],"mappings":"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","ignoreList":[],"sourceRoot":""}},{"offset":{"line":21,"column":0},"map":{"version":3,"names":["EventDelegateHook","_dec","defineUI5Class","_dec2","property","type","_dec3","event","_class","_class2","_Element","idOrSettings","settings","_this","call","this","_initializerDefineProperty","_descriptor","_descriptor2","_exports","_inheritsLoose","_proto","prototype","setParent","parentObject","aggregationName","suppressInvalidate","getParent","removeEventDelegate","addEventDelegate","ontap","tapEvent","stopTapPropagation","stopPropagation","fireEvent","Element","_applyDecoratedDescriptor","configurable","enumerable","writable","initializer"],"sources":["./EventDelegateHook.ts"],"sourcesContent":["import type { PropertiesOf } from \"sap/fe/base/ClassSupport\";\nimport { defineUI5Class, event, property } from \"sap/fe/base/ClassSupport\";\nimport type { $ElementSettings } from \"sap/ui/core/Element\";\nimport Element from \"sap/ui/core/Element\";\nimport type { EventHandler } from \"types/extension_types\";\n\n/**\n * Create an event delegate hook on the parent of this control to deal with event propagation.\n *\n * This is a specific solution for the Avatar control case where the press cannot be interrupted and which then ends up interacting with control behind it.\n *\n */\n@defineUI5Class(\"sap.fe.base.EventDelegateHook\")\nexport default class EventDelegateHook extends Element {\n\t@property({ type: \"boolean\" })\n\tstopTapPropagation = false;\n\n\t@event()\n\ttap?: EventHandler;\n\n\tconstructor(idOrSettings?: EventDelegateSettings);\n\n\tconstructor(idOrSettings: string, settings?: EventDelegateSettings);\n\n\tconstructor(idOrSettings?: string | PropertiesOf<EventDelegateHook>, settings?: EventDelegateSettings) {\n\t\tsuper(idOrSettings as string, settings);\n\t}\n\n\tsetParent(parentObject: Element, aggregationName: string, suppressInvalidate: boolean): void {\n\t\tif (this.getParent()) {\n\t\t\t(this.getParent() as Element).removeEventDelegate(this);\n\t\t}\n\t\tparentObject.addEventDelegate(this);\n\t\tsuper.setParent(parentObject, aggregationName, suppressInvalidate);\n\t}\n\n\tontap(tapEvent: JQuery.Event): void {\n\t\tif (this.stopTapPropagation) {\n\t\t\ttapEvent.stopPropagation();\n\t\t}\n\t\tthis.fireEvent(\"tap\");\n\t}\n}\n\ntype EventDelegateSettings = $ElementSettings & PropertiesOf<EventDelegateHook>;\n"],"mappings":"AAAA;;;;qpCAMA,IAOqBA,GAAiBC,EADrCC,EAAe,iCAAgCC,EAE9CC,EAAS,CAAEC,KAAM,YAAYC,EAG7BC,IAAON,EAAAO,GAAAC,EAAA,SAAAC,GAOR,SAAAV,EAAYW,EAAyDC,GAAkC,IAAAC,EACtGA,EAAAH,EAAAI,KAAAC,KAAMJ,EAAwBC,IAASG,KAACC,EAAAH,EAAA,qBAAAI,EAAAJ,GAAAG,EAAAH,EAAA,MAAAK,EAAAL,GAAA,OAAAA,CACzC,CAACM,EAAAnB,EAAAoB,EAAApB,EAAAU,GAAA,IAAAW,EAAArB,EAAAsB,UAAAD,EAEDE,UAAA,SAAAA,EAAUC,EAAuBC,EAAyBC,GACzD,GAAIX,KAAKY,YAAa,CACpBZ,KAAKY,YAAwBC,oBAAoBb,KACnD,CACAS,EAAaK,iBAAiBd,MAC9BL,EAAAY,UAAMC,UAAST,KAAAC,KAACS,EAAcC,EAAiBC,EAChD,EAACL,EAEDS,MAAA,SAAAA,EAAMC,GACL,GAAIhB,KAAKiB,mBAAoB,CAC5BD,EAASE,iBACV,CACAlB,KAAKmB,UAAU,MAChB,EAAC,OAAAlC,CAAA,CAxBO,CAJsCmC,GAAOlB,EAAAmB,EAAA3B,EAAAa,UAAA,sBAAAnB,GAAA,CAAAkC,aAAA,KAAAC,WAAA,KAAAC,SAAA,KAAAC,YAAA,kBAEhC,KAAK,IAAAtB,EAAAkB,EAAA3B,EAAAa,UAAA,OAAAhB,GAAA,CAAA+B,aAAA,KAAAC,WAAA,KAAAC,SAAA,KAAAC,YAAA,OAAA/B,KAAAD,GAAAW,EAAAnB,EAAA,OAAAmB,CAAA","ignoreList":[],"sourceRoot":""}},{"offset":{"line":26,"column":0},"map":{"version":3,"names":["registeredInstances","registeredHandlers","hookable","execution","target","propertyKey","descriptor","indexableTarget","toString","fn","cExTInstanceHookMap","this","hookedHandlers","push","handlers","index","indexOf","splice","oldValue","value","async","returnValue","bind","arguments","handler","_exports","isAlreadyRegistered","existingRegistrations","newRegistration","find","r","name","method","targetMethod","hooks","Symbol","controllerExtensionHandler","String","constructor","Object","defineProperty","initControllerExtensionHookHandlers","controller","registeredHooks","deepClone","indexableController","registeredHook","handlerFunction","getView","attachBeforeExit","removeControllerExtensionHookHandlers","propagateHookFromMixin","source","getOwnPropertyDescriptor","create","xmlViewPreprocessor","_caller","_settings","sourceView","getController","macroAPIChild","findAggregatedObjects","s","isA","managedObject"],"sources":["./HookSupport.ts"],"sourcesContent":["import deepClone from \"sap/base/util/deepClone\";\nimport type { ExtensionOverrideExecution } from \"sap/fe/base/ClassSupport\";\nimport type Controller from \"sap/ui/core/mvc/Controller\";\nimport type XMLView from \"sap/ui/core/mvc/XMLView\";\n/**\n * This type is to be extended with all controller extensions and methods that are hookable.\n */\ntype HookableControllerExtensions = {\n\teditFlow: {\n\t\tonAfterSave: true;\n\t\tonBeforeSave: true;\n\t};\n\tinlineEditFlow: {\n\t\tinlineEditEnd: true;\n\t\tinlineEditStart: true;\n\t};\n\tcollaborationManager: {\n\t\tcollectAvailableCards: true;\n\t};\n\tpaginator: {\n\t\tinitialize: true;\n\t};\n\trouting: {\n\t\tonAfterBinding: true;\n\t};\n};\n\ntype HandlerConfiguration<CExtName extends keyof HookableControllerExtensions> = {\n\tname: CExtName;\n\tmethod: keyof HookableControllerExtensions[CExtName];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype HandlerRegistration = HandlerConfiguration<any> & { targetMethod: string; handlerFunction?: Function };\n\ntype FunctionMap = {\n\t[key: string]: Function;\n};\ntype DeepFunctionMap = {\n\t[key: string]: FunctionMap;\n};\ntype HookMap = {\n\thookedHandlers: {\n\t\t[key: string]: Function[];\n\t};\n};\n\n// Use two arrays as we cannot index a map through an arbitrary object instance\nconst registeredInstances: Function[] = [];\nconst registeredHandlers: HandlerRegistration[][] = [];\n\n/**\n * Marks a controller extension method to be hookable by generating additional methods that can be used to attach and detach handlers at runtime.\n * @param execution\n * @returns A method decorator\n */\nexport function hookable(execution: ExtensionOverrideExecution): MethodDecorator {\n\treturn function (target: unknown, propertyKey: string | symbol, descriptor: PropertyDescriptor) {\n\t\tconst indexableTarget = target as FunctionMap;\n\n\t\tindexableTarget[`attach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers = {};\n\t\t\t}\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers[propertyKey.toString()]) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()] = [];\n\t\t\t}\n\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()].push(fn);\n\t\t};\n\t\tindexableTarget[`detach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tconst handlers = cExTInstanceHookMap.hookedHandlers[propertyKey.toString()];\n\t\t\tconst index = handlers.indexOf(fn);\n\t\t\tif (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t};\n\n\t\tconst oldValue = descriptor.value;\n\t\tif (execution === \"BeforeAsync\" || execution === \"AfterAsync\") {\n\t\t\tdescriptor.value = async function (...args: unknown[]): Promise<unknown> {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"AfterAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tawait handler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"BeforeAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t} else {\n\t\t\tdescriptor.value = function (...args: unknown[]): unknown {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"After\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\thandler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"Before\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t}\n\t};\n}\n\n/**\n * Checks whether a newRegistration is already included in some existingRegistrations by comparing all relevant attributes.\n * @param existingRegistrations\n * @param newRegistration\n * @returns Result of the check\n */\nfunction isAlreadyRegistered(existingRegistrations: HandlerRegistration[], newRegistration: HandlerRegistration): boolean {\n\treturn !!existingRegistrations.find(\n\t\t(r) => r.name === newRegistration.name && r.method === newRegistration.method && r.targetMethod === newRegistration.targetMethod\n\t);\n}\n\nexport const hooks = Symbol(\"hooks\");\n\n/**\n * Registers a method as controller extension hook handler.\n *\n * Currently, only methods of runtime building blocks are supported.\n * @param name Controller extension to hook into\n * @param method Method to hook into\n * @returns A method decorator\n */\nexport function controllerExtensionHandler<CExtName extends keyof HookableControllerExtensions>(\n\tname: CExtName,\n\tmethod: keyof HookableControllerExtensions[CExtName]\n): MethodDecorator {\n\treturn function (target: { constructor: Function & { [hooks]?: HandlerRegistration[] } }, propertyKey: string) {\n\t\tconst newRegistration = { name, method: String(method), targetMethod: propertyKey };\n\t\tconst index = registeredInstances.indexOf(target.constructor);\n\t\tif (!target.constructor[hooks]) {\n\t\t\tObject.defineProperty(target.constructor, hooks, {\n\t\t\t\tvalue: []\n\t\t\t});\n\t\t}\n\t\ttarget.constructor[hooks]?.push(newRegistration);\n\t\t// We need to check if this exact handler is already registered as handlers are registered statically (on the constructor)\n\t\tif (index !== -1 && !isAlreadyRegistered(registeredHandlers[index], newRegistration)) {\n\t\t\tregisteredHandlers[index].push(newRegistration);\n\t\t} else {\n\t\t\tregisteredInstances.push(target.constructor);\n\t\t\tregisteredHandlers.push([newRegistration]);\n\t\t}\n\t} as MethodDecorator;\n}\n\n/**\n * Initializes all controller extension handlers registered for a given target.\n * @param target Target class to initialize the handlers for\n * @param target.constructor\n * @param controller PageController instance to get the controller extensions instances from\n */\nexport function initControllerExtensionHookHandlers(\n\ttarget: { constructor: Function & { [hooks]?: HandlerRegistration[] } } & { [hooks]?: HandlerRegistration[] },\n\tcontroller: Controller\n): void {\n\tif (target.constructor[hooks]) {\n\t\tlet registeredHooks = target.constructor[hooks];\n\t\ttarget[hooks] = deepClone(registeredHooks);\n\t\tregisteredHooks = target[hooks]!;\n\t\tconst indexableTarget = target as unknown as FunctionMap;\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tfor (const registeredHook of registeredHooks) {\n\t\t\tregisteredHook.handlerFunction = indexableTarget[registeredHook.targetMethod].bind(target);\n\t\t\tindexableController[registeredHook.name][`attach${String(registeredHook.method)}`](registeredHook.handlerFunction);\n\t\t\tcontroller.getView()?.attachBeforeExit(() => {\n\t\t\t\tindexableController[registeredHook.name][`detach${String(registeredHook.method)}`](registeredHook.handlerFunction);\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport function removeControllerExtensionHookHandlers(\n\ttarget: { constructor: Function & { [hooks]?: HandlerRegistration[] } } & { [hooks]?: HandlerRegistration[] },\n\tcontroller: Controller\n): void {\n\tif (target[hooks]) {\n\t\tconst registeredHooks = target[hooks];\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tfor (const registeredHook of registeredHooks) {\n\t\t\tindexableController[registeredHook.name]?.[`detach${String(registeredHook.method)}`]?.(registeredHook.handlerFunction);\n\t\t}\n\t}\n}\n\nexport function propagateHookFromMixin(\n\ttarget: Function & { [hooks]?: HandlerRegistration[] },\n\tsource: Function & { [hooks]?: HandlerRegistration[] }\n): void {\n\tif (source[hooks]) {\n\t\tif (target[hooks]) {\n\t\t\ttarget[hooks]!.splice(0, 0, ...source[hooks]);\n\t\t} else {\n\t\t\tObject.defineProperty(target, hooks, Object.getOwnPropertyDescriptor(source, hooks) || Object.create([]));\n\t\t}\n\t}\n}\n\nexport function xmlViewPreprocessor(source: object, _caller?: unknown, _settings?: object): void {\n\tconst sourceView = source as XMLView;\n\tconst controller = sourceView.getController() as Controller | undefined;\n\tif (controller) {\n\t\tconst macroAPIChild = sourceView.findAggregatedObjects(true, (s) => s.isA(\"sap.fe.macros.MacroAPI\"));\n\t\tfor (const managedObject of macroAPIChild) {\n\t\t\tinitControllerExtensionHookHandlers(managedObject, controller);\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[],"sourceRoot":""}},{"offset":{"line":31,"column":0},"map":{"version":3,"names":["jsxs","jsx"],"sources":["./jsx-runtime.ts"],"sourcesContent":["import jsx from \"sap/fe/base/jsx-runtime/jsx\";\nimport jsxs from \"sap/fe/base/jsx-runtime/jsxs\";\n\n/**\n * When coming from the JSX factory, the JSX factory will call this function with the type of the element, the props and the children.\n * The babel plugin expect this file to exist.\n */\nexport default { jsxs, jsx };\n"],"mappings":"AAAA;;;;sIAGA,MAIe,CAAEA,OAAMC,MAAK","ignoreList":[],"sourceRoot":""}},{"offset":{"line":36,"column":0},"map":{"version":3,"names":["Fragment","isFragment","_exports"],"sources":["./Fragment.ts"],"sourcesContent":["export default class Fragment {\n\tstatic isFragment = true;\n}\n"],"mappings":"AAAA;;;;6FAAqBA,EAAQ,SAAAA,IAAA,EAARA,EACbC,WAAa,KAAIC,EAAAF,EAAA,OAAAE,CAAA","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":41,"column":0},"map":{"version":3,"names":["ViewLoader","_dec","defineUI5Class","_dec2","property","type","_class","_class2","_View","mSettings","_this","cache","call","this","_initializerDefineProperty","_descriptor","sViewName","viewName","_oContainingView","_exports","_inheritsLoose","_proto","prototype","loadDependency","async","name","Promise","resolve","sap","ui","require","MDXContent","initViewSettings","viewConfig","getViewData","viewContent","_jsxViewName","getMetadata","isA","controller","viewContentFn","getControllerName","viewData","controllerName","createContent","oController","preprocessorData","mPreprocessors","xml","owner","Component","getOwnerComponentFor","runAsOwner","fn","ManagedObject","runWithPreprocessors","render","id","sId","createId","settings","View","_applyDecoratedDescriptor","configurable","enumerable","writable","initializer"],"sources":["./ViewLoader.tsx"],"sourcesContent":["import type { NonAbstractClass } from \"sap/fe/base/ClassSupport\";\nimport { defineUI5Class, property } from \"sap/fe/base/ClassSupport\";\nimport type { XMLPreprocessorContext } from \"sap/fe/core/TemplateComponent\";\nimport ManagedObject from \"sap/ui/base/ManagedObject\";\nimport Component from \"sap/ui/core/Component\";\nimport type Control from \"sap/ui/core/Control\";\nimport type { $ControlSettings } from \"sap/ui/core/Control\";\nimport type Controller from \"sap/ui/core/mvc/Controller\";\nimport View from \"sap/ui/core/mvc/View\";\nimport type { ManagedObjectEx } from \"../../../../../../../types/extension_types\";\n\ntype JSXViewController = Controller & { render?: () => Control };\n@defineUI5Class(\"sap.fe.base.jsx-runtime.MDXViewLoader\")\nexport default class ViewLoader extends View {\n\tstatic preprocessorData?: XMLPreprocessorContext;\n\n\tstatic controller: Controller;\n\n\t@property({ type: \"string\" })\n\tviewName!: string;\n\n\tprivate viewContent?: Control;\n\n\tprivate viewContentFn?: Function;\n\n\tpublic sViewName: string;\n\n\tpublic _oContainingView: this;\n\n\tconstructor(mSettings: Record<string, unknown>) {\n\t\tdelete mSettings.cache;\n\t\tsuper(mSettings);\n\t\tthis.sViewName = this.viewName;\n\t\tthis._oContainingView = this;\n\t}\n\n\tasync loadDependency(name: string): Promise<unknown> {\n\t\treturn new Promise((resolve) => {\n\t\t\tsap.ui.require([name], (MDXContent: Function): void => {\n\t\t\t\tresolve(MDXContent);\n\t\t\t});\n\t\t});\n\t}\n\n\tasync initViewSettings(mSettings: Record<string, unknown>): Promise<void> {\n\t\tconst viewConfig = this.getViewData() as { viewContent?: Control; _jsxViewName: string } & Record<string, unknown>;\n\t\tconst viewContent = viewConfig.viewContent || ((await this.loadDependency(viewConfig._jsxViewName)) as Control | Function);\n\t\tdelete mSettings.cache;\n\t\tif ((viewContent as Control)?.getMetadata?.().isA(\"sap.ui.core.mvc.Controller\")) {\n\t\t\tmSettings.controller = new (viewContent as NonAbstractClass<Control>)(viewConfig as $ControlSettings);\n\t\t} else {\n\t\t\tthis.viewContentFn = viewContent as Function;\n\t\t}\n\t}\n\n\tgetControllerName(): string {\n\t\tconst viewData = this.getViewData() as { controllerName: string };\n\t\treturn viewData.controllerName;\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t// @ts-ignore\n\tcreateContent(oController: JSXViewController): Control {\n\t\tViewLoader.preprocessorData = (this as { mPreprocessors?: { xml?: XMLPreprocessorContext } })?.mPreprocessors?.xml;\n\t\tViewLoader.controller = oController;\n\n\t\tconst owner = Component.getOwnerComponentFor(this)! ?? { runAsOwner: (fn: Function) => fn() };\n\t\treturn owner.runAsOwner(() => {\n\t\t\treturn (ManagedObject as ManagedObjectEx).runWithPreprocessors(\n\t\t\t\t() => {\n\t\t\t\t\tif (oController && oController.render) {\n\t\t\t\t\t\treturn oController.render();\n\t\t\t\t\t}\n\t\t\t\t\treturn this.viewContentFn?.();\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: (sId: string) => {\n\t\t\t\t\t\treturn this.createId(sId);\n\t\t\t\t\t},\n\t\t\t\t\tsettings: function () {\n\t\t\t\t\t\tthis.controller = oController;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n"],"mappings":"AAAA;;;;qsCAaqBA,GAAUC,EAD9BC,EAAe,yCAAwCC,EAMtDC,EAAS,CAAEC,KAAM,WAAWJ,EAAAK,GAAAC,EAAA,SAAAC,GAW7B,SAAAR,EAAYS,GAAoC,IAAAC,SACxCD,EAAUE,MACjBD,EAAAF,EAAAI,KAAAC,KAAMJ,IAAUI,KAACC,EAAAJ,EAAA,WAAAK,EAAAL,GACjBA,EAAKM,UAAYN,EAAKO,SACtBP,EAAKQ,iBAAgBR,EAAQ,OAAAA,CAC9B,CAACS,EAAAnB,EAAAoB,EAAApB,EAAAQ,GAAA,IAAAa,EAAArB,EAAAsB,UAAAD,EAEKE,eAANC,eAAMD,EAAeE,GACpB,OAAO,IAAIC,QAASC,IACnBC,IAAIC,GAAGC,QAAQ,CAACL,GAAQM,IACvBJ,EAAQI,MAGX,EAACV,EAEKW,iBAANR,eAAMQ,EAAiBvB,GACtB,MAAMwB,EAAapB,KAAKqB,cACxB,MAAMC,EAAcF,EAAWE,mBAAuBtB,KAAKU,eAAeU,EAAWG,qBAC9E3B,EAAUE,MACjB,GAAKwB,GAAyBE,gBAAgBC,IAAI,8BAA+B,CAChF7B,EAAU8B,WAAa,IAAKJ,EAA0CF,EACvE,KAAO,CACNpB,KAAK2B,cAAgBL,CACtB,CACD,EAACd,EAEDoB,kBAAA,SAAAA,IACC,MAAMC,EAAW7B,KAAKqB,cACtB,OAAOQ,EAASC,cACjB,EAGAtB,EACAuB,cAAA,SAAAA,EAAcC,GACb7C,EAAW8C,iBAAoBjC,MAAgEkC,gBAAgBC,IAC/GhD,EAAWuC,WAAaM,EAExB,MAAMI,EAAQC,EAAUC,qBAAqBtC,OAAU,CAAEuC,WAAaC,GAAiBA,KACvF,OAAOJ,EAAMG,WAAW,IACfE,EAAkCC,qBACzC,KACC,GAAIV,GAAeA,EAAYW,OAAQ,CACtC,OAAOX,EAAYW,QACpB,CACA,OAAO3C,KAAK2B,mBAEb,CACCiB,GAAKC,GACG7C,KAAK8C,SAASD,GAEtBE,SAAU,WACT/C,KAAK0B,WAAaM,CACnB,IAIJ,EAAC,OAAA7C,CAAA,CAnE4B,CALU6D,GAAI9C,EAAA+C,EAAAvD,EAAAe,UAAA,YAAAnB,GAAA,CAAA4D,aAAA,KAAAC,WAAA,KAAAC,SAAA,KAAAC,YAAA,OAAA3D,KAAAD,GAAAa,EAAAnB,EAAA,OAAAmB,CAAA","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":46,"column":0},"map":{"version":3,"names":["FL_DELEGATE","CORE_REQUIRE","DT_DESIGNTIME","addChildAggregation","aggregationChildren","aggregationName","child","undefined","isChildAnElement","push","Array","isArray","forEach","subChild","Object","keys","childKey","children","isA","isAControl","getMetadata","processAggregations","metadata","mSettings","metadataAggregations","getAllAggregations","defaultAggregationName","getDefaultAggregationName","hasOwnProperty","resultingParse","BindingParser","complexParser","path","model","factory","template","processBindingToolkitExpression","settings","settingsKey","bindingToolkitExpression","allProperties","isConstant","compileConstant","call","isPathInModelExpression","modelName","compileExpression","processStringProperty","value","allEvents","startsWith","Log","error","getName","propertyType","getType","DataType","includes","parseValue","processObjectProperty","lateProperties","then","__bindingInfo","processProperties","getAllEvents","getAllProperties","isBindingToolkitExpression","processCommand","commandProperty","command","eventName","split","event","name","EventHandlerResolver","resolveEventHandler","jsxControl","ControlType","key","jsxContext","targetControl","isFragment","classDef","class","refDef","ref","bindingDef","binding","flDelegate","dtDesigntime","targetControlInstance","addStyleClass","setCurrent","customSettings","data","delegate","designtime","length","bindingInfo","bindingParser","bindElement","parameters","bindingDefKey","latePropertiesKey","setProperty","catch","controlTypeFn","Text","text"],"sources":["./jsx-control.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tcompileConstant,\n\tcompileExpression,\n\tisBindingToolkitExpression,\n\tisConstant,\n\tisPathInModelExpression\n} from \"sap/fe/base/BindingToolkit\";\nimport type { BindingInfoHolder, NonAbstractClass } from \"sap/fe/base/ClassSupport\";\nimport type { ControlProperties, JSXContext, NonControlProperties, Ref } from \"sap/fe/base/jsx-runtime/jsx\";\nimport Text from \"sap/m/Text\";\nimport BindingParser from \"sap/ui/base/BindingParser\";\nimport DataType from \"sap/ui/base/DataType\";\nimport { bindingParser } from \"sap/ui/base/ManagedObject\";\nimport type ManagedObjectMetadata from \"sap/ui/base/ManagedObjectMetadata\";\nimport type Control from \"sap/ui/core/Control\";\nimport type { $ControlSettings } from \"sap/ui/core/Control\";\nimport type { default as Element, default as UI5Element } from \"sap/ui/core/Element\";\nimport EventHandlerResolver from \"sap/ui/core/mvc/EventHandlerResolver\";\n\nconst FL_DELEGATE = \"fl:delegate\";\nconst CORE_REQUIRE = \"core:require\";\nconst DT_DESIGNTIME = \"dt:designtime\";\nconst addChildAggregation = function (\n\taggregationChildren: Record<string, (string | UI5Element)[]>,\n\taggregationName: string,\n\tchild?: string | UI5Element | UI5Element[]\n): void {\n\tif (child === null || child === undefined || typeof child === \"string\") {\n\t\treturn;\n\t}\n\tif (!aggregationChildren[aggregationName]) {\n\t\taggregationChildren[aggregationName] = [];\n\t}\n\tif (isChildAnElement(child)) {\n\t\taggregationChildren[aggregationName].push(child);\n\t} else if (Array.isArray(child)) {\n\t\tchild.forEach((subChild) => {\n\t\t\taddChildAggregation(aggregationChildren, aggregationName, subChild);\n\t\t});\n\t} else if (typeof child === \"function\") {\n\t\taggregationChildren[aggregationName] = child;\n\t} else {\n\t\tObject.keys(child).forEach((childKey) => {\n\t\t\taddChildAggregation(aggregationChildren, childKey, child[childKey]);\n\t\t});\n\t}\n};\nconst isChildAnElement = function (children?: unknown): children is Element {\n\treturn (children as Element)?.isA?.(\"sap.ui.core.Element\");\n};\nconst isAControl = function (children?: typeof Control | Function): children is NonAbstractClass<Control> {\n\treturn !!(children as typeof Control)?.getMetadata;\n};\n\nfunction processAggregations(metadata: ManagedObjectMetadata, mSettings: Record<string, unknown>): void {\n\tconst metadataAggregations = metadata.getAllAggregations();\n\tconst defaultAggregationName = metadata.getDefaultAggregationName();\n\tconst aggregationChildren: Record<string, (string | UI5Element)[]> = {};\n\taddChildAggregation(aggregationChildren, defaultAggregationName, mSettings.children as string | UI5Element | UI5Element[]);\n\tdelete mSettings.children;\n\t// find out which aggregation are bound (both in children and directly under it)\n\tObject.keys(metadataAggregations).forEach((aggregationName) => {\n\t\tif (aggregationChildren[aggregationName] !== undefined) {\n\t\t\tif (mSettings.hasOwnProperty(aggregationName)) {\n\t\t\t\tif (typeof mSettings[aggregationName] === \"string\") {\n\t\t\t\t\tconst resultingParse = BindingParser.complexParser(mSettings[aggregationName]);\n\t\t\t\t\tif (resultingParse) {\n\t\t\t\t\t\tmSettings[aggregationName] = {\n\t\t\t\t\t\t\tpath: resultingParse.path,\n\t\t\t\t\t\t\tmodel: resultingParse.model\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmSettings[aggregationName] = {\n\t\t\t\t\t\t\tpath: mSettings[aggregationName]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof aggregationChildren[aggregationName] === \"function\") {\n\t\t\t\t\t(mSettings[aggregationName] as { factory: Function }).factory = aggregationChildren[\n\t\t\t\t\t\taggregationName\n\t\t\t\t\t] as unknown as Function;\n\t\t\t\t} else {\n\t\t\t\t\t(mSettings[aggregationName] as { template: string | UI5Element }).template = aggregationChildren[aggregationName][0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmSettings[aggregationName] = aggregationChildren[aggregationName];\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Processes a binding toolkit expression property for function processProperties\n *\n * If the property is a constant, it compiles it as a constant. If the property is an aggregation,\n * it compiles the expression as an object. Otherwise, it compiles the expression normally.\n * @param settings The settings of the control\n * @param settingsKey The key of the setting being processed\n * @param bindingToolkitExpression The binding toolkit expression to process\n * @param allProperties All properties of the control\n */\nfunction processBindingToolkitExpression(\n\tsettings: Record<string, unknown>,\n\tsettingsKey: keyof typeof settings,\n\tbindingToolkitExpression: BindingToolkitExpression<unknown>,\n\tallProperties: Record<string, unknown>\n): void {\n\tif (isConstant(bindingToolkitExpression)) {\n\t\tsettings[settingsKey] = compileConstant(bindingToolkitExpression, false, true, true);\n\t} else if (!Object.hasOwnProperty.call(allProperties, settingsKey)) {\n\t\t// Aggregation case - we need to compile the expression but as an object\n\t\tif (isPathInModelExpression(bindingToolkitExpression)) {\n\t\t\tsettings[settingsKey] = { path: bindingToolkitExpression.path, model: bindingToolkitExpression.modelName };\n\t\t}\n\t} else {\n\t\tsettings[settingsKey] = compileExpression(bindingToolkitExpression);\n\t}\n}\n\n/**\n * Processes a string property for function processProperties\n *\n * If the property is not a binding expression and does not match the expected format,\n * it parses the value to provide the expected format. If the property is an event handler,\n * it logs an error.\n * @param settings The settings of the control\n * @param settingsKey The key of the setting being processed\n * @param value The string value to process\n * @param allEvents All events of the control\n * @param allProperties All properties of the control\n * @param metadata Metadata of the control\n */\nfunction processStringProperty(\n\tsettings: Record<string, unknown>,\n\tsettingsKey: keyof typeof settings,\n\tvalue: string,\n\tallEvents: Record<string, unknown>,\n\tallProperties: Record<string, unknown>,\n\tmetadata: ManagedObjectMetadata\n): void {\n\tif (!value.startsWith(\"{\")) {\n\t\tif (Object.hasOwnProperty.call(allEvents, settingsKey)) {\n\t\t\tLog.error(`Event handlers cannot be set as string in JSX, ${settingsKey} in ${metadata.getName()}`);\n\t\t}\n\t\tconst propertyType = (allProperties[settingsKey] as { getType?: Function })?.getType?.();\n\t\tif (propertyType && propertyType instanceof DataType && [\"boolean\", \"int\", \"float\"].includes(propertyType.getName())) {\n\t\t\tsettings[settingsKey] = propertyType.parseValue(value);\n\t\t}\n\t} else {\n\t\tsettings[settingsKey] = value;\n\t}\n}\n\n/**\n * Processes an object property for function processProperties.\n *\n * If the property is a promise, it adds it to the late properties map. If the property is a binding info holder,\n * it sets the binding info to the settings.\n * @param settings The settings of the control\n * @param settingsKey The key of the setting being processed\n * @param value The object value to process\n * @param lateProperties A map of the control's late properties\n */\nfunction processObjectProperty(\n\tsettings: Record<string, unknown>,\n\tsettingsKey: keyof typeof settings,\n\tvalue: unknown,\n\tlateProperties: Record<string, Promise<unknown>>\n): void {\n\tif ((value as Promise<unknown>).then) {\n\t\tlateProperties[settingsKey] = value as Promise<unknown>;\n\t\tdelete settings[settingsKey];\n\t} else if ((value as BindingInfoHolder<unknown>).__bindingInfo) {\n\t\tsettings[settingsKey] = (value as BindingInfoHolder<unknown>).__bindingInfo;\n\t}\n}\n\n/**\n * Processes the properties.\n *\n * If the property is a bindingToolkit expression we need to compile it.\n * Else if the property is set as string (compiled binding expression returns string by default even if it's a boolean, int, etc.) and it doesn't match with expected\n * format the value is parsed to provide expected format.\n * @param metadata Metadata of the control\n * @param settings Settings of the control\n * @returns A map of late properties that need to be awaited after the control is created\n */\nfunction processProperties(metadata: ManagedObjectMetadata, settings: Record<string, unknown>): Record<string, Promise<unknown>> {\n\tlet settingsKey: keyof typeof settings;\n\tconst lateProperties: Record<string, Promise<unknown>> = {};\n\tconst allEvents = metadata.getAllEvents();\n\tconst allProperties = metadata.getAllProperties();\n\n\tfor (settingsKey in settings) {\n\t\tconst value = settings[settingsKey];\n\t\tif (isBindingToolkitExpression(value)) {\n\t\t\tprocessBindingToolkitExpression(settings, settingsKey, value, allProperties);\n\t\t} else if (value !== null && typeof value === \"object\") {\n\t\t\tprocessObjectProperty(settings, settingsKey, value, lateProperties);\n\t\t} else if (typeof value === \"string\") {\n\t\t\tprocessStringProperty(settings, settingsKey, value, allEvents, allProperties, metadata);\n\t\t} else if (value === undefined) {\n\t\t\tdelete settings[settingsKey];\n\t\t}\n\t}\n\treturn lateProperties;\n}\n\n/**\n * Processes the command.\n *\n * Resolves the command set on the control via the intrinsic class attribute \"jsx:command\".\n * If no command has been set or the targeted event doesn't exist, no configuration is set.\n * @param metadata Metadata of the control\n * @param settings Settings of the control\n */\nfunction processCommand(metadata: ManagedObjectMetadata, settings: Record<string, unknown>): void {\n\tconst commandProperty = settings[\"jsx:command\"];\n\tif (commandProperty) {\n\t\tconst [command, eventName] = (commandProperty as string).split(\"|\");\n\t\tconst event = metadata.getAllEvents()[eventName];\n\t\tif (event && command.startsWith(\"cmd:\")) {\n\t\t\tsettings[event.name] = EventHandlerResolver.resolveEventHandler(command);\n\t\t}\n\t}\n\tdelete settings[\"jsx:command\"];\n}\n\nconst jsxControl = function <T extends Element>(\n\tControlType: NonAbstractClass<Control> | Function,\n\tsettings: NonControlProperties<T> & {\n\t\tkey: string;\n\t\tchildren?: Element | ControlProperties<T>;\n\t\tref?: Ref<T>;\n\t\tbinding?: string;\n\t\tclass?: string;\n\t\t[FL_DELEGATE]?: string;\n\t\t[DT_DESIGNTIME]?: string;\n\t\t[CORE_REQUIRE]?: string;\n\t},\n\tkey: string,\n\tjsxContext: JSXContext\n): Control | Control[] | undefined {\n\tlet targetControl: Control | Control[] | undefined;\n\n\tif ((ControlType as { isFragment?: boolean })?.isFragment) {\n\t\ttargetControl = settings.children as Control | Control[];\n\t} else if (isAControl(ControlType)) {\n\t\tconst metadata = ControlType.getMetadata();\n\t\tif (key !== undefined) {\n\t\t\tsettings[\"key\"] = key;\n\t\t}\n\t\tconst lateProperties = processProperties(metadata, settings);\n\t\tprocessCommand(metadata, settings);\n\t\tprocessAggregations(metadata, settings);\n\t\tconst classDef = settings.class;\n\t\tconst refDef = settings.ref;\n\t\tconst bindingDef = settings.binding;\n\t\tconst flDelegate = settings[FL_DELEGATE];\n\t\tconst dtDesigntime = settings[DT_DESIGNTIME];\n\t\tdelete settings.ref;\n\t\tdelete settings.class;\n\t\tdelete settings.binding;\n\t\tdelete settings[FL_DELEGATE];\n\t\tdelete settings[DT_DESIGNTIME];\n\t\tdelete settings[CORE_REQUIRE]; // Core require is not useful in control mode\n\t\tconst targetControlInstance = new ControlType(settings as $ControlSettings);\n\t\tif (classDef) {\n\t\t\ttargetControlInstance.addStyleClass(classDef);\n\t\t}\n\t\tif (refDef) {\n\t\t\trefDef.setCurrent(targetControlInstance as unknown as T);\n\t\t}\n\t\tconst customSettings = targetControlInstance.data(\"sap-ui-custom-settings\") ?? {};\n\t\tif (flDelegate) {\n\t\t\tcustomSettings[\"sap.ui.fl\"] ??= {};\n\t\t\tcustomSettings[\"sap.ui.fl\"].delegate = flDelegate;\n\t\t}\n\t\tif (dtDesigntime) {\n\t\t\tcustomSettings[\"sap.ui.dt\"] ??= {};\n\t\t\tcustomSettings[\"sap.ui.dt\"].designtime = dtDesigntime;\n\t\t}\n\t\tif (Object.keys(customSettings).length > 0) {\n\t\t\ttargetControlInstance.data(\"sap-ui-custom-settings\", customSettings);\n\t\t}\n\n\t\tif (bindingDef) {\n\t\t\tif (typeof bindingDef === \"string\") {\n\t\t\t\tconst bindingInfo = bindingParser(bindingDef);\n\t\t\t\tif (bindingInfo) {\n\t\t\t\t\ttargetControlInstance.bindElement({\n\t\t\t\t\t\tmodel: bindingInfo.model ?? undefined,\n\t\t\t\t\t\tpath: bindingInfo.path,\n\t\t\t\t\t\tparameters: bindingInfo.parameters ?? undefined\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttargetControlInstance.bindElement(bindingDef);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We consider it's an object\n\t\t\t\tObject.keys(bindingDef).forEach((bindingDefKey) => {\n\t\t\t\t\ttargetControlInstance.bindElement({ model: bindingDefKey, path: bindingDef[bindingDefKey] });\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfor (const latePropertiesKey in lateProperties) {\n\t\t\tlateProperties[latePropertiesKey]\n\t\t\t\t.then((value) => {\n\t\t\t\t\treturn targetControlInstance.setProperty(latePropertiesKey, value);\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tLog.error(`Couldn't set property ${latePropertiesKey} on ${ControlType.getMetadata().getName()}`, error, \"jsxControl\");\n\t\t\t\t});\n\t\t}\n\t\ttargetControl = targetControlInstance;\n\t} else if (typeof ControlType === \"function\") {\n\t\tconst controlTypeFn = ControlType;\n\t\ttargetControl = controlTypeFn(settings as $ControlSettings);\n\t} else {\n\t\ttargetControl = new Text({ text: \"Missing component \" + (ControlType as string) });\n\t}\n\n\treturn targetControl;\n};\n\nexport default jsxControl;\n"],"mappings":"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","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":51,"column":0},"map":{"version":3,"names":["jsxRenderManager","type","mSettings","key","renderManager","ref","openStart","mSetting","attr","class","split","forEach","className","openEnd","children","Array","isArray","child","text","toString","undefined","renderControl","close"],"sources":["./jsx-renderManager.ts"],"sourcesContent":["import type Control from \"sap/ui/core/Control\";\nimport type RenderManager from \"sap/ui/core/RenderManager\";\n\nconst jsxRenderManager = function (\n\ttype: string | Function,\n\tmSettings: Record<string, string>,\n\tkey: string,\n\trenderManager: RenderManager\n): Function {\n\treturn () => {\n\t\tif (typeof type === \"string\") {\n\t\t\tif (mSettings.ref) {\n\t\t\t\trenderManager.openStart(type, mSettings.ref);\n\t\t\t} else {\n\t\t\t\trenderManager.openStart(type);\n\t\t\t}\n\t\t\tfor (const mSetting in mSettings) {\n\t\t\t\tif (mSetting !== \"children\" && mSetting !== \"ref\" && mSetting !== \"class\") {\n\t\t\t\t\trenderManager.attr(mSetting, mSettings[mSetting]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mSettings.class) {\n\t\t\t\tmSettings.class.split(\" \").forEach((className) => {\n\t\t\t\t\trenderManager.class(className);\n\t\t\t\t});\n\t\t\t}\n\t\t\trenderManager.openEnd();\n\t\t}\n\t\tconst children = mSettings.children as (string | Function | Control) | (string | Function | Control)[];\n\t\tif (Array.isArray(children)) {\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tif (typeof child === \"string\" || typeof child === \"number\" || typeof child === \"boolean\") {\n\t\t\t\t\trenderManager.text(child.toString());\n\t\t\t\t} else if (typeof child === \"function\") {\n\t\t\t\t\tchild();\n\t\t\t\t} else if (child !== undefined) {\n\t\t\t\t\trenderManager.renderControl(child);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (typeof children === \"string\" || typeof children === \"number\" || typeof children === \"boolean\") {\n\t\t\trenderManager.text(children.toString());\n\t\t} else if (typeof children === \"function\") {\n\t\t\tchildren();\n\t\t} else if (children !== undefined) {\n\t\t\trenderManager.renderControl(children);\n\t\t}\n\n\t\tif (typeof type === \"string\") {\n\t\t\trenderManager.close(type);\n\t\t}\n\t};\n};\nexport default jsxRenderManager;\n"],"mappings":"AAAA;;;;yFAGA,MAAMA,EAAmB,SACxBC,EACAC,EACAC,EACAC,GAEA,MAAO,KACN,UAAWH,IAAS,SAAU,CAC7B,GAAIC,EAAUG,IAAK,CAClBD,EAAcE,UAAUL,EAAMC,EAAUG,IACzC,KAAO,CACND,EAAcE,UAAUL,EACzB,CACA,IAAK,MAAMM,KAAYL,EAAW,CACjC,GAAIK,IAAa,YAAcA,IAAa,OAASA,IAAa,QAAS,CAC1EH,EAAcI,KAAKD,EAAUL,EAAUK,GACxC,CACD,CACA,GAAIL,EAAUO,MAAO,CACpBP,EAAUO,MAAMC,MAAM,KAAKC,QAASC,IACnCR,EAAcK,MAAMG,IAEtB,CACAR,EAAcS,SACf,CACA,MAAMC,EAAWZ,EAAUY,SAC3B,GAAIC,MAAMC,QAAQF,GAAW,CAC5BA,EAASH,QAASM,IACjB,UAAWA,IAAU,iBAAmBA,IAAU,iBAAmBA,IAAU,UAAW,CACzFb,EAAcc,KAAKD,EAAME,WAC1B,MAAO,UAAWF,IAAU,WAAY,CACvCA,GACD,MAAO,GAAIA,IAAUG,UAAW,CAC/BhB,EAAciB,cAAcJ,EAC7B,GAEF,MAAO,UAAWH,IAAa,iBAAmBA,IAAa,iBAAmBA,IAAa,UAAW,CACzGV,EAAcc,KAAKJ,EAASK,WAC7B,MAAO,UAAWL,IAAa,WAAY,CAC1CA,GACD,MAAO,GAAIA,IAAaM,UAAW,CAClChB,EAAciB,cAAcP,EAC7B,CAEA,UAAWb,IAAS,SAAU,CAC7BG,EAAckB,MAAMrB,EACrB,EAEF,EAAE,OACaD,CAAgB","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":56,"column":0},"map":{"version":3,"names":["isBindingToolkitExpression","expression","_type","undefined","writeChildren","val","Array","isArray","join","escapeXMLAttributeValue","value","replace","addChildAggregation","aggregationChildren","aggregationName","child","trim","length","push","forEach","subChild","childKey","Object","keys","isAControl","children","getMetadata","FL_DELEGATE","DT_DESIGNTIME","CORE_REQUIRE","LOG_SOURCEPATH","CUSTOM_ENTITYTYPE","processObjectPropertyValue","childrenObject","namespaceAlias","propertyName","aggregationProperties","subPropName","childValue","childrenObjectElement","toString","namespacedProperty","processProperties","mSettings","metadataProperties","propertiesString","aggregationString","isControl","hasOwnProperty","propertyValue","type","getPath","compileExpression","outValue","JSON","stringify","separator","endsWith","every","propAsUI5Object","ui5object","prop","processCommand","settings","metadataEvents","commandProperty","command","eventName","split","event","startsWith","name","processAggregations","metadataAggregations","defaultAggregationName","aggregationChildKeys","writeOnlyDefaultAggregation","jsxXml","key","xmlNamespaceMap","overrideNodeName","metadata","controlName","getAllProperties","getAllEvents","getAllAssociations","getName","getAllAggregations","getDefaultAggregationName","properties","dependents","customData","aggregations","defaultAggregation","namespace","namesSplit","slice","tagName"],"sources":["./jsx-xml.ts"],"sourcesContent":["import type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression } from \"sap/fe/base/BindingToolkit\";\nimport type { ControlProperties, NonControlProperties } from \"sap/fe/base/jsx-runtime/jsx\";\nimport type BuildingBlockTemplatingBase from \"sap/fe/core/buildingBlocks/templating/BuildingBlockTemplatingBase\";\nimport type Control from \"sap/ui/core/Control\";\nimport type UI5Element from \"sap/ui/core/Element\";\nimport type Context from \"sap/ui/model/Context\";\n\nfunction isBindingToolkitExpression(\n\texpression: BindingToolkitExpression<unknown> | unknown\n): expression is BindingToolkitExpression<unknown> {\n\treturn (expression as BindingToolkitExpression<unknown>)?._type !== undefined;\n}\n\nconst writeChildren = function (val: string | string[]): string {\n\tif (Array.isArray(val)) {\n\t\treturn val.join(\"\");\n\t} else {\n\t\treturn val;\n\t}\n};\n\n/**\n * Some characters needs to be escaped when used as XML attribute value, otherwise this result in incorrect XML.\n * @param value\n * @returns The escaped xml attribute\n */\nfunction escapeXMLAttributeValue(value?: string): string | undefined {\n\treturn value?.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\");\n}\n\nconst addChildAggregation = function (\n\taggregationChildren: Record<string, (Control | string)[]>,\n\taggregationName: string,\n\tchild: string | Record<string, string>\n): void {\n\tif (child === undefined) {\n\t\treturn;\n\t}\n\tif (!aggregationChildren[aggregationName]) {\n\t\taggregationChildren[aggregationName] = [];\n\t}\n\tif (typeof child === \"string\") {\n\t\tif (child.trim().length > 0) {\n\t\t\taggregationChildren[aggregationName].push(child);\n\t\t}\n\t} else if (Array.isArray(child)) {\n\t\tchild.forEach((subChild) => {\n\t\t\taddChildAggregation(aggregationChildren, aggregationName, subChild);\n\t\t});\n\t} else {\n\t\tfor (const childKey of Object.keys(child)) {\n\t\t\taddChildAggregation(aggregationChildren, childKey, child[childKey]);\n\t\t}\n\t}\n};\n\nconst isAControl = function (children?: typeof Control | Function): children is typeof Control {\n\treturn !!(children as typeof Control)?.getMetadata;\n};\n\nconst FL_DELEGATE = \"fl:delegate\";\nconst DT_DESIGNTIME = \"dt:designtime\";\nconst CORE_REQUIRE = \"core:require\";\nconst LOG_SOURCEPATH = \"log:sourcePath\";\nconst CUSTOM_ENTITYTYPE = \"customData:entityType\";\n\nfunction processObjectPropertyValue(\n\tchildrenObject: Record<string, unknown>,\n\tnamespaceAlias: string | undefined,\n\tpropertyName: string\n): string {\n\t// This is called when the child is\n\tconst aggregationProperties: string[] = [];\n\tconst aggregationChildren: string[] = [];\n\tObject.keys(childrenObject).forEach((subPropName) => {\n\t\tconst childValue = childrenObject[subPropName];\n\t\tif (childValue !== undefined) {\n\t\t\tif (typeof childValue === \"object\") {\n\t\t\t\tif (Array.isArray(childValue)) {\n\t\t\t\t\taggregationChildren.push(`<${subPropName}>`);\n\t\t\t\t\tfor (const childrenObjectElement of childValue) {\n\t\t\t\t\t\taggregationChildren.push(\n\t\t\t\t\t\t\tprocessObjectPropertyValue(childrenObjectElement as Record<string, unknown>, namespaceAlias, subPropName)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\taggregationChildren.push(`</${subPropName}>`);\n\t\t\t\t} else {\n\t\t\t\t\t// if the property is a value it needs to be serialized as a children\n\t\t\t\t\t// <myObjectProp prop1='xxx', prop2='xxt'/>\n\t\t\t\t\taggregationChildren.push(\n\t\t\t\t\t\tprocessObjectPropertyValue(childValue as Record<string, unknown>, namespaceAlias, subPropName)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise it's part of the main object just as another property\n\t\t\t\taggregationProperties.push(`${subPropName}='${escapeXMLAttributeValue(childValue.toString())}'`);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst namespacedProperty = namespaceAlias ? `${namespaceAlias}:${propertyName}` : propertyName;\n\treturn `<${namespacedProperty} ${aggregationProperties.join(\" \")}>${aggregationChildren.join(\"\\n\")}</${namespacedProperty}>`;\n}\n\nfunction processProperties<T>(\n\tmSettings: Record<string, unknown>,\n\tmetadataProperties: Record<\n\t\tstring,\n\t\t{\n\t\t\tname?: string;\n\t\t\ttype?: string;\n\t\t}\n\t>,\n\tnamespaceAlias: string,\n\tpropertiesString: string[],\n\taggregationString: string[],\n\tisControl: boolean\n): void {\n\tObject.keys(metadataProperties).forEach((propertyName) => {\n\t\tif (mSettings.hasOwnProperty(propertyName) && mSettings[propertyName] !== undefined) {\n\t\t\tconst propertyValue = mSettings[propertyName];\n\t\t\tif (propertyName === CORE_REQUIRE) {\n\t\t\t\tpropertiesString.push(`xmlns:core=\"sap.ui.core\"`);\n\t\t\t}\n\t\t\tif (propertyName === FL_DELEGATE) {\n\t\t\t\tpropertiesString.push(`xmlns:fl=\"sap.ui.fl\"`);\n\t\t\t}\n\t\t\tif (propertyName === DT_DESIGNTIME) {\n\t\t\t\tpropertiesString.push(`xmlns:dt=\"sap.ui.dt\"`);\n\t\t\t}\n\t\t\tif (propertyName === LOG_SOURCEPATH) {\n\t\t\t\tpropertiesString.push(`xmlns:log=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.CustomData/1\"`);\n\t\t\t}\n\t\t\tif (propertyName === CUSTOM_ENTITYTYPE) {\n\t\t\t\tpropertiesString.push(`xmlns:customData=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.CustomData/1\"`);\n\t\t\t}\n\t\t\tif (propertyValue && typeof propertyValue === \"object\") {\n\t\t\t\tif (metadataProperties[propertyName].type === \"sap.ui.model.Context\") {\n\t\t\t\t\tpropertiesString.push(`${propertyName}='${(propertyValue as Context).getPath()}'`);\n\t\t\t\t} else if (isBindingToolkitExpression(propertyValue)) {\n\t\t\t\t\tpropertiesString.push(`${propertyName}='${escapeXMLAttributeValue(compileExpression(propertyValue))}'`);\n\t\t\t\t} else if (Array.isArray(propertyValue)) {\n\t\t\t\t\tif (propertyValue.length === 1) {\n\t\t\t\t\t\tconst outValue = typeof propertyValue[0] === \"string\" ? propertyValue[0] : JSON.stringify(propertyValue[0]);\n\t\t\t\t\t\tpropertiesString.push(`${propertyName}='${outValue}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst separator = metadataProperties[propertyName].type?.endsWith(\"[]\") ? \",\" : \" \";\n\t\t\t\t\t\tconst outValue = propertyValue.every((val) => typeof val === \"string\")\n\t\t\t\t\t\t\t? propertyValue.join(separator)\n\t\t\t\t\t\t\t: JSON.stringify(propertyValue);\n\t\t\t\t\t\tpropertiesString.push(`${propertyName}='${outValue}'`);\n\t\t\t\t\t}\n\t\t\t\t} else if (isControl) {\n\t\t\t\t\tconst propAsUI5Object = { ui5object: true, ...propertyValue };\n\t\t\t\t\tpropertiesString.push(`${propertyName}='${escapeXMLAttributeValue(JSON.stringify(propAsUI5Object))}'`);\n\t\t\t\t} else {\n\t\t\t\t\taggregationString.push(processObjectPropertyValue(propertyValue as Record<string, string>, undefined, propertyName));\n\t\t\t\t}\n\t\t\t} else if (propertyValue !== null) {\n\t\t\t\tconst prop = propertyValue as string | boolean | number;\n\t\t\t\tpropertiesString.push(`${propertyName}='${escapeXMLAttributeValue(prop.toString())}'`);\n\t\t\t}\n\t\t} else if (\n\t\t\tmSettings.children?.hasOwnProperty(propertyName) &&\n\t\t\tObject.keys((mSettings.children as ControlProperties<T>)?.[propertyName] ?? {}).length > 0\n\t\t) {\n\t\t\t// Object / Array properties are part of the `children` aggregation and as such still need to be processed as properties\n\t\t\tconst childrenObject = (mSettings.children as ControlProperties<T>)?.[propertyName] as unknown as Record<string, object>;\n\t\t\taggregationString.push(processObjectPropertyValue(childrenObject, namespaceAlias, propertyName));\n\t\t}\n\t});\n}\n\n/**\n * Processes the command.\n *\n * Resolves the command set on the control via the intrinsic class attribute \"jsx:command\".\n * If no command has been set or the targeted event doesn't exist, no configuration is set.\n * @param settings Metadata of the control\n * @param metadataEvents Settings of the control\n */\nfunction processCommand(\n\tsettings: Record<string, unknown>,\n\tmetadataEvents: Record<\n\t\tstring,\n\t\t{\n\t\t\tname: string;\n\t\t}\n\t>\n): void {\n\tconst commandProperty = settings[\"jsx:command\"];\n\tif (commandProperty) {\n\t\tconst [command, eventName] = (commandProperty as string).split(\"|\");\n\t\tconst event = metadataEvents[eventName];\n\t\tif (event && command.startsWith(\"cmd:\")) {\n\t\t\tsettings[event.name] = command;\n\t\t}\n\t}\n\tdelete settings[\"jsx:command\"];\n}\n\nfunction processAggregations(\n\tmSettings: Record<string, unknown>,\n\tmetadataAggregations: Record<string, object>,\n\tnamespaceAlias: string,\n\tdefaultAggregationName: string | undefined,\n\tpropertiesString: string[],\n\taggregationString: string[]\n): Record<string, string[]> {\n\tconst aggregationChildren: Record<string, string[]> = {};\n\taddChildAggregation(aggregationChildren, defaultAggregationName ?? \"customData\", mSettings.children as Record<string, string>);\n\tconst aggregationChildKeys = Object.keys(aggregationChildren);\n\tlet writeOnlyDefaultAggregation = false;\n\tif (aggregationChildKeys.length === 1 && aggregationChildKeys[0] === defaultAggregationName) {\n\t\twriteOnlyDefaultAggregation = true;\n\t}\n\tObject.keys(metadataAggregations).forEach((aggregationName) => {\n\t\tif (aggregationChildren.hasOwnProperty(aggregationName) && aggregationChildren[aggregationName].length > 0) {\n\t\t\tif (aggregationName === defaultAggregationName && writeOnlyDefaultAggregation) {\n\t\t\t\taggregationString.push(`${writeChildren(aggregationChildren[aggregationName])}`);\n\t\t\t} else {\n\t\t\t\taggregationString.push(\n\t\t\t\t\t`<${namespaceAlias}:${aggregationName}>\n\t\t\t\t\t\t${writeChildren(aggregationChildren[aggregationName])}\n\t\t\t\t\t</${namespaceAlias}:${aggregationName}>`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (mSettings.hasOwnProperty(aggregationName) && mSettings[aggregationName] !== undefined) {\n\t\t\tif (typeof mSettings[aggregationName] === \"object\") {\n\t\t\t\tpropertiesString.push(`${aggregationName}='${JSON.stringify(mSettings[aggregationName])}'`);\n\t\t\t} else {\n\t\t\t\t// In some case the aggregation expect a string value (like for the tooltip), in this case we set it directly as a property\n\t\t\t\tpropertiesString.push(`${aggregationName}='${escapeXMLAttributeValue(mSettings[aggregationName] as string)}'`);\n\t\t\t}\n\t\t}\n\t});\n\treturn aggregationChildren;\n}\n\nconst jsxXml = function <T>(\n\ttype: typeof Control | typeof BuildingBlockTemplatingBase | \"slot\",\n\tmSettings: NonControlProperties<T> & { key?: string; children?: UI5Element | ControlProperties<T>; name?: string },\n\tkey: string | undefined,\n\txmlNamespaceMap: Record<string, string>,\n\toverrideNodeName?: string\n): string {\n\tlet metadata;\n\tlet metadataProperties: Record<string, { name?: string; type?: string }>;\n\tlet metadataEvents: Record<string, { name: string }>;\n\tlet controlName;\n\tlet metadataAggregations;\n\tlet defaultAggregationName: string | undefined;\n\tlet isControl = false;\n\tif (type === \"slot\") {\n\t\treturn `<slot name=\"${mSettings.name}\"/>`;\n\t} else if (isAControl(type)) {\n\t\tmetadata = type.getMetadata();\n\t\tmetadataProperties = metadata.getAllProperties();\n\t\tmetadataProperties = { ...metadataProperties, ...metadata.getAllEvents(), ...metadata.getAllAssociations() };\n\t\tmetadataEvents = metadata.getAllEvents();\n\t\tcontrolName = metadata.getName();\n\t\tmetadataAggregations = metadata.getAllAggregations();\n\t\tdefaultAggregationName = metadata.getDefaultAggregationName();\n\t\tisControl = true;\n\t} else {\n\t\tmetadata = type.metadata;\n\t\tmetadataProperties = { ...metadata.properties };\n\t\tmetadataAggregations = { ...{ dependents: {}, customData: {} }, ...metadata.aggregations };\n\t\tmetadataEvents = {};\n\t\tdefaultAggregationName = metadata.defaultAggregation;\n\t\tcontrolName = metadata.namespace + \".\" + metadata.name;\n\t}\n\tconst namesSplit = controlName.split(\".\");\n\tif (key !== undefined) {\n\t\tmSettings[\"key\"] = key;\n\t}\n\n\tmetadataProperties[\"class\"] = { name: \"class\" };\n\tmetadataProperties[\"id\"] = { name: \"id\" };\n\tmetadataProperties[\"binding\"] = { name: \"binding\" };\n\tmetadataProperties[FL_DELEGATE] = { name: FL_DELEGATE };\n\tmetadataProperties[DT_DESIGNTIME] = { name: DT_DESIGNTIME };\n\tmetadataProperties[CORE_REQUIRE] = { name: CORE_REQUIRE };\n\tmetadataProperties[LOG_SOURCEPATH] = { name: LOG_SOURCEPATH };\n\tmetadataProperties[CUSTOM_ENTITYTYPE] = { name: CUSTOM_ENTITYTYPE };\n\tmetadataProperties[\"xmlns:fl\"] = { name: FL_DELEGATE };\n\tmetadataProperties[\"xmlns:dt\"] = { name: DT_DESIGNTIME };\n\tmetadataProperties[\"xmlns:core\"] = { name: CORE_REQUIRE };\n\tmetadataProperties[\"xmlns:log\"] = { name: LOG_SOURCEPATH };\n\tif (controlName === \"sap.ui.core.Fragment\") {\n\t\tmetadataProperties[\"fragmentName\"] = { name: \"fragmentName\" };\n\t}\n\tconst namespace = namesSplit.slice(0, -1);\n\tconst name = namesSplit[namesSplit.length - 1];\n\tlet namespaceAlias = namespace[namespace.length - 1];\n\tif (xmlNamespaceMap[namespace.join(\".\")]) {\n\t\tnamespaceAlias = xmlNamespaceMap[namespace.join(\".\")];\n\t}\n\tlet tagName = `${namespaceAlias}:${name}`;\n\tconst propertiesString: string[] = [];\n\tconst aggregationString: string[] = [];\n\tprocessCommand(mSettings, metadataEvents);\n\tprocessProperties(mSettings, metadataProperties, namespaceAlias, propertiesString, aggregationString, isControl);\n\tprocessAggregations(mSettings, metadataAggregations, namespaceAlias, defaultAggregationName, propertiesString, aggregationString);\n\tif (overrideNodeName) {\n\t\ttagName = overrideNodeName;\n\t}\n\treturn `<${tagName} xmlns:${namespaceAlias}=\"${namespace.join(\".\")}\" ${propertiesString.join(\" \")}>${aggregationString.join(\n\t\t\"\"\n\t)}</${tagName}>`;\n};\nexport default jsxXml;\n"],"mappings":"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","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":61,"column":0},"map":{"version":3,"names":["renderNextAsXML","renderNextUsingRenderManager","xmlNamespaceMap","jsx","ControlType","mSettings","key","jsxControl","jsxContext","undefined","jsxRenderManager","jsxXml","renderUsingRenderManager","renderManager","control","renderMethod","returnValue","defineXMLNamespaceMap","async","namespaceMap","renderAsXML","getContext","withContext","context","functionToExecute","callBackReturn"],"sources":["./jsx.ts"],"sourcesContent":["import jsxControl from \"sap/fe/base/jsx-runtime/jsx-control\";\nimport jsxRenderManager from \"sap/fe/base/jsx-runtime/jsx-renderManager\";\nimport jsxXml from \"sap/fe/base/jsx-runtime/jsx-xml\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport type Control from \"sap/ui/core/Control\";\nimport type Element from \"sap/ui/core/Element\";\nimport type RenderManager from \"sap/ui/core/RenderManager\";\n\nimport type View from \"sap/ui/core/mvc/View\";\n\ntype ControlPropertyNames<T> = {\n\t[K in keyof T]: T[K] extends string | boolean | Function | number | undefined | string[] ? never : K;\n}[keyof T];\nexport type ControlProperties<T> = Partial<Record<ControlPropertyNames<T>, Element>> & {\n\t[k: string]: Element;\n};\nexport type NonControlProperties<T> = Partial<Omit<T, ControlPropertyNames<T>>>;\nexport type CommandProperties = `cmd:${string}|${string}`;\n\nlet renderNextAsXML = false;\nlet renderNextUsingRenderManager: RenderManager | undefined;\nlet xmlNamespaceMap: Record<string, string> = {};\nconst jsx = function <T>(\n\tControlType: typeof Control,\n\tmSettings: NonControlProperties<T> & { key: string; children?: Element | ControlProperties<T> },\n\tkey: string\n): string | Control | Control[] | undefined {\n\tif (!renderNextAsXML && !renderNextUsingRenderManager) {\n\t\treturn jsxControl(ControlType, mSettings, key, jsxContext);\n\t} else if (renderNextUsingRenderManager !== undefined) {\n\t\treturn jsxRenderManager(\n\t\t\tControlType as unknown as string,\n\t\t\tmSettings as Record<string, string>,\n\t\t\tkey,\n\t\t\trenderNextUsingRenderManager\n\t\t) as unknown as string | Control | Control[] | undefined;\n\t} else {\n\t\treturn jsxXml(ControlType, mSettings, key, xmlNamespaceMap);\n\t}\n};\njsx.renderUsingRenderManager = function (renderManager: RenderManager, control: Control, renderMethod: Function): void {\n\trenderNextUsingRenderManager = renderManager;\n\tconst returnValue = renderMethod(control);\n\trenderNextUsingRenderManager = undefined;\n\treturnValue();\n};\njsx.defineXMLNamespaceMap = async function (namespaceMap: Record<string, string>, renderMethod: Function): Promise<unknown> {\n\txmlNamespaceMap = namespaceMap;\n\tconst returnValue = await renderMethod();\n\txmlNamespaceMap = {};\n\treturn returnValue;\n};\n/**\n * Indicates that the next JSX call should be rendered as XML.\n * @param renderMethod The method that needs to be rendered as XML\n * @returns The XML representation of the control\n */\njsx.renderAsXML = function <T>(renderMethod: () => T): T {\n\trenderNextAsXML = true;\n\tconst returnValue = renderMethod();\n\trenderNextAsXML = false;\n\treturn returnValue;\n};\n\nexport type Ref<T extends Element> = {\n\tcurrent?: T;\n\tsetCurrent(oControlInstance: T): void;\n};\n\nexport type JSXContext = {\n\townerControl?: Control & {\n\t\tcontrolReferences?: Record<string, Element>;\n\t\tcontrolReferencesId?: number;\n\t};\n\tview?: View;\n\tappComponent?: AppComponent;\n};\nlet jsxContext: JSXContext = {};\njsx.getContext = function (): JSXContext {\n\treturn jsxContext;\n};\n\njsx.withContext = function <T>(context: JSXContext, functionToExecute: () => T): T {\n\tjsxContext = context;\n\tconst callBackReturn = functionToExecute();\n\tjsxContext = {};\n\treturn callBackReturn;\n};\n\nexport default jsx;\n"],"mappings":"AAAA;;;;mMAmBA,IAAIA,EAAkB,MACtB,IAAIC,EACJ,IAAIC,EAA0C,CAAC,EAC/C,MAAMC,EAAM,SACXC,EACAC,EACAC,GAEA,IAAKN,IAAoBC,EAA8B,CACtD,OAAOM,EAAWH,EAAaC,EAAWC,EAAKE,EAChD,MAAO,GAAIP,IAAiCQ,UAAW,CACtD,OAAOC,EACNN,EACAC,EACAC,EACAL,EAEF,KAAO,CACN,OAAOU,EAAOP,EAAaC,EAAWC,EAAKJ,EAC5C,CACD,EACAC,EAAIS,yBAA2B,SAAUC,EAA8BC,EAAkBC,GACxFd,EAA+BY,EAC/B,MAAMG,EAAcD,EAAaD,GACjCb,EAA+BQ,UAC/BO,GACD,EACAb,EAAIc,sBAAwBC,eAAgBC,EAAsCJ,GACjFb,EAAkBiB,EAClB,MAAMH,QAAoBD,IAC1Bb,EAAkB,CAAC,EACnB,OAAOc,CACR,EAMAb,EAAIiB,YAAc,SAAaL,GAC9Bf,EAAkB,KAClB,MAAMgB,EAAcD,IACpBf,EAAkB,MAClB,OAAOgB,CACR,EAeA,IAAIR,EAAyB,CAAC,EAC9BL,EAAIkB,WAAa,WAChB,OAAOb,CACR,EAEAL,EAAImB,YAAc,SAAaC,EAAqBC,GACnDhB,EAAae,EACb,MAAME,EAAiBD,IACvBhB,EAAa,CAAC,EACd,OAAOiB,CACR,EAAE,OAEatB,CAAG","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":66,"column":0},"map":{"version":3,"names":["jsx"],"sources":["./jsxs.ts"],"sourcesContent":["import jsx from \"sap/fe/base/jsx-runtime/jsx\";\n\nexport default jsx;\n"],"mappings":"AAAA;;;;iHAEeA,CAAG","ignoreList":[],"sourceRoot":"jsx-runtime"}},{"offset":{"line":71,"column":0},"map":{"version":3,"names":["feBaseNamespace","_exports","thisLib","Library","init","name","apiVersion","dependencies","types","interfaces","controls","elements","version","noLibraryCSS"],"sources":["./library.ts"],"sourcesContent":["import Library from \"sap/ui/core/Lib\";\n/**\n * Library providing the base functionality of the runtime for SAP Fiori elements for OData V4.\n * @namespace\n * @public\n */\nexport const feBaseNamespace = \"sap.fe.base\";\n\nconst thisLib = Library.init({\n\tname: \"sap.fe.base\",\n\tapiVersion: 2,\n\tdependencies: [\"sap.ui.core\"],\n\ttypes: [],\n\tinterfaces: [],\n\tcontrols: [],\n\telements: [],\n\t// eslint-disable-next-line no-template-curly-in-string\n\tversion: \"${version}\",\n\tnoLibraryCSS: true\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n}) as any;\n\nexport default thisLib;\n"],"mappings":"AAAA;;;;8FAMO,MAAMA,EAAkB,cAAcC,EAAAD,kBAE7C,MAAME,EAAUC,EAAQC,KAAK,CAC5BC,KAAM,cACNC,WAAY,EACZC,aAAc,CAAC,eACfC,MAAO,GACPC,WAAY,GACZC,SAAU,GACVC,SAAU,GAEVC,QAAS,UACTC,aAAc,OAEL,OAEKX,CAAO","ignoreList":[],"sourceRoot":""}},{"offset":{"line":76,"column":0},"map":{"version":3,"names":[],"sources":["library-preload.js?bundle-code-0"],"mappings":"AAAA;AACA","sourcesContent":["sap.ui.require.preload({\n"],"sourceRoot":""}}]}