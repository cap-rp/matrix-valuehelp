{"version":3,"file":"HookSupport.js","names":["registeredInstances","registeredHandlers","hookable","execution","target","propertyKey","descriptor","indexableTarget","toString","fn","cExTInstanceHookMap","this","hookedHandlers","push","handlers","index","indexOf","splice","oldValue","value","async","returnValue","bind","arguments","handler","_exports","isAlreadyRegistered","existingRegistrations","newRegistration","find","r","name","method","targetMethod","hooks","Symbol","controllerExtensionHandler","String","constructor","Object","defineProperty","initControllerExtensionHookHandlers","controller","registeredHooks","deepClone","indexableController","registeredHook","handlerFunction","getView","attachBeforeExit","removeControllerExtensionHookHandlers","propagateHookFromMixin","source","getOwnPropertyDescriptor","create","xmlViewPreprocessor","_caller","_settings","sourceView","getController","macroAPIChild","findAggregatedObjects","s","isA","managedObject"],"sources":["./HookSupport.ts"],"sourcesContent":["import deepClone from \"sap/base/util/deepClone\";\nimport type { ExtensionOverrideExecution } from \"sap/fe/base/ClassSupport\";\nimport type Controller from \"sap/ui/core/mvc/Controller\";\nimport type XMLView from \"sap/ui/core/mvc/XMLView\";\n/**\n * This type is to be extended with all controller extensions and methods that are hookable.\n */\ntype HookableControllerExtensions = {\n\teditFlow: {\n\t\tonAfterSave: true;\n\t\tonBeforeSave: true;\n\t};\n\tinlineEditFlow: {\n\t\tinlineEditEnd: true;\n\t\tinlineEditStart: true;\n\t};\n\tcollaborationManager: {\n\t\tcollectAvailableCards: true;\n\t};\n\tpaginator: {\n\t\tinitialize: true;\n\t};\n\trouting: {\n\t\tonAfterBinding: true;\n\t};\n};\n\ntype HandlerConfiguration<CExtName extends keyof HookableControllerExtensions> = {\n\tname: CExtName;\n\tmethod: keyof HookableControllerExtensions[CExtName];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype HandlerRegistration = HandlerConfiguration<any> & { targetMethod: string; handlerFunction?: Function };\n\ntype FunctionMap = {\n\t[key: string]: Function;\n};\ntype DeepFunctionMap = {\n\t[key: string]: FunctionMap;\n};\ntype HookMap = {\n\thookedHandlers: {\n\t\t[key: string]: Function[];\n\t};\n};\n\n// Use two arrays as we cannot index a map through an arbitrary object instance\nconst registeredInstances: Function[] = [];\nconst registeredHandlers: HandlerRegistration[][] = [];\n\n/**\n * Marks a controller extension method to be hookable by generating additional methods that can be used to attach and detach handlers at runtime.\n * @param execution\n * @returns A method decorator\n */\nexport function hookable(execution: ExtensionOverrideExecution): MethodDecorator {\n\treturn function (target: unknown, propertyKey: string | symbol, descriptor: PropertyDescriptor) {\n\t\tconst indexableTarget = target as FunctionMap;\n\n\t\tindexableTarget[`attach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers = {};\n\t\t\t}\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers[propertyKey.toString()]) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()] = [];\n\t\t\t}\n\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()].push(fn);\n\t\t};\n\t\tindexableTarget[`detach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tconst handlers = cExTInstanceHookMap.hookedHandlers[propertyKey.toString()];\n\t\t\tconst index = handlers.indexOf(fn);\n\t\t\tif (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t};\n\n\t\tconst oldValue = descriptor.value;\n\t\tif (execution === \"BeforeAsync\" || execution === \"AfterAsync\") {\n\t\t\tdescriptor.value = async function (...args: unknown[]): Promise<unknown> {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"AfterAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tawait handler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"BeforeAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t} else {\n\t\t\tdescriptor.value = function (...args: unknown[]): unknown {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"After\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\thandler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"Before\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t}\n\t};\n}\n\n/**\n * Checks whether a newRegistration is already included in some existingRegistrations by comparing all relevant attributes.\n * @param existingRegistrations\n * @param newRegistration\n * @returns Result of the check\n */\nfunction isAlreadyRegistered(existingRegistrations: HandlerRegistration[], newRegistration: HandlerRegistration): boolean {\n\treturn !!existingRegistrations.find(\n\t\t(r) => r.name === newRegistration.name && r.method === newRegistration.method && r.targetMethod === newRegistration.targetMethod\n\t);\n}\n\nexport const hooks = Symbol(\"hooks\");\n\n/**\n * Registers a method as controller extension hook handler.\n *\n * Currently, only methods of runtime building blocks are supported.\n * @param name Controller extension to hook into\n * @param method Method to hook into\n * @returns A method decorator\n */\nexport function controllerExtensionHandler<CExtName extends keyof HookableControllerExtensions>(\n\tname: CExtName,\n\tmethod: keyof HookableControllerExtensions[CExtName]\n): MethodDecorator {\n\treturn function (target: { constructor: Function & { [hooks]?: HandlerRegistration[] } }, propertyKey: string) {\n\t\tconst newRegistration = { name, method: String(method), targetMethod: propertyKey };\n\t\tconst index = registeredInstances.indexOf(target.constructor);\n\t\tif (!target.constructor[hooks]) {\n\t\t\tObject.defineProperty(target.constructor, hooks, {\n\t\t\t\tvalue: []\n\t\t\t});\n\t\t}\n\t\ttarget.constructor[hooks]?.push(newRegistration);\n\t\t// We need to check if this exact handler is already registered as handlers are registered statically (on the constructor)\n\t\tif (index !== -1 && !isAlreadyRegistered(registeredHandlers[index], newRegistration)) {\n\t\t\tregisteredHandlers[index].push(newRegistration);\n\t\t} else {\n\t\t\tregisteredInstances.push(target.constructor);\n\t\t\tregisteredHandlers.push([newRegistration]);\n\t\t}\n\t} as MethodDecorator;\n}\n\n/**\n * Initializes all controller extension handlers registered for a given target.\n * @param target Target class to initialize the handlers for\n * @param target.constructor\n * @param controller PageController instance to get the controller extensions instances from\n */\nexport function initControllerExtensionHookHandlers(\n\ttarget: { constructor: Function & { [hooks]?: HandlerRegistration[] } } & { [hooks]?: HandlerRegistration[] },\n\tcontroller: Controller\n): void {\n\tif (target.constructor[hooks]) {\n\t\tlet registeredHooks = target.constructor[hooks];\n\t\ttarget[hooks] = deepClone(registeredHooks);\n\t\tregisteredHooks = target[hooks]!;\n\t\tconst indexableTarget = target as unknown as FunctionMap;\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tfor (const registeredHook of registeredHooks) {\n\t\t\tregisteredHook.handlerFunction = indexableTarget[registeredHook.targetMethod].bind(target);\n\t\t\tindexableController[registeredHook.name][`attach${String(registeredHook.method)}`](registeredHook.handlerFunction);\n\t\t\tcontroller.getView()?.attachBeforeExit(() => {\n\t\t\t\tindexableController[registeredHook.name][`detach${String(registeredHook.method)}`](registeredHook.handlerFunction);\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport function removeControllerExtensionHookHandlers(\n\ttarget: { constructor: Function & { [hooks]?: HandlerRegistration[] } } & { [hooks]?: HandlerRegistration[] },\n\tcontroller: Controller\n): void {\n\tif (target[hooks]) {\n\t\tconst registeredHooks = target[hooks];\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tfor (const registeredHook of registeredHooks) {\n\t\t\tindexableController[registeredHook.name]?.[`detach${String(registeredHook.method)}`]?.(registeredHook.handlerFunction);\n\t\t}\n\t}\n}\n\nexport function propagateHookFromMixin(\n\ttarget: Function & { [hooks]?: HandlerRegistration[] },\n\tsource: Function & { [hooks]?: HandlerRegistration[] }\n): void {\n\tif (source[hooks]) {\n\t\tif (target[hooks]) {\n\t\t\ttarget[hooks]!.splice(0, 0, ...source[hooks]);\n\t\t} else {\n\t\t\tObject.defineProperty(target, hooks, Object.getOwnPropertyDescriptor(source, hooks) || Object.create([]));\n\t\t}\n\t}\n}\n\nexport function xmlViewPreprocessor(source: object, _caller?: unknown, _settings?: object): void {\n\tconst sourceView = source as XMLView;\n\tconst controller = sourceView.getController() as Controller | undefined;\n\tif (controller) {\n\t\tconst macroAPIChild = sourceView.findAggregatedObjects(true, (s) => s.isA(\"sap.fe.macros.MacroAPI\"));\n\t\tfor (const managedObject of macroAPIChild) {\n\t\t\tinitControllerExtensionHookHandlers(managedObject, controller);\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]}